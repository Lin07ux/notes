转摘：[CSS秘密花园： 通过亮度调节去强调(De-emphasize)](http://www.w3cplus.com/css3/css-secrets/de-emphasize-by-dimming.html)

很多时候，我们需要通过在元素背后添加一个半透明的深色叠加来让内容变暗，强调并提醒用户关注某个UI元素。例如，lightboxes 和“quick tours”接口经常需要这种效果：
![深色半透明](http://cnd.qiniu.lin07ux.cn/2016-04-12%20de-emphasize.png)

完成这个效果有多种方式，下面来分别分析。

### 额外元素背景色
完成这个效果的最常见的技术是添加一个额外的 HTML 元素，设置一个背景色来调节亮度，CSS 代码如下：

```css
.overlay { /* 暗色背景元素 */
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background: rgba(0,0,0,.8);
}
.lightbox { /* 需要凸显出的元素 */
    position: absolute;
    z-index: 1;
    /* [rest of styling] */
}
```

深色叠加的目的是把用户的注意力放到我们希望用户注意的元素上边，然后元素后边的内容都变暗。 .lightbox 有一个更高的 z-index ，可以让它放置在深色叠加之上。

这样是没有问题的，但是它需要一个额外的 HTML 元素，也就是说效果不能只通过 CSS 应用。那怎么避免呢？看下面的方法

### 基于伪元素
我们可以使用伪元素来消除对额外 HTML 元素的需求，将伪元素应用上面的 css 效果即可。如下：

```css
body.dimmed::before {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    z-index: 1;
    background: rgba(0,0,0,.8);
}
```

这是一个稍微好点的解决方案，这也意味着我们现在可以直接通过 CSS 应用这种效果。但是，这不是非常方便，因为 <body> 元素可能已经应用了一些其它的东西在它的 ::before 伪元素之上了。

我们可以通过给元素本身的`::before`伪元素应用深色叠加，并给它一个`z-index:-1`来解决这个问题，这样它就位于我们的元素之下了，还解决了可移植性的问题。但是：它并不能给我们控制 Z 轴的位置提供很精确的控制，因为它可能最终会被放在我们的元素下边（这是期望的）或放在我们的元素以及它的几个父元素下边(这是要避免的)。

此外，伪元素的一个问题在于：**伪元素没有自己的 JavaScript 事件**。当使用一个单独的元素来进行叠加的时候，我们可以给它添加事件句柄——例如：当用户点击叠加层的时候，关闭高亮窗口。如果我们在同一个想要强调的元素上使用伪元素，想要检测用户是否点击了覆盖层或者元素是很棘手的。当然，如果需要伪元素响应事件这就是一个比较好的解决方案了。

### box-shadow 的解决方案
对于简单的用例或原型设计，我们可以采用`box-shadow`的`spread`半径，把它增大到你在每一边希望指定的大小。也就是说我们可以创建一个非常大的零偏移零模糊的`shadow`，用一种迅速又随性的方式来模拟覆盖层：

```css
box-shadow: 0 0 0 999px rgba(0,0,0,.8);
```

如果只是这样做，会有一个明显的问题：在非常大分辨率（ > 2000px ）的地方它就无法覆盖到了。
我们可以通过使用一个再大一点的数字来缓解这种情况，或者通过使用`viewport`单位来完全地解决这个问题，这样我们可以确保“overlay”总会比我们的 viewport 大。因为我们不能使用不同的水平和垂直 spread 半径值，viewport 单位应该是`vmax`。

> 1vmax 等于 1vw 或 1vh 中的取较大值。 100vw 等于 viewport 的 width，同样，100vh 等于 viewport 的 height 值。

能够满足我们需求的最小值是 50vmax ，因为它在每一边都会添加，所以我们的覆盖层的最终尺寸是 100vmax +我们的元素的尺寸：

```css
box-shadow: 0 0 0 50vmax rgba(0,0,0,.8);
```

虽然能覆盖到整个视窗了，但是还是有两个比较严重的问题：

- 首先，因为我们的元素的尺寸是和 viewport 相关的，和页面没有关系，当我们滚动页面的时候，会看到覆盖层的边界，除非元素是`position: fixed;`定位的，或者是页面本身不够长，不能滚动。所以我建议你只对`fixed`定位的元素，或页面很小没有滚动的情况下使用这种技术。
- 第二，使用一个单独的元素（或伪元素）作为覆盖层并不仅仅会将用户的注意力引导到我们想要的元素上。它还会阻止鼠标和页面的其余部分交互，因为它捕获了指针事件。`box-shadow`没有这个属性。因此，它只会在视觉上帮助用户将注意力引导到特定的元素上，而不会自己捕获任何鼠标交互事件。至于这是否可以接受，要看你具体的使用情况。

### backdrop 解决方案
如果你想要变成焦点的元素是一个模式对话框`<dialog>`元素(<dialog> 元素通过它的`showModal()`方法显示)，默认它已经有一个覆盖层了。这种原生的覆盖还可以通过`::backdrop`伪元素来添加样式，例如，让它变暗一点：

```css
dialog::backdrop {
    background: rgba(0, 0, 0, .8);
}
```

这种方法唯一需要注意的地方是：在编写的时候，浏览器的支持是非常有限的，所以一定要在使用前检查其当前状态。记住，即使它不被支持，如果对话框没有覆盖层的话，也不会影响到什么东西，因为它只是一个用户体验的改善。


