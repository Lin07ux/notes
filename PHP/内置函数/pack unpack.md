PHP 中，`pack`和`unpack`是用于字符串和二进制之间互相转换的。而`ord`和`chr`则是用于单字节字符的，另外还有一个函数`bin2hex`则是在二进制和十六进制之间进行转换的。

> 转摘：[PHP中的pack和unpack函数](https://www.tlanyan.me/php-pack-and-unpack-functions/)

### 1. 字符和字节

在理解这两个函数之前，需要理解字符和字节的关系：字节是计算机存储和操作的最小单位，字符是人们阅读的最小单位；字节是存储（物理）概念，字符是逻辑概念；字节代表数据（内涵和本质），字符代表其含义；字符由字节组成，对同一组字节，根据不同的字符集解析出来的可以是不同的字符。

再举一个常用的例子说明字符和字节的区别。开发中常用 md5 算法获取数据的哈希值，算法返回一个 128 位(bit)的数据(16 个字节)。为方便查看其值，人们约定成俗地用十六进制表示，结果就是熟知的 32 位长度的字符串（不区分大小写）。32 长度字符串不是 md5 算法的必然结果，16 字节数据才是其本质。如果愿意，也可以用一个小于 2^128 的数字表示哈希结果，也可以将 16 字节 base64 编码后作为其结果。所以常用的 32 位哈希值与 md5 返回的 16 字节关系为：一个是字符表示，另一个则是其本质(字符数组)（PHP 的 md5 函数第二个参数值为 true 便可得到 16 字节数据，或 hash 函数第三个参数为 true ）。

根据硬件不同，同一个字符对应的字节也会有所不同，占用字节大小可能为 1、2、4、8 等。对于占用多个字节的时候，就涉及到字节序的问题了，比如对于 42 这个数字，在占用 4 个字节的情况下，前面三个字节应该都是`0`，如果是大端序（低位字节存放在地址高位），四个字节分别是`0 0 0 42`；如果是小端序，结果则是`42 0 0 0`。

PHP 中没有判断字节序的函数，可以使用`pack`和`ord`来进行判断：

```php
function bigEndian() : bool {
    $data = 0x1200;
    $bytes = pack("s", $data);

    return ord($bytes[0]) === 0x12;
}
```

### 2. pack

`pack`按照指定的格式将数据打包成二进制字符串，语法如下：

```
pack ( string $format [, mixed $args [, mixed $... ]] ) : string
```

形式上与`printf`系列函数相同：第一个参数是格式字符串，其余参数是要格式化的参数。不同之处在于`pack`函数的格式中不能出现元字符和量词外的其他字符，所以不需要`%`符号。

`pack`函数的元字符主要分为三类：

1.	字符串：`a`、`A`格式将数据转成字符串，功能上与`sprintf`类似，例如整数 32 转换成字符串`"32"`；
2. 字节：`h`和`H`格式对字节进行 16 进制编码，区别在于低位还是高位在前，功能上与`dechex`等函数类似；
3. char/short/int/long/float/double 六种基本类型：`c/s/i/l`等；将数据转换成对应类型的字节数组，除`char`类型外（暂）没有其他函数可替代；

> 注意：`char`和`a/A`等的区别是，`a/A`等输入为字符(串)，而`s/S`的输入要求是小于 256 的整数，输入字符会得到 0。



### 3. unpack

`unpack`是`pack`的反向操作：将字节数组解析成有意义的数据。其函数原型为：

```
unpack ( string $format , string $data [, int $offset = 0 ] ) : array
```

`pack`是将一组参数打包成一个字节组，而`unpack`则是将一个字节组进行解包，得到输入时的参数数组。

返回一个数组，其键分别是什么呢？这便是格式化参数(`$format`)在`pack`和`unpack`的不同之处：`unpack`应该对释放出来的数据命名，用`/`分隔各组数据。由于格式化参数允许有非元字符和量词外的字符，为了区分数据，不同数据间的`/`分隔符必不可少。

```php
$bytes = pack("iaa*", 42, ":", "The answer to life, the universe and everything");
// "*\0\0\0:The answer to life, the universe and everything"

$result = unpack("inumber/acolon/a*word", $bytes);
print_r($result);
// Array
// (
//    "num" => 42,
//    "colon" => ":",
//    "word" => "The answer to life, the universe and everything",
// )
```

如果你不对数据命名，默认的 1、2、3... 就用来当作键值。如果有多组数据，每组都用同样的下标，会导致数据覆盖，最终只留下键为`1`的数据。例如上例中`unpack`的格式化参数为`"inumber/a/a*"`，则输出结果为：

```
Array
(
   "num" => 42,
   1 => "The answer to life, the universe and everything",
)
```

官方文档如下：

> CautionIf you do not name an element, numeric indices starting from 1 are used. Be aware that if you have more than one unnamed element, some data is overwritten because the numbering restarts from 1 for each element.

### 4. format

format 字符串由格式代码组成，后面跟着一个可选的重复参数。重复参数可以是一个整数值或者`*`值来重复到输入数据的末尾。对于`a`、`A`、`h`、`H`格式化代码，其后的重复参数指定了给定数据将会被使用几个字符串，对于`@`,其后的数字表示放置剩余数据的绝对定位（之前的数据将会被空字符串填充），对于其他所有内容，重复数量指定消耗多少数据并将其打包到生成的二进制字符串中。

代码   |  描述
------ | -------------
a      | 以 NUL 字节填充字符串
A      | 以 SPACE(空格)填充字符串
h      | 十六进制字符串，低位在前
H      | 十六进制字符串，高位在前
c      | 有符号字符
C      | 无符号字符
s      | 有符号短整型(16位，主机字节序)
S      | 无符号短整型(16位，主机字节序)
n      | 无符号短整型(16位，大端字节序)
v      | 无符号短整型(16位，小端字节序)
i      | 有符号整型(机器相关大小字节序)
I      | 无符号整型(机器相关大小字节序)
l      | 有符号长整型(32位，主机字节序)
L      | 无符号长整型(32位，主机字节序)
N      | 无符号长整型(32位，大端字节序)
V      | 无符号长整型(32位，小端字节序)
q      | 有符号长长整型(64位，主机字节序)
Q      | 无符号长长整型(64位，主机字节序)
J      | 无符号长长整型(64位，大端字节序)
P      | 无符号长长整型(64位，小端字节序)
f      | 单精度浮点型(机器相关大小)
g      | 单精度浮点型(机器相关大小，小端字节序)
G      | 单精度浮点型(机器相关大小，大端字节序)
d      | 双精度浮点型(机器相关大小)
e      | 双精度浮点型(机器相关大小，小端字节序)
E      | 双精度浮点型(机器相关大小，大端字节序)
x      | NUL 字节
X      | 回退一字节
Z      | 以 NUL 字节填充字符串空白(PHP 5.5 中新加入的)
@      | NUL 填充到绝对位置

这里的`a`、`A`填充的意思是，将打包后的内容填充到指定的长度，如果不指定数值，则默认为 1；如果指定的长度小于字符串长度，则会对其进行截断；如果指定的长度比字符串的长度长，则会使用空格或 NULL 字节(`\0`)在字符串后面进行填充。


