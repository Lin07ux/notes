函数将一个代码块作为整体，调用函数的时候就可以通过函数名来执行该代码块。

## 一、基础

### 1.1 定义函数

Python 中定义一个函数需要使用关键词`def`(定义类中的方法也一样)，它必须后跟函数名称和带括号的形式参数列表。

如下，可以创建一个输出任意范围内 Fibonacci 数列的函数：

```python
def fib(n):
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

函数体的第一行可以（可选的）是字符串文字注释，表示函数的文档字符串或 docstring。有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；在编写的代码中包含文档字符串是一种很好的做法。

### 1.2 返回值

函数中可以使用`return`语句返回一个值，表示该函数执行的结果。执行`return`语句之后，其后的代码将不会执行了。

事实上，即使没有`return`语句的函数也会返回一个值，尽管它是一个相当无聊的值。这个值称为`None`（它是内置名称）。一般来说解释器不会打印出单独的返回值`None`，如果想看到它，可以使用`print()`。

比如，对于上面的 Fibonacci 数列的函数，传入参数 0 时的结果：

```
>>> fib(0)
>>> print(fib(0))
None
```

一个函数只能返回一个值，这个值可以是原始数据(Integer、Float、Boolean)，也可以是一个对象(List、Set、Object)。所以如果有多个值需要返回，可以将这些值都放在一个数组中然后返回。

## 二、参数

> 转摘：[Python 学习笔记 - 函数 - 参数](https://mp.weixin.qq.com/s/AViF-Rtnko4D4PbymkSLtQ)

每个函数都可以有零个、一个或多个参数。这些参数有些可以是必选的，有些是可选；有些没有默认值，有些有默认值；有些参数是按位置定义，有些参数则可以和其他参数合用一个位置。

总结来说，就是：按定义和传参方式，参数可分作位置(positional)和键值(keyword)两类。允许设置默认值和余参收集，但不支持参数嵌套。

### 2.1 形参和实参

形参出现在函数定义的参数列表中，可视作函数局部变量，仅能在函数内部使用。而实参由调用方提供，通常以复制方式将值传递个形参。形参在函数调用结束后销毁，而实参则受调用方作用域影响。不同于形参以变量形式存在，实参可以是变量、常量、表达式等，总之须有确定值可供复制传递。

不管实参是名字、引用，还是指针，都以值复制方式传递，随后形参变化不会影响实参。当然，对该指针或引用目标的修改，与此无关。也即是说，函数中的代码不会改变传入的实参的值，但是实参所指向的对象的数据是可以变化的。

### 2.2 位置参数

位置参数按排列顺序，又可细分为：

1.	普通位置参数，零到多个。
2.	有默认值的位置参数，零到多个。
3.	单星号收集参数，仅一个。

其中，单星号收集参数会将多余的参数值收纳到一个*元组对象*里。所谓多余，是指对普通参数和有默认值参数全部赋值以后的结余。在调用函数的时候，单星号收集参数是不能通过名称为其指定值的。

另外，按位置传递的实参需要在按名称传递的实参前面，否则会造成语法错误。

示例如下：

```Python
def test(a, b, c = 3, d = 4, *args):
     print(locals())
```

其中：

* `a`、`b`是普通的位置参数
* `c`、`d`是有默认值的位置参数
* `args`是单星号收集参数

对于这个函数，不同的调用方式会有不同的输出：

```
>>> test(1, 2, 33)  # 不足以填充普通参数和默认值参数。
{'args': (), 'd': 4, 'c': 33, 'b': 2, 'a': 1}
>>> 
>>> test(1, 2, 33, 44, 5, 6, 7) # 填充完普通和默认值参数后，收集剩余参数值。
{'args': (5, 6, 7), 'd': 44, 'c': 33, 'b': 2, 'a': 1}
>>> 
>>> test(1, 2, 33, 44, args = (5, 6, 7)) # 不能对收集参数命名传参
TypeError: test() got an unexpected keyword argument 'args'
>>> test(a = 1, c = 4, 2)# 按位置传递的参数需要在按名称传递之前
SyntaxError: positional argument follows keyword argument
```

### 2.3 普通键值参数

键值参数是指调用函数时，可以通过名称来传递参数，可以乱序传递实参而不按照定义时形参的位置传递。键值参数有如下几种：

* 普通键值参数，零到多个
* 有默认值的键值参数，零到多个
* 双星号收集键值参数，零或一个

其中，双星号收集参数和单星号收集参数类似，只是其会将多余的键值参数值收纳到一个*字典对象*里，而且双星号键值收集仅针对命名传参，对多余的位置参数没兴趣。

> 键值收集参数会维持传入顺序(PEP468)。如键值参数存在次序依赖，那么此功能就有实际意义。还有，收集参数并不计入函数的`__code__.co_argcount`中。

普通键值参数和普通的位置参数在一般使用上相同，但是也有一些细微的差别，这常常是因函数的定义和调用的不同而导致的。

如下：

```Python
def test(a, b, **kwargs):
    print(locals())
```

这里：`a`、`b`可以作为位置参数传参，也可以作为普通的键值参数传参，`kwargs`则是双星号收集参数。

```
>>> def test(a, b, *args, **kwargs):
...    print(kwargs)
>>> test(1, 2, 3, x = 1, y = 2) # 多余位置参数被 args 收集，其他命名参数被 kwargs 收集
{'x': 1, 'y': 2}
>>> test(b = 2, a = 1, x = 3, y = 4)
{'x': 3, 'y': 4}
>>> 
>>> def test(a, b, **kwargs): pass
>>> test(1, 2, 3, x = 1) # 键值收集仅针对命名传参，对多余的位置参数没兴趣
TypeError: test() takes 2 positional arguments but 3 were given
```

同样，不应对键值收集参数命名传参。其结果是弄巧成拙，被当作普通参数收集：

```
>>> def test(**kwargs):
        print(kwargs)
>>> test(kwargs = {"a":1, "b":2})  # 被当作普通键值参数收集，kwargs["kwargs"]。
{'kwargs': {'a': 1, 'b': 2}}
>>> test(**{"a":1, "b":2})  # 这才是正确的收集姿势。
{'a': 1, 'b': 2}
```

### 2.4 keyword-only 键值参数

keyword-only 键值参数则只能通过命名方式传参，否则将会引起错误。

keyword-only 的键值参数需要与位置参数列表分隔边界，可以使用星号`*`分隔，也可以使用单星号位置收集参数(如`*args`)分隔。但只取其一，不能同时出现。

无默认值的 keyword-only 必须显式命名传参，否则视为普通位置参数。比如：

```Python
def test(a, b, *, c):
    print(locals())
```

这里的`c`由于被`*`分隔，所以其就成了 keyword-only 键值参数。由于没有默认值，所以它必须显示命名传参，否则会被作为位置参数解析。如下所示：

```
>>> test(1, 2, 3) TypeError: test() takes 2 positional arguments but 3 were given >>> >>> test(1, 2) TypeError: test() missing 1 required keyword-only argument: 'c'
>>>
>>> test(1, 2, c = 3)
{'c': 3, 'b': 2, 'a': 1}
```

即便没有位置参数，keyword-only 也须按规则传递。比如：

```
>>> def test(*, c): pass
>>> 
>>> test(1)
TypeError: test() takes 0 positional arguments but 1 was given
>>> 
>>> test(c = 1)
>>> 
```

### 2.5 默认值

参数默认值允许省略实参传值，让函数调用更加灵活。尤其是那些参数众多，或具有缺省设定的函数。

但需注意，**默认值**在函数创建时生成，**保存到函数的特定属性`__defaults__`，为每次调用所共享**。如此，其行为**类似静态局部变量**，会“记住”以往调用状态。这也就意味着：如果默认值为可变类型，且在函数内做了修改，那么后续调用会观察到本次改动，导致默认值失去原本含义。

比如，对于如下的函数定义：

```Python
def test(a, x = [1, 2]):
    x.append(a)
    print(x)
```

该函数内部改变了参数`x`默认值的数据，这将会影响到下一次调用。

```
>>> test.__defaults__
([1, 2],)
>>> test(3)
[1, 2, 3]
>>> test.__defaults__
([1, 2, 3],)
>>> 
>>> test(4)
[1, 2, 3, 4]
>>> test.__defaults__
([1, 2, 3, 4],)
>>> test(3, [1])
[1, 3]
>>> test.__defaults__
([1, 2, 3, 4],)
```

可以看到，每次没有为`x`参数传入数值的时候，都会改变`x`的默认值的内容，并影响下次的调用。故建议**默认值选用不可变类型，或以 None 表示可忽略**。

如下，通过判断`x`参数是否传入的内容来决定是否新建一个列表：

```Python
def test(a, x = None):
    x = x or []                # 忽略时，主动新建。
    x.append(a)
    return x
```

这样定义之后，每次调用就不会影响到后续的调用了：

```
>>> test(1)
[1]
>>> test(2)
[2]
>>> test(3, [1, 2])  # 提供非默认值实参。
[1, 2, 3]
```

函数参数的默认值静态局部变量也有一定的用处，比如作为函数调用计数等。但相对来说，还是为函数创建一个状态属性更好。毕竟变量为函数内部使用，而参数属对外接口。所创建属性等同函数对象生命周期，不会随函数调用结束而终结：

```Python
def test():
    test.__x__ = hasattr(test, "__x__") and test.__x__ + 1 or 1
    print(test.__x__)
```

### 2.6 形参赋值过程

通过以上对函数形参的分类，总结解释器对形参赋值过程如下：

1.	按顺序对位置参数赋值。
2.	按命名方式对指定参数赋值。
3.	收集多余的位置参数。
4.	收集多余键值参数。
5.	为没有赋值的参数设置默认值。
6.	检查参数列表，确保非收集参数都已赋值。

> 收集参数`args`、`kwargs`属习惯性命名，非强制。

对应形参顺序，实参也有些基本规则：

* 无默认值参数，必须有实参传入。
* 键值参数总是以命名方式传入。
* 不能对同一参数重复传值。 
> 无论是以位置和命名两种不同方式，还是多个星号展开里有重复主键，都不能导致对同一参数重复传值。

## 三、作用域

函数的执行会引入一个用于函数局部变量的新符号表。更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，最后是内置名称表。因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在`global`语句中定义的全局变量，或者是在`nonlocal`语句中定义的外层函数的变量），尽管它们可以被引用。

在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过*按值调用*传递的（其中*值*始终是对象*引用*而不是对象的值）。当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。



