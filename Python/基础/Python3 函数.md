函数将一个代码块作为整体，调用函数的时候就可以通过函数名来执行该代码块。Python 中函数是第一类对象(first-class object)，可作为参数和返回值传递。

## 一、基础

> 转摘：[Python 学习笔记 - 函数 - 定义](https://mp.weixin.qq.com/s/x5qXXBvJMokyiB0GhjxXyQ)

### 1.1 定义函数

Python 中定义一个函数需要使用关键词`def`(定义类中的方法也一样)，它必须后跟函数名称和带括号的形式参数列表。

如下，可以创建一个输出任意范围内 Fibonacci 数列的函数：

```python
def fib(n):
    """Print a Fibonacci series up to n."""
    a, b = 0, 1
    while a < n:
        print(a, end=' ')
        a, b = b, a+b
    print()

# Now call the function we just defined:
fib(2000)
# 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597
```

函数体的第一行可以（可选的）是字符串文字注释，表示函数的文档字符串或 docstring。有些工具使用文档字符串自动生成在线或印刷文档，或者让用户以交互式的形式浏览代码；在编写的代码中包含文档字符串是一种很好的做法。

### 1.2 主要属性

函数也是一种对象，Python 为函数对象添加了一些隐藏属性：

* `__code__.co_varnames` 参数及变量名列表
* `__code__.co_consts` 指令常量
* `__defaults__` 参数默认值字典
* `__dict__` 函数实例属性
* `__name__` 函数名称，编译期静态绑定，与运行期变量名引用无关
* `__qualname__` 函数在模块中的完整定义路径

```Python
def test(x, y = 10):
    x += 100
    print(x, y)

print(test) # <function test>
print(test.__code__) # <code object>
print(test.__code__.co_varnames) # ('x', 'y')
print(test.__code__.co_consts) # (None, 100)
print(test.__defaults__) # (10,)
print(test.__name__) # test

print(test(1)) # 101 10
test.__defaults__ = (1234,) # 修改默认值
print(test(1)) # 101 1234

print(test.__dict__) # {}
test.abc = "hello, world" # 为函数实例添加属性
print(test.__dict__) # {'abc': 'hello, world'}
```

### 1.3 内部原理

事实上，`def`是运行期指令。以代码对象为参数，创建函数实例，并在当前上下文与指定名字相关联。

> 可以理解为：`def`指令会将代码块作为一个只读变量与函数名称变量进行绑定关联。

正因如此，可用`def`指令以单个代码对象为模版创建多个函数实例，比如：

> 但需要区别的是，多个实例和多个名字引用同一实例并非一回事。

```Python
def make(n):
    ret = []

    for i in range(n):
        def test(): print("hello")  # test = make_function(code)

        print(id(test), id(test.__code__)) 
        ret.append(test)

    return ret

make(3)
# 输出类似如下，不同实例，相同代码
# 4428346232 4425999248
# 4430389456 4425999248
# 4430390136 4425999248
```

同一名字空间，名字只能与单个目标关联。如此，就不能实现函数重载(overload)。而另一方面，如果不在同一个命名空间中，则可以出现相同名称的函数，比如下面的嵌套示例中，内外函数名字虽相同，但分属不同层次名字空间，依优先级而定，并不冲突：

```Python
def test():
    print("outer test")

    def test():
        print("inner test")

    return test

x = test() # outer test
print(x) # <function __main__.test.<locals>.test>
x() # inner test
```

### 1.4 lambda 匿名函数

lambda 表达式也称为匿名函数，相比普通函数，其内容只能是单个表达式（函数调用也属表达式），不能使用语句，而且不能提供函数名。除此之外，其使用方法与普通函数并无差异。

lambda 表达式可以接受参数，在参数后面用`:`分隔的就是表示式。调用 lambda 的时候，会运行表达式的值，并将其作为结果返回。

```Python
add = lambda x, y: x + y
print(add) # <function __main__.<lambda>>
add(1, 2) # 3
```

另外需要注意的是，lambda 表达式的`__name__`属性值总是`<lambda>`。这意味着，如果没有将 lambda 赋值给变量，那么其在当前语句被执行完成之后，将无法再次被调用。这也使得 lambda 在某些场合远比普通函数更加灵活和自由。

```Python
map(lambda x: x ** 2, range(3)) # 直接作为参数

[lambda: print("hello") for i in range(3)] # 作为推导式输出结果

(lambda x: print(x))("hello") # 直接运行

test = lambda x: (lambda y: x + y) # 将另一个 lambda 作为返回值，支持闭包
add = test(2)
add(3) # 5

ops = { # 构建方法表
    "add": lambda x, y: x + y,
    "sub": lambda x, y: x - y,
}
ops["add"](2, 3) # 5
```

## 二、参数

> 转摘：[Python 学习笔记 - 函数 - 参数](https://mp.weixin.qq.com/s/AViF-Rtnko4D4PbymkSLtQ)

每个函数都可以有零个、一个或多个参数。这些参数有些可以是必选的，有些是可选；有些没有默认值，有些有默认值；有些参数是按位置定义，有些参数则可以和其他参数合用一个位置。

总结来说，就是：按定义和传参方式，参数可分作位置(positional)和键值(keyword)两类。允许设置默认值和余参收集，但不支持参数嵌套。

### 2.1 形参和实参

形参出现在函数定义的参数列表中，可视作函数局部变量，仅能在函数内部使用。而实参由调用方提供，通常以复制方式将值传递个形参。形参在函数调用结束后销毁，而实参则受调用方作用域影响。不同于形参以变量形式存在，实参可以是变量、常量、表达式等，总之须有确定值可供复制传递。

不管实参是名字、引用，还是指针，都以值复制方式传递，随后形参变化不会影响实参。当然，对该指针或引用目标的修改，与此无关。也即是说，函数中的代码不会改变传入的实参的值，但是实参所指向的对象的数据是可以变化的。

### 2.2 位置参数

位置参数按排列顺序，又可细分为：

1.	普通位置参数，零到多个。
2.	有默认值的位置参数，零到多个。
3.	单星号收集参数，仅一个。

其中，单星号收集参数会将多余的参数值收纳到一个*元组对象*里。所谓多余，是指对普通参数和有默认值参数全部赋值以后的结余。在调用函数的时候，单星号收集参数是不能通过名称为其指定值的。

另外，按位置传递的实参需要在按名称传递的实参前面，否则会造成语法错误。

示例如下：

```Python
def test(a, b, c = 3, d = 4, *args):
     print(locals())
```

其中：

* `a`、`b`是普通的位置参数
* `c`、`d`是有默认值的位置参数
* `args`是单星号收集参数

对于这个函数，不同的调用方式会有不同的输出：

```
>>> test(1, 2, 33)  # 不足以填充普通参数和默认值参数。
{'args': (), 'd': 4, 'c': 33, 'b': 2, 'a': 1}
>>> 
>>> test(1, 2, 33, 44, 5, 6, 7) # 填充完普通和默认值参数后，收集剩余参数值。
{'args': (5, 6, 7), 'd': 44, 'c': 33, 'b': 2, 'a': 1}
>>> 
>>> test(1, 2, 33, 44, args = (5, 6, 7)) # 不能对收集参数命名传参
TypeError: test() got an unexpected keyword argument 'args'
>>> test(a = 1, c = 4, 2)# 按位置传递的参数需要在按名称传递之前
SyntaxError: positional argument follows keyword argument
```

### 2.3 普通键值参数

键值参数是指调用函数时，可以通过名称来传递参数，可以乱序传递实参而不按照定义时形参的位置传递。键值参数有如下几种：

* 普通键值参数，零到多个
* 有默认值的键值参数，零到多个
* 双星号收集键值参数，零或一个

其中，双星号收集参数和单星号收集参数类似，只是其会将多余的键值参数值收纳到一个*字典对象*里，而且双星号键值收集仅针对命名传参，对多余的位置参数没兴趣。

> 键值收集参数会维持传入顺序(PEP468)。如键值参数存在次序依赖，那么此功能就有实际意义。还有，收集参数并不计入函数的`__code__.co_argcount`中。

普通键值参数和普通的位置参数在一般使用上相同，但是也有一些细微的差别，这常常是因函数的定义和调用的不同而导致的。

如下：

```Python
def test(a, b, **kwargs):
    print(locals())
```

这里：`a`、`b`可以作为位置参数传参，也可以作为普通的键值参数传参，`kwargs`则是双星号收集参数。

```
>>> def test(a, b, *args, **kwargs):
...    print(kwargs)
>>> test(1, 2, 3, x = 1, y = 2) # 多余位置参数被 args 收集，其他命名参数被 kwargs 收集
{'x': 1, 'y': 2}
>>> test(b = 2, a = 1, x = 3, y = 4)
{'x': 3, 'y': 4}
>>> 
>>> def test(a, b, **kwargs): pass
>>> test(1, 2, 3, x = 1) # 键值收集仅针对命名传参，对多余的位置参数没兴趣
TypeError: test() takes 2 positional arguments but 3 were given
```

同样，不应对键值收集参数命名传参。其结果是弄巧成拙，被当作普通参数收集：

```
>>> def test(**kwargs):
        print(kwargs)
>>> test(kwargs = {"a":1, "b":2})  # 被当作普通键值参数收集，kwargs["kwargs"]。
{'kwargs': {'a': 1, 'b': 2}}
>>> test(**{"a":1, "b":2})  # 这才是正确的收集姿势。
{'a': 1, 'b': 2}
```

### 2.4 keyword-only 键值参数

keyword-only 键值参数则只能通过命名方式传参，否则将会引起错误。

keyword-only 的键值参数需要与位置参数列表分隔边界，可以使用星号`*`分隔，也可以使用单星号位置收集参数(如`*args`)分隔。但只取其一，不能同时出现。

无默认值的 keyword-only 必须显式命名传参，否则视为普通位置参数。比如：

```Python
def test(a, b, *, c):
    print(locals())
```

这里的`c`由于被`*`分隔，所以其就成了 keyword-only 键值参数。由于没有默认值，所以它必须显示命名传参，否则会被作为位置参数解析。如下所示：

```
>>> test(1, 2, 3) TypeError: test() takes 2 positional arguments but 3 were given >>> >>> test(1, 2) TypeError: test() missing 1 required keyword-only argument: 'c'
>>>
>>> test(1, 2, c = 3)
{'c': 3, 'b': 2, 'a': 1}
```

即便没有位置参数，keyword-only 也须按规则传递。比如：

```
>>> def test(*, c): pass
>>> 
>>> test(1)
TypeError: test() takes 0 positional arguments but 1 was given
>>> 
>>> test(c = 1)
>>> 
```

### 2.5 默认值

参数默认值允许省略实参传值，让函数调用更加灵活。尤其是那些参数众多，或具有缺省设定的函数。

默认值是在*定义过程*中在函数定义处计算的，所以可以设置函数的默认值为某个变量。如：

```Python
i = 5

def f(arg=i):
    print(arg)

i = 6
f()
# 输出：5
```

另外需要注意的是，**默认值**在函数创建时**保存到函数的特定属性`__defaults__`，为每次调用所共享**。如此，其行为**类似静态局部变量**，会“记住”以往调用状态。这也就意味着：如果默认值为可变类型，且在函数内做了修改，那么后续调用会观察到本次改动，导致默认值失去原本含义。

比如，对于如下的函数定义：

```Python
def test(a, x = [1, 2]):
    x.append(a)
    print(x)
```

该函数内部改变了参数`x`默认值的数据，这将会影响到下一次调用。

```
>>> test.__defaults__
([1, 2],)
>>> test(3)
[1, 2, 3]
>>> test.__defaults__
([1, 2, 3],)
>>> 
>>> test(4)
[1, 2, 3, 4]
>>> test.__defaults__
([1, 2, 3, 4],)
>>> test(3, [1])
[1, 3]
>>> test.__defaults__
([1, 2, 3, 4],)
```

可以看到，每次没有为`x`参数传入数值的时候，都会改变`x`的默认值的内容，并影响下次的调用。故建议**默认值选用不可变类型，或以 None 表示可忽略**。

如下，通过判断`x`参数是否传入的内容来决定是否新建一个列表：

```Python
def test(a, x = None):
    x = x or [] # 忽略时，主动新建。
    x.append(a)
    return x
```

这样定义之后，每次调用就不会影响到后续的调用了：

```
>>> test(1)
[1]
>>> test(2)
[2]
>>> test(3, [1, 2])  # 提供非默认值实参。
[1, 2, 3]
```

函数参数的默认值静态局部变量也有一定的用处，比如作为函数调用计数等。但相对来说，还是为函数创建一个状态属性更好。毕竟变量为函数内部使用，而参数属对外接口。所创建属性等同函数对象生命周期，不会随函数调用结束而终结：

```Python
def test():
    test.__x__ = hasattr(test, "__x__") and test.__x__ + 1 or 1
    print(test.__x__)
```

### 2.6 形参赋值过程

通过以上对函数形参的分类，总结解释器对形参赋值过程如下：

1.	按顺序对位置参数赋值。
2.	按命名方式对指定参数赋值。
3.	收集多余的位置参数。
4.	收集多余键值参数。
5.	为没有赋值的参数设置默认值。
6.	检查参数列表，确保非收集参数都已赋值。

> 收集参数`args`、`kwargs`属习惯性命名，非强制。

对应形参顺序，实参也有些基本规则：

* 无默认值参数，必须有实参传入。
* 键值参数总是以命名方式传入。
* 不能对同一参数重复传值。 
> 无论是以位置和命名两种不同方式，还是多个星号展开里有重复主键，都不能导致对同一参数重复传值。

## 三、返回值

函数中可以使用`return`语句返回一个值，表示该函数执行的结果。执行`return`语句之后，其后的代码将不会执行了。

事实上，即使没有`return`语句的函数也会返回一个值，尽管它是一个相当无聊的值。这个值称为`None`（它是内置名称）。一般来说解释器不会打印出单独的返回值`None`，如果想看到它，可以使用`print()`。

比如，对于上面的 Fibonacci 数列的函数，传入参数 0 时的结果：

```
>>> fib(0)
>>> print(fib(0))
None
```

一个函数只能返回一个值，这个值可以是原始数据(Integer、Float、Boolean)，也可以是一个对象(List、Set、Object)。所以如果有多个值需要返回，可以将这些值都放在一个数组中然后返回。

## 三、作用域

函数的执行会引入一个用于函数局部变量的新符号表。更确切地说，函数中所有的变量赋值都将存储在局部符号表中；而变量引用会首先在局部符号表中查找，然后是外层函数的局部符号表，最后是内置名称表。因此，全局变量和外层函数的变量不能在函数内部直接赋值（除非是在`global`语句中定义的全局变量，或者是在`nonlocal`语句中定义的外层函数的变量），尽管它们可以被引用。

在函数被调用时，实际参数（实参）会被引入被调用函数的本地符号表中；因此，实参是通过*按值调用*传递的（其中*值*始终是对象*引用*而不是对象的值）。当一个函数调用另外一个函数时，将会为该调用创建一个新的本地符号表。



