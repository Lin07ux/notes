## 一、简介

在最新的 MYSQL 版本里，每个表最多可以有 64 个索引。

从索引的实现上，可以将其分为聚集索引与非聚集索引(或称辅助索引或二级索引)两大类。从索引的实际应用中，可以细分为普通索引、唯一索引、主键索引、联合索引、外键索引、全文索引这几种。

对于 MySQL 来说，两种主要的引擎的索引和数据结构是不同的：

* **InnoDB 可以看做是聚集索引**，因为它的 B+ 树的叶结点包含了完整的数据记录。InnoDB 的数据文件本身就是索引文件，表数据文件本身就是按 B+Tree 组织的一个索引结构，这棵树的叶节点的 data 域保存了完整的数据记录。这棵 B+数的索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。InnoDB 的辅助索引的 data 域存储相应记录主键的值而不是地址。换句话说，InnoDB 的所有辅助索引都引用主键作为 data 域。

* **MyISAM 为非聚集索引**，其B+ 树的叶结点只是存储了数据的地址。MyISAM 引擎使用 B+Tree 作为索引结构，叶节点的 data 域存放的是数据记录的地址。在 MyISAM 中，主索引和辅助索引在结构上没有任何区别，只是主索引要求 key 是唯一的，而辅助索引的 key 可以重复。

<div style="text-align: center">
    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1559564341860.png" align="center"/>
</div>

目前主要用到的是 InnoDB 引擎，下面主要以此引擎作为介绍。

### 1.1 特点

InnoDB 由于其索引结构特性，在使用时有如下特点：

* **回表**：使用辅助索引查询时，由于找到的是主键值，要获取具体的记录值，则还需要使用找到的主键值再次查找，这个过程就被称为回表。
* **索引覆盖**：使用索引查找时，如果所需要获取的值只有索引值，不包含其他记录值，那么就可以直接返回找到的索引的值，也不会存在回表现象，这就被称为索引覆盖。索引覆盖对普通索引，特别是联合索引查询中非常有用，可以大大提升查询效率。
* **数据页**：数据行并不是存储引擎管理的最小存储单位，索引只能够帮助查询定位到某个数据页，每一次磁盘读写的最小单位为也是数据页，而一个数据页内存储了多个数据行，然后数据库引擎会通过内部处理找到具体的记录行。这对获取一系列连续的数据行会有比较大的效率提升。
* **选择性**：选择性定义为不重复的索引值和数据总记录条数的比值。索引的选择性越高，那么其查询效率也越高，价值也越大。譬如对于性别这种参数，由于一般只为男、女两种，所以为其建立索引根本没有意义。         

> 计算某列的选择性：
> 
> ```sql
> SELECT count(DISTINCT(title)) / count(*) AS Selectivity FROM titles;
> ```

### 1.2 开销和成本

索引是昂贵的，不要添加多余的索引。**在多数情况下，扩展索引比添加一个新的索引要好**。

索引的开销主要有如下两个方面：

* 写 - 更新索引常常是数据库写操作的主要开销；
* 读 - 需要在硬盘和内存开销空间; 查询优化中需要额外的开销。

索引的成本表现在：

* 长主键索引(使所有相应的二级索引 变得更长、更慢)
* 随机主键索引(会插入导致大量的页面分割)
* 越长的索引通常越慢
* 低区分度的索引是低劣的
* 相关索引是不太昂贵的(insert_time 与自增 id 是相关的)

## 二、索引类别

### 2.1 主键 Primary Key

在 InnoDB 内部，表数据是按主键排列分布的，其查找速度是最快的，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。即使表中没有适合做主键的列，也推荐采用一个自动增长的整数主键(代理键)，那么这个表在增加数据的时候是顺序存放的，而且后续在别的表参考该外键查询的时候也会得到优化。

如果在创建表时没有显式地定义主键，则 InnoDB 存储引擎会按如下方式选择或创建主键：

1. 首先表中是否有非空的唯一索引(Unique NOT NULL)，如果有则该列即为主键。
2. 不符合上述条件，InnoDB 存储引擎自动创建一个 6 个字节大小的指针，用户不能查看或访问。

主键最好应该有如下特性：

* 主键要尽量越短越好，否则如果还建了很多普通索引，将造成普通索引占有很大的物理空间。
* 主键最好是顺序递增的，否则在 InnoDB 引擎下，UUID 的无序性可能会引起数据位置频繁变动，严重影响性能。

自增 ID 与 UUID 的对比如下：

* 唯一性：自增 ID 很容易会被暴力破解，数据迁移的时候，特别是发生表格合并这种操作的时候，会不可避免地存在冲突。UUID 则能够保证唯一性，彻底避免冲突。
* 并发性：自增 ID 并且高并发的情况下，竞争自增锁会降低数据库的吞吐能力。UUID 则能够在应用层生成 UUID，提高数据库的吞吐能力。
* 键长度：自增字段的长度较 UUID 小很多，这会对检索的性能有较大影响。Innodb 引擎进行数据检索时，也是先根据索引找到主键，然后根据主键找到记录；这样在主键长度短的情况下，会有较好的读性能。
* 数据库索引：InnoDB 中表数据是按照主键顺序存放的，在写入数据时候如果发生了随机 IO，那么就会频繁地移动磁盘块。当数据量大的时候，写的短板将非常明显。自增 ID 中新增的数据可以默认按序排列，对于性能有很大的提升；UUID 则主键之间没有顺序规律。

### 2.2 唯一键

唯一键在插入和修改的时候会校验该索引对应的列的值是否已经存在。唯一键与主键的对比如下：

* 主键就是唯一索引，但是唯一索引不一定是主键；
* 唯一索引可以为空，但是空值只能有一个，主键不能为空。

对于单列索引，要求该列所有数据都不相同，但允许有 NULL 值；对于多列的联合索引，要求这些列的组合是唯一的。唯一索引其本身既可以作为索引，实际中也可以用以产生数据约束，防止增加或者修改后产生相同数据，从而保证数据的完整性。

### 2.3 前缀索引

前缀索引是给字段的最左前缀建立的索引。对 BLOB/TEXT 类型的字段建立前缀索引，能显著的减少空间使用，但是前缀的长度是一个需要考虑的问题，需要*确保不会有很多记录使用相同的前缀*。

MySQL 的前缀索引可以分为三类：联合索引前缀、like 前缀和字符串前缀。

#### 2.3.1 联合索引前缀

联合索引前缀指的是在建立多列索引的时候，必须按照从左到右的顺序使用全部或部分的索引列，才能充分的使用联合索引，**不能跨越字段使用，也不能使用多个非等值条件(`>`、`<`、`BETWEEN`、`LIKE`)，但是可以使用`IN`范围查询**。
    
比如`(col1, col2, col3)`使用`(col1)`、`(col1, col2)`、`(col1, col2, col3)`有效，但是`col1 = 'Bush' and col2 > 'Chicago' and col3 = 'baseball'`只能使用`col1`和`col2`部分索引，`col1 = 'Bush' and col3 = 'baseball'`就只能用到联合索引中的`col1`部分。
    
使用联合索引对结果进行排序，索引的顺序和 ORDER BY 子句中的顺序一致，并且所有列的升降序一致(ASC/DESC)，也不能使用` IN`查询。如果查询连接了多个表，只有在 ORDER BY 的列引用的是第一个表才可以(需要按序 JOIN)。比如，对于索引`KEY(A, B)`：

* 以下情形将会使用索引进行排序
    * `ORDER BY A` - 对索引首字段进行排序
    * `A=5 ORDER BY B` - 对第一个字段进行点查询，对第二个字段进行排序
    * `ORDER BY A DESC, B DESC` - 对两个字段进行相同的顺序进行排序
    * `A>5 ORDER BY A` - 对首字段进行范围查询，并对首字段进行排序 
* 以下情形将不使用索引进行排序
    * `ORDER BY B` - 对第二个字段进行排序（未使用首字段）
    * `A>5 ORDER BY B` – 对首字段进行范围查询，对第二个字段进行排序
    * `A IN(1,2) ORDER BY B` - 对首字段进行IN查询，对第二个字段进行排序
    * `ORDER BY A ASC, B DESC` - 对两个字段进行不同顺序的排序

#### 2.3.2 like 前缀

like 前缀是指在使用 like 查询时，如果使用的表达式为`first_name like 'rMq%'`，是可以用到 first_name 字段的索引的。但是对于`first_name like '%Chu%'`，就无法使用 first_name 的索引。
    
对于 like 前缀，MySQL 底层实际上是使用了一个补全策略来使用索引的，比如这里`first_name like 'rMq%'`，MySQL 会将其补全为两条数据：`rMqAAAAA`和`rMqzzzzz`，后面补全部分的长度为当前字段的最大长度。在使用索引查询时，MySQL 就使用这两条数据进行索引定位，最后需要的结果集就是这两个定位点的中间部分的数据。

#### 2.3.3 字符串前缀

字符串前缀索引指的是只取字符串前几个字符建立的索引。在进行查询时，如果一个字段值较长，那么为其建立索引的成本将非常高，并且查询效率也比较低，字符串前缀索引就是为了解决这一问题而存在的。字符串前缀索引最需要注意的一个问题是如何*选择前缀的长度*，长度选择合适时，前缀索引的过滤性将和对整个字段建立索引的选择性几乎相等。
    
字符串前缀索引主要应用在两个方面：
    
* 字段前缀部分的选择性比较高；
* 字段整体的选择性不太大（如果字段整体选择性比较大则可以使用哈希索引）。

创建字符串前缀索引的方式如下：
    
```sql
ALTER TABLE tableName ADD KEY (id_address(25));
```

## 三、索引优化

### 3.1 避免读取数据（只读取索引）

在可能的情况下，尽量只读取索引，而不去读取数据。因为：

* 索引通常比数据本身要小；
* 索引读取起来更有次序，而读取数据指针通常是随机的。

比如，对于索引`KEY(CUSTOMER_ID, STATUS)`，如下的查询是非常好的：

```sql
SELECT status FROM orders WHERE customer_id = 123;
```

### 3.2 Min/Max 的优化

索引可以帮助优化`MIN()/MAX()`这类的统计函数，但只包含对索引字段进行统计的情况：

```sql
-- key(id)
SELECT MAX(id) FROM tbl;

-- key()
SELECT MAX(salary) FROM employee GROUP BY dept_id;
```

### 3.4 单索引和复合索引的选择

是使用多个单索引还是使用一个符合索引，需要根据使用的 sql 语句的不同而不同：

* `SELECT * FROM TBL WHERE A = 5 AND B = 6`，这种情况索引`KEY(A, B)`是更好的选择。
* `SELECT * FROM TBL WHERE A = 5 OR B = 6`，这种情下两个索引同时分别被使用，使用`KEY(A)`和`KEY(B)`索引更好，而索引`KEY(A, B)`在这个查询中只能使用部分。

## 四、问题反馈

### 4.1 bigint 类型替代 varchar 做索引

*问：团队中的一人想要使用 bigint 字段类型来代替 25-30 长度的 varchar 类型来存储 CRC64 数据，然后将索引也改成 bigint 的索引，这会节省索引的空间。请问这否是合理的性能优化方法？（需要注意到是自适应前缀哈希在这里是无效的，因为前 10 个字符重复率很高，因此 UNIQUE 索引不适合用在这里）*

答：在很多时候，这是一个很好的优化方法。考虑到哈希碰撞的问题，可以使用形如`SELECT * FROM TBL WHERE hash = crc32('string') AND string='string'`这样的查询。另外还需要注意的是 MySQL 里的字符串比较默认是不区分大小写的，对于哈希字符串也是如此。另外与 25~30 字节长度的字符串来说，使用 8 位的 bigint 在索引存储上的差异并不大。这项技术对超过 100 字节的字符串是最好的。

### 4.2 ORDER BY 的优化问题

*问：`select * from table where A = xxx and B between 100 and 200 order by B`是很常见的日期范围的查询，并且需要对结果进行排序。问题是这样的查询如何设置最佳的索引？*

答：实际上这种情况在`(A, B)`建索引就很好了，但如果需要使用第三个列`(C)`作排序，那么复合索引`(A,B,C)`就会导致排序无法使用索引，因此可以将排序转成小范围数据的联合来处理。

### 4.3 关联表索引

*问：使用关联表时，是否应该在 (foreignkey1, foreignkey2) 和 (foreignkey2, foreignkey1) 上建索引？*

答：是的，这是一个好的实践方法。正常情况下如果需要使用不同查询做双向遍历时，可以这样创建表：

```sql
CREATE TABLE LINK (
    id1 int unsigned not null,
    id2 int unsigned not null,
    PRIMARY KEY(id1, id2),
    KEY K(id2, id1)
) engine=INNODB;
```

这个将使用更快的主键来做一些查询，然后使用索引 K 来做其他的查询。

### 4.4 IN 的使用

*问: “WHERE a IN (2-4)”的效率比“WHERE a IN (2,3,4)”低吗？换句话说，在范围查询中 IN 比 BETWEEN 效率高吗?*

答：`IN(2-4)`并不是想要的那样：`2-4`被看做是一个数学公式，结果是`IN(-2)`。

### 4.5 过多的联合索引

*问：有一个主索引在 int(ID)，还有另外一些复合索引在 idx1(X,A,B,C) idx2(Y,A,B,C) 等等(一共有五个)。是不是把 A,B,C,ID 设置为主索引，把另外的索引设置在一列，像这样 idx(X)、idx2(Y)，这样是不是更好?*

答：相较于设置 5 个复合索引和仅仅设置第一列为索引，那一个才是最好的配置。关于改变主键来包含这么多的列前缀取决准备搜索什么。通过这些列的数据分组有利于很多方面的搜索，但是也会减慢插入操作以及使主键显得很碎，很分散。并且在处理把主键追加到索引的时候 MYSQL 也有很多的限制。尤其是所述这种情况。最后要注意的是这种独特的设置是不是对系统性能有很大的提升。

### 4.6 关联字段是否需要设置索引

*问：Table1 有一主键，Table2 用 Table1 的当前这个主键来关联 Table1，Table2 上两个表存在关联的那个字段有必要建立索引吗？*

答：这个问题涉及到 MySQL 执行 join 的问题。如果首先是用别的索引字段来检索 Table2，然后再到 Table1 通过 Table1 的主键索引来查找行数据，这样就没有必要在 Table2 关联的那个字段上建一个索引。

### 4.7 扩展原有的索引是否比新添加一个索引更好

*有张名叫 PO 的表，拥有一个主键以及两个额外的字段 vendor_id 和 order_id。如果有一个索引基于 vendor_id 和 order_id，但是查询语句仅选择了 vendor_id，这个索引是否会影响到该查询的速度？*

答：如果将该索引从`vendor_id`扩展至`(vendor_id, order_id)`，却只用到`vendor_id`，将会因为增加了 4 个字节的长度（假设`order_id`是`int`类型）而影响查询速度，但可能并不明显。不过除了单独基于`vendor_id`的索引，比起对`(vendor_id, order_id)`建立另一个索引，它似乎能极大的减少系统花费。这个例子里真正需要担心的会因扩展索引而造成影响的是当大幅度增加他的长度，例如增加`long`、`varchar`类型列。类似的情况下它确实会比增加一个索引好。

### 4.8 过多的数据是否会影响系统性能

*问：有个数据库大概有 400G 的索引，这么多索引不可能全部读取到内存了，这样会影响系统性能吗？*

答：通常不必把所有的索引都放入内存，只需要让一部分频繁进出内存。这部分工作区的大小取决于应用程序，范围大小是总内存的 5% 至 100%。合适的工作区大小和不合适的工作区大小会让系统性能相差 10 倍以上。

### 4.9 是否需要为创建的每一个表都创建一个索引

*例如：一张表仅仅用于记录 user_id 和 competition_id，并没有别的东西。若直接使用`SELECT competition_id, COUNT(user_id) AS user_count FROM tbl GROUP BY competition_id;`会不会比没有索引慢呢？*

答：可以定义`(competition_id, user_id)`作为此类表的主键。它还能对无临时表或外部排序时进行分组查询有帮助。

### 4.10 在 group by 上使用索引

如果为`group by`上的字段加索引的话，MySQL 可以避免临时表或 filesort(这两种处理类型性能很低)，这是因为 MySQL 通过扫描索引已经对数据进行了排序。

### 4.11 使用日期范围进行查询的相关方法或技巧

日期比较和其他的数据比较非常相似，所以一些技巧也是相通的，例如在某些条件下可以将`BETWEEN`的写法转换成`IN`这种范围写法以更好的利用索引。

### 4.12 为什么用 B/B+ 树这种结构来实现索引

MySQL 是基于磁盘的数据库，索引是以索引文件的形式存在于磁盘中的，索引的查找过程就会涉及到磁盘 IO 消耗，磁盘 IO 的消耗相比较于内存 IO 的消耗要高好几个数量级，所以索引的组织结构要设计得在查找关键字时要尽量减少磁盘 IO 的次数。而使用 B/B+ 树实现索引也跟磁盘的存储原理有关。

计算机科学中有一个局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用。基于此，磁盘读取完需要的数据后，会按顺序再多读一部分数据到内存中，预读的长度一般为页(page)的整倍数，而磁盘的顺序读取的效率很高(与内存 IO 相当)。因此对于具有局部性的程序来说，预读可以提高 I/O 效率。

B-Tree 借助计算机磁盘预读的机制，并使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个结点只需一次 I/O。假设 B-Tree 的高度为 h，B-Tree 中一次检索最多需要 h-1 次 I/O（根节点常驻内存），渐进复杂度为`O(h)=O(logdN)`。一般实际应用中，出度 d 是非常大的数字，通常超过 100，因此 h 非常小（通常不超过3，也即索引的 B+ 树层次一般不超过三层，所以查找效率很高）。而红黑树这种结构，h 明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的 I/O 渐进复杂度也为 O(h)，效率明显比 B-Tree 差很多。

### 4.13 为什么 MySQL 的索引使用 B+ 树而不是 B 树

1. B+ 树更适合外部存储(一般指磁盘存储)，由于内节点(非叶子节点)不存储数据，所以一个节点可以存储更多的内节点，每个节点能索引的范围更大更精确。也就是说使用 B+ 树单次磁盘 IO 的信息量相比较 B 树更大，IO 效率更高。
2. MySQL 是关系型数据库，经常会按照区间来访问某个索引列，B+ 树的叶子节点间按顺序建立了链指针，加强了区间访问性，所以B+树对索引列上的区间范围查询很友好。而 B 树每个节点的 key 和 data 在一起，无法进行区间查找。

## 五、转摘

1. [MySQL Indexing: Best Practices](https://www.percona.com/webinars/2012-08-15-mysql-indexing-best-practices)
2. [MySQL 索引的原理与应用：索引类型，存储结构与锁](https://segmentfault.com/a/1190000019366328)

