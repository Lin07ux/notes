### 1. 什么是聚簇索引?

在 B+ 树的索引中，叶子节点可能存储了当前的 key 值，也可能存储了当前的 key 值以及整行的数据，后者就是聚簇索引，前者则是非聚簇索引。

在 InnoDB 中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。

当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。

### 2. 非聚簇索引一定会回表查询吗?

不一定，这涉及到查询语句所要求的字段是否全部命中了索引。如果全部命中了索引，那么就不必再进行回表查询。

### 3. 为什么用自增列作为主键？

MySQL InnoDB 引擎中，数据记录本身被存于主索引(一颗 B+Tree)的叶子节点上。在每个叶子节点内，数据记录按照主键的次序顺序的进行存储。而每个叶子节点的大小是固定的，一般为一个内存页或一个磁盘页的大小。

因此每当有一条新的记录插入时，MySQL 会根据其主键将其插入适当的节点和位置，如果页面达到装载因子(InnoDB 默认为 15/16)，则开辟一个新的页（节点）。

如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，是顺序的追加数据，此时磁盘的读写效率很高。

如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。此时 MySQL 不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销。

同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过 OPTIMIZE TABLE 来重建表并优化填充页面。否则会拖慢数据的读写效率。

### 4. 为什么使用数据索引能提高效率？

1. 数据索引的存储是有序的
2. 在有序的情况下，通过索引查询一个数据是无需遍历索引记录的
3. 极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)

### 5. B 树和 B+ 树的区别？

1. B 树：每个节点都存储 key 和 data，所有节点组成这棵树，并且叶子节点指针为 null，叶子结点不包含任何关键字信息。如下图所示：

    ![B 树](http://cnd.qiniu.lin07ux.cn/markdown/1568035291937.png)

2. B+ 树：所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。所有的非终端结点可以看成是索引部分，其仅含有其子树根结点中最大（或最小）关键字，不包含数据信息。

    ![B+ 树](http://cnd.qiniu.lin07ux.cn/markdown/1568035316069.png)

这种存储方式的差别使得 B+ 树有如下优势：

1. B+的磁盘读写代价更低。因为每个 B+ 树的内部结点仅储存关键字而不存储数据，所以可以存储的关键字数量会很大，一次性读入内存中的需要查找的关键字也就越多，相对来说 IO 次数也就降低了。
2. B+ 树的查询效率更加稳定。由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

