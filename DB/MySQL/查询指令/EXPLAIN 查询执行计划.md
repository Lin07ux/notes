## 一、简介

MySQL 的`EXPLAIN`命令用于 SQL 语句的查询执行计划(QEP)。这条命令的输出结果能够展示 MySQL 优化器是如何执行 SQL 语句的。这条命令并没有提供任何调整建议，但它能够提供重要的信息帮助做出调优决策。它仅对`SELECT`语句或者特定表有效，可以帮助**选择更好的索引**和**写出更优化的查询语句**。

> 如果`EXPLAIN`作用在表上，那么其等同于`DESC`表命令。

> 在 5.6.10 版本里面，是可以直接对 DML(增删改查等) 语句进行`EXPLAIN`分析操作的。

`UPDATE`和`DELETE`命令也需要进行性能改进，需要把它们改写成 SELECT 语句(以便对它们执行`EXPLAIN`命令)。如：

```sql
-- UPDATE 语句
UPDATE table1 SET col1 = X, col2 = Y WHERE id = 9 AND dt >= '2010-01-01';

-- 改写成 SELECT 语句，并进行 EXPLAIN
EXPLAIN SELECT col1, col2 FROM table1 WHERE id = 9 AND dt >= '2010-01-01';
```

## 二、使用

`EXPLAIN`一般都是用于查看`SELECT`语句的，使用方法很简单，直接在`SELECT`语句的最前面添加`EXPLAIN`关键字即可，和一般的查询语句写法基本相同：

```sql
EXPLAIN SELECT * FROM user WHERE id = 1;
```

> 默认情况下，EXPLAIN 的输出是一个横向的表格，如果想要竖向显示，可以在语句最后添加`\G`来更改。

<img src="http://cnd.qiniu.lin07ux.cn/markdown/1473954724661.png" width="817"/>

结果中各个参数解释如下：

### 2.1 id

这个是 SELECT 查询序列号，即为 SQL 语句执行的顺序。这个一般不重要。

### 2.2 select_type

SELECT 操作的类型，主要有以下几个值：

* `simple` 它表示简单的 SELECT，没有 UNION 和子查询。
* `primary` 最外面的 SELECT。在有子查询的语句中，最外面的 SELECT 查询就是 primary。这个类型通常可以在 DERIVED 和 UNION 类型混合使用时见到。
* `derived` 当一个表不是一个物理表时，那么就被叫做 DERIVED。
* `dependent subquery` 这个值是为使用子查询而定义的。
* `union` UNION 语句的第二个或者说是后面那一个。
* `dependent union` UNION 中的第二个或后面的 SELECT 语句，取决于外面的查询。
* `union result` UNION 的结果。

### 2.3 table

输出的行所用的表。也就是当前 SELECT 语句操作的表。这个值可能是表名、表的别名或者一个为查询产生临时表的标识符，如派生表、子查询或集合。

### 2.4 type

显示连接使用了何种类型。从最好到最差的连接类型为`system`、`const`、`eq_reg`、`ref`、`range`、`index`和`all`。

> 可以参见：[](../知识点/EXPLAIN%20type%20各值的含义.md)

* `system`：系统表，少量数据，往往不需要进行磁盘 IO；
* `const`：表最多有一个匹配行，`const`用于比较 primary key 或者 unique 索引。因为只匹配一行数据，所以很快。记住一定是用到 primary key 或者 unique。
* `eq_reg`：对于每个来自于前面的表的行组合，从该表中读取一行。这可能是最好的联接类型，除了 const 类型。它用在一个索引的所有部分被联接使用并且索引是 UNIQUE 或 PRIMARY KEY。eq_ref 可以用于使用`=`比较带索引的列。
* `ref`：对于每个来自于前面的表的行组合，所有有匹配索引值的行将从这张表中读取。如果联接只使用键的最左边的前缀，或如果键不是 UNIQUE 或 PRIMARY KEY（换句话说，如果联接不能基于关键字选择单个行的话），则使用 ref。如果使用的键仅仅匹配少量行，该联接类型是不错的。
* `range`：给定范围内的检索，使用一个索引来检查行。
* `index`：该联接类型与 ALL 相同，除了只有索引树被扫描。这通常比 ALL 快，因为索引文件通常比数据文件小。（也就是说虽然 ALL 和 Index 都是读全表，但 Index 是从索引中读取的，而 ALL 是从硬盘中读的）
* `ALL`：对于每个来自于先前的表的行组合，进行完整的表扫描。如果表是第一个没标记 const 的表，这通常不好，并且通常在它情况下很差。通常可以增加更多的索引而不要使用 ALL，使得行能基于前面的表中的常数值或列值被检索出。

### 2.5 possible_keys

显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从 WHERE 语句中选择一个合适的语句。

### 2.6 key

实际使用的索引。如果为 null，则没有使用索引。很少的情况下，mysql 会选择优化不足的索引。这种情况下，可以在 SELECT 语句中使用`use index(indexname)`来强制使用一个索引或者用`ignore index indexname`来强制 mysql 忽略索引。

### 2.7 key_len

使用的索引的长度。在不损失精确性的情况下，长度越短越好。

### 2.8 ref

显示索引的哪一列被使用了，如果可能的话，是一个常数。

### 2.9 rows

mysql 认为必须检查的用来返回请求数据的行数，数值越大越不好，说明没有用好索引。

### 2.10 Extra

关于 mysql 如何解析查询的额外信息。`using temporary`和`using filesort`是最差的情况，意思 mysql 根本不能使用索引，结果是检索会很慢。

Extra 列各个值的意义描述：

* `distinct`：一旦 mysql 找到了与行相联合匹配的行，就不再搜索了
* `not exists`：mysql 优化了 left join，一旦它找到了匹配 left join 标准的行，就不再搜索了
* `range checked for each record(index map:#)`：没有找到理想的索引，因此对于从前面表中来的每一个行组合，mysql 检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一
* `using filesort`：看到这个的时候，查询就需要优化了。mysql 需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行
* `using index`：列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候
* `using temporary`：看到这个的时候，查询需要优化了。这里，mysql 需要创建一个临时表来存储结果，这通常发生在对不同的列集进行 order by 上，而不是 group by 上
* `where used`：使用了 where 从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型 all 或 index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）
* `system`：表只有一行：system 表。这是 const 连接类型的特殊情况
* `const`：表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为 mysql 先读这个值然后把它当做常数来对待
* `eq_ref`：在连接中，mysql 在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用
* `ref`：这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好
* `range`：这个连接类型使用索引返回一个范围中的行，比如使用 > 或 < 查找东西时发生的情况
* `index`：这个连接类型对前面的表中的每一个记录联合进行完全扫描（比 all 更好，因为索引一般小于表数据）
* `all`：这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免



