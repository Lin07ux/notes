> 转摘：[手把手教你分析Mysql死锁问题](https://www.cnblogs.com/jay-huaxiao/p/12685287.html)

## 一、锁类别

MySQL 中的锁根据不同的方式可以分为如下的几种类别：

![](http://cnd.qiniu.lin07ux.cn/markdown/1587716080800.png)

### 1.1 共享锁与排他锁

MySQL InnoDB 引擎实现了标准的行级锁，包括两种：

* 共享锁(简称`s 锁`)：允许持锁事务读取一行。
* 排它锁(简称`x 锁`)：允许持锁事务更新或删除一行。

如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：

* T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁
* T2 请求 x 锁不能被立即允许。

如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为 x 锁与任何的锁都不兼容。

兼容性如下表所示：

           | S         | X
-----------|-----------|-----------
 S         | 兼容       | 不兼容
 X         | 不兼容     | 不兼容

### 1.2 意向锁

当事务要获取表中的某几行的锁时，会去获取意向锁：

* 意向共享锁(IS 锁)：事务想要获得一张表中某几行的共享锁。
* 意向排他锁(IX 锁)：事务想要获得一张表中某几行的排他锁。

意向锁可以实现更细粒度的加锁。比如，事务 1 在表 1 上加了 S 锁后，事务 2 想要更改某行记录，需要添加 IX 锁，由于不兼容，所以需要等待S锁释放；如果事务 1 在表 1 上加了 IS 锁，事务 2 添加的 IX 锁与 IS 锁兼容，就可以操作。

InnoDB 存储引擎中锁的兼容性如下表：

           | S         | X         | IS        | IX
-----------|-----------|-----------|-----------|-----------
 S         | 兼容       | 不兼容     | 兼容      | 不兼容
 X         | 不兼容     | 不兼容     | 不兼容     | 不兼容
 IS        | 兼容       | 不兼容     | 兼容      | 兼容
 IX        | 不兼容     | 不兼容     | 兼容       | 兼容

### 1.3 记录锁(Record Locks)

记录锁是最简单的行锁，仅仅锁住一行。如：`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`。

**记录锁永远都是加在索引上**的，即使一个表没有索引，InnoDB 也会隐式的创建一个索引，并使用这个索引实施记录锁。

记录锁会阻塞其他事务对其插入、更新、删除。

### 1.4 间隙锁(Gap Locks)

间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。

使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。

间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以`gap x lock`和`gap s lock`有相同的作用。

### 1.5 Next-Key 锁

Next-Key 锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。

### 1.6 插入意向锁(Insert Intention)

插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。

假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方，因为插入行不冲突。


间隙锁、插入意向锁、记录锁和 Next-Key 锁之间的兼容性如下表所示（横向是已持有锁，纵向是正在请求的锁）：

                  | GAP       | Insert Intention | Record    | Next-Key
------------------|-----------|------------------|-----------|-----------
 GAP              | 兼容       | 兼容              | 兼容      | 兼容
 Insert Intention | 冲突       | 兼容              | 兼容      | 冲突
 Record           | 兼容       | 兼容              | 冲突      | 冲突
 Next-Key         | 兼容       | 兼容              | 冲突      | 冲突


## 二、锁示例

### 2.1 select for update

`for update`仅适用于 InnoDB 引擎，且必须在事务块中(`BEGIN/COMMIT`之间)才能生效。

在进行事务操作时，通过**`for update`**语句，MySQL 会**对查询结果集中的每一行数都添加排它锁**，其他线程对该记录的更新与删除操作都会阻塞。这里的排它锁包含行锁、表锁。

InnoDB 引擎的锁实现意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁！

假设有个表 products，包含 id、type 和 name 三个列，其中 id 是主键，有如下几种加锁情况：

* 明确指定主键，并且有此行记录，加行锁：

    ```sql
    SELECT * FROM products WHERE id = 3 FOR UPDATE;
    SELECT * FROM products WHERE id = 3 AND type = 1 FOR UPDATE;
    ```

* 明确指定主键，但无该记录，不加锁

    ```sql
    SELECT * FROM products WHERE id = -1 FOR UPDATE;
    ```

* 不指定主键，加表锁

    ```sql
    SELECT * FROM products WHERE name = 'Mouse' FOR UPDATE;
    ```

* 主键不明确，加表锁

    ```sql
    SELECT * FROM products WHERE id <> 1 FOR UPDATE;
    SELECT * FROM products WHERE id like '3' FOR UPDATE;
    ```


