> 转摘：[从头带你捋一遍 MySQL 索引结构，索引没你想的那么难！](https://mp.weixin.qq.com/s/0JkWDDx6fTaII0Jgo36Nqw)

## 一、前导

MySQL 中进行数据查询的时候，如果没有指定排序列，则默认会按照主键进行排序，从而使得获得的结果都是有序的。在 MySQL InnoDB 中，每个表都会有一个主键，如果没有显式的为表定义主键，那么 MySQL 会自动为其创建一个隐藏的主键。之所以会自动按照主键进行结果排序，是因为 MySQL 在存储数据的时候，就已经按照一定的规则和层级进行的数据排序，取出时只需要顺序读取即可。

### 1.1 表结构

假设有如下的表结构：

```sql
CREATE TABLE user (
    id INT PRIMARY KEY,
    age INT,
    height INT,
    weight INT,
    name VARCHAR(32)
) ENGINE = InnoDB;
```

### 1.2 插入数据

向上面的表中乱序的插入一些数据：

```sql
INSERT INTO user(id,age,height,weight,name)VALUES(2,1,2,7,'小吉');
INSERT INTO user(id,age,height,weight,name)VALUES(5,2,1,8,'小尼');
INSERT INTO user(id,age,height,weight,name)VALUES(1,4,3,1,'小泰');
INSERT INTO user(id,age,height,weight,name)VALUES(4,1,5,2,'小美');
INSERT INTO user(id,age,height,weight,name)VALUES(3,5,6,7,'小蔡');
```

### 1.3 数据顺序

此时，直接查询该表的数据：

```sql
select * from user;
```

输出结果类似如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1576817872957.png)

可以看到虽然插入时是 ID 乱序的，但是查询出来的结果则是按照 ID 字段顺序排列的。

在插入数据的时候，MySQL 会自动对数据按照主键进行排序。并在查询的时候，也默认按照主键排序。而之所以这样操作，是为了更好的提高数据读取效率。

## 二、单页

> 可参考：[磁盘 IO 与数据组织及数据库索引](../../../编程思想/磁盘 IO 与数据组织及数据库索引.md)

### 2.1 程序局部性

MySQL 作为一个基于操作系统的软件，其运行所需的基础环境和底层操作都是通过操作系统代理来完成的，所以 MySQL 的性能与操作系统的运行规则和效率是息息相关的。

在操作系统的概念中，当从磁盘中读取数据时，很多时候操作系统并非仅仅获取指定读取大小的数据，而是一次取出更多的数据。一般情况下，操作系统取出的数据会是 4KB 的整数倍，这是由于操作系统的一个页表的大小是 4KB。

这里之所以在读取 1KB 的时候也会返回 4KB 的数据，涉及到*程序局部性*的概念。这个概念大致是说：*一个程序在访问了一条数据之后，有极大的可能性再次访问这条数据及其相邻的数据*。而直接一次加载 4KB 的数据到内存，可以使下次要访问这一页的数据时不需要再去从硬盘中读取，而是直接在内存中操作，减少 IO 次数。磁盘随机 IO 效率一般很低，是影响程序性能的主要因素，而顺序 IO 的效率则很高，可以媲美内存操作。

操作系统利用程序局部性的原理可以大幅度的程序读取数据的速度，提高程序的性能。

### 2.2 页对数据读取性能的提升

假设对前面的那个数据表，在数据已经是有序的情况下，查找`id = 5`的数据，分别考虑不利用和利用页时数据的获取情况。

首先，考虑使用最原始的方式，每次只读取所需要的数据：

> 为了找到`id = 5`的数据，需要对每条数据分别读取和比较，直到找到符合条件的数据。
> 
> 1. 读取第一条数据，发现`id = 1`，不符合条件，继续读取数据；
> 2. 读取第二条数据，发现`id = 2`，不符合条件，继续读取数据；
> 3. 读取第二条数据，发现`id = 3`，不符合条件，继续读取数据；
> 4. 读取第二条数据，发现`id = 4`，不符合条件，继续读取数据；
> 5. 读取第二条数据，发现`id = 5`，符合条件，找到所需数据。
> 
> 总共需要五次磁盘 IO 才能找到符合要求的数据。如果数据更多，要找的数据更靠后，那么就需要更多次的磁盘 IO 了。

然后，在引入页的概念后，查找过程如下：

> 有页的概念时，MySQL 会一次读取一个页的数据到内存中，然后在内存中对这些数据进行比对处理。假设一页能存储 4 条数据：
> 
> 1. 读取第一页的数据到内存，分别比较这 4 条数据是否符合`id = 5`的条件，发现不符合，继续读取下一页；
> 2. 读取第二页的数据到内存，可以从这 4 条数据中找到`id = 5`的数据，完成查找。
> 
> 总共需要两次磁盘 IO 即找到的所需数据。如果数据更多，那么所需的磁盘 IO 也会比不使用页的时候少非常多次的磁盘 IO。

### 2.3 MySQL InnoDB 页

在 MySQL 的 InnoDb 引擎中，页的大小是 16KB，是操作系统的 4 倍。而 int 类型的数据是 4 个字节，其它类型的数据的字节数通常也在 4000 字节以内，所以一页是可以存放很多很多条数据的。

MySQL 的数据是以页为基本单位组合而成的。每一页的数据中，有指向下一页的指针和指向上一页的指针，组成一个链表的结构。

![](http://cnd.qiniu.lin07ux.cn/markdown/1576819042845.png)

MySQL 在插入和更新数据的时候，会将数据在页中自动更多排列好顺序，这样做是也为了优化查询的效率。因为 MySQL 的数据由页组成了链表，而链表的特点是增删快、查询慢，所以需要先将数据排好序进行存储，提升之后的查询效率。

由于 MySQL 中页的数据已经排序过，所以在对页内的数据进行比较时，能够采用二分法快速的确认数据位置，提升数据查找效率。

### 2.4 页目录

虽然一次顺序读取一整页的数据可以减少磁盘 IO，提高性能。但是当页内的数据增多的时候，由于页模式内部是通过链表方式串接数据的，要找到一条靠后的数据，需要遍历很多次才能找到。这样，即便在内存中进行操作，依旧需要进行适当的优化。

为了提升业内数据的查找性能，可以考虑类似书籍的目录一样，为这些页内数据建立一个“目录”，也就是页目录。引入页目录之后，页结构就变成了这样：

![](http://cnd.qiniu.lin07ux.cn/markdown/1577066575303.png)

这张图可以解释称：第一节从第一页开始，第二节从第三页开始，而实际上，每个目录项会存放自己这个目录项当中最小的 ID。也就是说，目录项 1 中会存放 1，而目录项 2 会存放 3。

假设要查找`id=3`的数据，在没有页目录的情况下，需要查找`id=1`、`id=2`、`id=3`，三次才能找到该数据，而如果有页目录之后，只需要先查看一下`id=3`存在于哪个目录项下，然后直接通过目录项进行数据的查找即可。如果在该目录项下没有找到这条数据，那么就可以直接确定这条数据不存在。

这样大大提升了数据库的查找效率，但是这种页目录的实现，首先就需要基于数据是在已经进行过排序的的场景下，才可以发挥其作用。所以，MySQL 数据库在插入时会进行排序。

## 三、多页

当数据量增多时，一个页无法存入全部的数据，这时 MySQL 就会开辟新的页来进行存储，这样就构成了多页结构：

![](http://cnd.qiniu.lin07ux.cn/markdown/1577067330751.png)

可以看到，在数据不断变多的情况下，MySQL 会再去开辟新的页来存放数据，而且每个页都有指向下一页的指针和指向上一页的指针，从而将全部的页串联起来。

需要注意的是：在开辟新页的时候，插入的数据不一定是放在新开辟的页上，而是要进行所有页的数据比较，来决定这条插入的数据放在哪一页上，而完成数据插入之后，最终的多页结构就会像上图中画的那样。

### 3.1 多页查询性能

多页其本质也是一个链表结构，只要是链表结构，查询效率一定不会高。假设数据又非常多条，数据库就会开辟非常多的新页，而这些新页就会像链表一样连接在一起，当要在这么多页中查询某条数据时，它还是会从头节点遍历到存在要查找的那条数据所存在的页上。

为了优化多页查询的性能，可以利用类似页目录的方式对多页数据进行处理。对于多页结构使用一个目录项来指向某一页，而这个目录项存放的就是这一页中存放的最小数据的索引值。和页目录不同的地方在于，这种目录管理的级别是页，而页目录管理的级别是行。结构类似如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1577068762431.png)

需要注意的是：**目录页的本质也是页，普通页中存的数据是项目数据，而目录页中存的数据是普通页的地址**。

### 3.2 B+ 树

上面那种多页目录结构实际上就是 MySQL InnoDB 引擎的 B+ 树索引结构。将存在目录页的多页模式图宏观化，可以形成下面的这张图：

![](http://cnd.qiniu.lin07ux.cn/markdown/1577069356479.png)

这就是由简到繁形成的一颗 B+ 树。和常规 B+ 树有些许不同，这是一棵 MySQL 意义上的 B+ 树，MySQL 的一种索引结构，其中的每个节点就可以理解为是一个页，而叶子节点也就是数据页，除了叶子节点以外的节点就是目录页。

这一点在图中也可以看出来，非叶子节点只存放了索引，而只有叶子节点中存放了真实的数据，这也是符合 B+ 树的特点的。

B+ 树的优势在于：

* 由于叶子节点上存放了所有的数据，并且有指针相连，每个叶子节点在逻辑上是相连的，所以对于范围查找比较友好。
* 所有数据都在叶子节点上，所以 B+ 树的查询效率稳定，一般都是查询 3 次。
* 有利于数据库的扫描。
* 有利于磁盘的 IO，因为他的层高基本不会因为数据扩大而增高（三层树结构大概可以存放两千万数据量）。 
### 3.3 聚簇索引和非聚簇索引

所谓聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，刚才看到的 B+ 树索引就是一种聚簇索引。

非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引回表找到相应的数据。

InnoDB 有且只有一个聚簇索引，而 MyISAM 中都是非聚簇索引。



