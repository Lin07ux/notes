> 转摘：[redo、undo、buffer pool、binlog，谁先谁后，有点儿乱？](https://mp.weixin.qq.com/s/wcJ2KisSaMnfP4nH5NYaQA)

这篇文章来讨论下一条 DML 语句从客户端发出后，服务器做了哪些处理，主要想讨论 redo、undo、binlog 这些日志是在什么时候生成的，什么时候写入到磁盘的。

> 虽然 SELECT 语句的处理也很复杂，但它并不会修改数据库中的书，也就不会记录注入 redo、undo、binlog 这些日志。

### 一、基础

### 1.1 预备知识

本次讨论的是基于 InnoDB 存储引擎的表，数据会被保存在磁盘上的表空间（文件系统中的一个或多个文件）中。

InnoDB 会将磁盘中的数据看成是若干个**页**的集合，页的大小默认是 16KB。其中某些页面用于存储关于系统的一些属性，某些页面用于存储 undo 日志，某些页面用于存储 B+树的节点（也就是包含记录的页面），反正总共有十来种不同类型的页面。

不过不论是什么类型的页面，每当从页面中读取或者写入数据时，都必须先将其从硬盘上加载到内存中的 buffer pool 中（也就是说内存中的页面其实就是硬盘中页面的一个副本），然后才能对内存中页面进行读取或写入。如果要修改内存中的页面，为了减少磁盘 IO，修改后的页面并不会立即同步到磁盘，而是作为**脏页**继续呆在内存中，等待后续合适时机将其刷新到磁盘（一般是有后台线程异步刷新）。

### 1.2 准备工作

先建一张表：

```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number),
    KEY idx_name (name)
) Engine=InnoDB CHARSET=utf8;
```

然后向这个表里插入几条数据：

```sql
INSERT INTO hero VALUES
    (1, 'l刘备', '蜀'),
    (3, 'z诸葛亮', '蜀'),
    (8, 'c曹操', '魏'),
    (15, 'x荀彧', '魏'),
    (20, 's孙权', '吴');
```

现在，`hero`这个表中就有了两个索引（一个二级索引，一个聚簇索引），示意图如下所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1642552483977-63451a93eea8.jpg)

## 二、更新执行

### 2.1 执行计划的生成

如果要执行下边这条 UPDATE 语句：

```sql
UPDATE hero SET country = '汉' WHERE name >= 'x荀彧';
```

MySQL 优化器首先会分析一下使用不同索引执行查询的成本，然后选取成本最低的那个索引去执行查询。

对于上面的 SQL 语句来说，可选的执行方案有 2 中：

* 方案一：使用全表扫描执行查询，即扫描全部聚簇索引记录，可以认为此时扫描区间就是`(-∞, +∞)`。
* 方案二：使用二级索引`idx_name`执行查询，此时扫描区间就是`['x荀彧', +∞)`。

优化器会计算上述两种方案的成本，选取成本最低的方案作为最终的执行计划。可以通过`EXPLAIN`语句来看一下这个语句的执行计划（当然，也可以通过 MySQL 提供的 optimizer trace 功能查看具体执行计划分析流程）：

```
mysql> explain UPDATE hero SET country = '汉' WHERE name >= 'x荀彧';
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------------+
| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref   | rows | filtered | Extra       |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------------+
|  1 | UPDATE      | hero  | NULL       | range | idx_name      | idx_name | 303     | const |    2 |   100.00 | Using where |
+----+-------------+-------+------------+-------+---------------+----------+---------+-------+------+----------+-------------+
1 row in set, 1 warning (0.01 sec)
```

可以看到，MySQL 优化器决定采用方案二，即扫描二级索引`idx_name`在`['x荀彧', +∞)`这个扫描区间中的记录。

### 2.2 开始执行

MySQL 分为 Server 层和存储引擎层，在执行上述的 UPDATE 语句时，Server 层和 InnoDB 之间会不断进行沟通，针对优化器的执行计划中得到的若干个扫描区间（本例中只有 1 个扫描区间`['x荀彧', +∞)`）的每一个区间，都会执行下边的步骤：

#### 2.2.1 处理扫描区间的第一条记录

1. 首先 Server 层根据执行计划，向 InnoDB 层索要二级索引`idx_name`的扫描区间`['x荀彧', +∞)`的第一条记录。
2. InnoDB 存储引擎通过二级索引`idx_nane`对应的 B+ 树，从树根页面一层一层向下查找（在页面中查找是通过页目录的槽进行二分查找，这个过程很快），快速在叶子节点中定位到扫描区间`['x荀彧', +∞)`的第一条二级索引记录。
3. InnoDB 根据这条二级索引记录中的主键值执行回表操作（即通过聚簇索引的 B+ 树根节点一层层向下查找，直到在叶子节点中找到对应记录），将获取到的的聚簇索引记录返回给 Server 层。
4. Server 层得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样，如果一样的话就不更新了，否则会把更新前的记录和更新后的记录都当做参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作。
5. InnoDB 收到更新请求后，先更新记录的聚簇索引记录，再更新记录的二级索引记录，最后将更新结果返回给 Server 层。

#### 2.2.2 处理扫描区间的第二条记录

1. Server 层继续向 InnoDB 索要下一条记录。
2. 此时由于 InnoDB 存储引擎已经通过 B+ 树定位到二级索引扫描区间`['x荀彧', +∞)`的第一条二级索引记录了，而记录又是被串联成单向链表，所以 InnoDB 会直接通过记录头信息的`next_record`属性即可获取到下一条二级索引记录。
3. InnoDB 通过二级索引的主键值进行回表操作，获取到完整的聚簇索引记录再返回给 Server 层。
4. Server 层得到聚簇索引记录后，会看一下更新前的记录和更新后的记录是否一样，如果一样的话就不更新了，否则会把更新前的记录和更新后的记录都当做参数传给 InnoDB 层，让 InnoDB 真正的执行更新记录的操作。
5. InnoDB 收到更新请求后，先更新记录的聚簇索引记录，再更新记录的二级索引记录，最后将更新结果返回给 Server 层。

#### 2.2.3 处理扫描区间的剩余记录

该扫描区间中的其他记录的处理就和第 2 条记录的处理过程是一样的了。

## 三、详细更新过程

在代码层面，MySQL 使用`mysql_update`函数处理上述的更新语句，而最主要的处理流程写在了一个循环里：

![主要流程](http://cnd.qiniu.lin07ux.cn/markdown/1642552533503-0ca7f02f48e4.jpg)

上图所示的`while`循环就是依次处理各条记录的过程。其中`info.read_record`是用于获取扫描区间的一条记录，读取到该记录后，展开详细的更新操作。处理完了之后再会到这个`while`循环的起点，通过`info.read_record`继续获取下一条记录，继续进行详细的更新操作。

也就是说，其实处理每一条记录的过程都是类似的，只不过定位扫描区间的第一条记录会有点麻烦（需要从 B+ 树根页面一层层向下查找）。

下面聚焦于一条记录的更新过程，看看这个过程都发生了什么。

### 3.1 将记录所在页面加载到 buffer pool

想更新一条记录，首先就得在 B+ 树中定位这条记录——即进行一次**加锁读**（上图中的`info.read_record`函数用于调用 InnoDB 读取记录的接口，加锁过程就不扩展了）。

如果该记录所在的页面已经在内存的 buffer pool 中，就可以直接读取，否则还需要将该记录所在的页面读取到内存中的 buffer pool。

> 不论想读写任何页面，都需要先将改页面从硬盘加载到 buffer pool 中。在定位扫描区间的第一条记录时，首先要读取 B+ 树根页面中的记录，所以首先需要把 B+ 树根页面加载到 buffer pool 中，然后再读取下一层的页面，直到叶子节点。每当要读取的页面不在 buffer pool 中，都得先将其加载到 buffer pool 中后才能使用。

InnoDB 使用`row_search_mvcc`处理读取一条记录的过程（不轮是加锁读还是一致性读都调用这个函数），在该函数内`btr_pcur_open_with_no_init`用于从 B+ 树定位记录。在定位记录时就需要将该记录所在页面加载到 buffer pool 中，完成这个过程的函数是`buf_page_get_gen`：

![buf_page_get_gen](http://cnd.qiniu.lin07ux.cn/markdown/1642552592655-6285b469e66c.jpg)

### 3.2 检测更新前后是否一样

在`mysql_update`函数中，当通过`info.read_record`读取到一条记录只会，就要分析一下这条记录更新前后是否发生变化：

![compare_records](http://cnd.qiniu.lin07ux.cn/markdown/1642552629069-4a4067fafba1.jpg)

上图中的`compare_records`用于比较记录更新前后是否一样。如果更新前后的记录是一样的，就跳过该记录，否则继续向下处理。

### 3.3 调用存储引擎接口进行更新

需要更新的话，就会通过`ha_update_row`函数让存储引起去更新记录：

![ha_update_row](http://cnd.qiniu.lin07ux.cn/markdown/1642552658697-1b8c7fc502b4.jpg)

其中`table->record[1]`代表旧记录，`table->record[0]`代表新记录。

InnoDB 会首先更新聚簇索引记录，然后再更新二级索引记录。

### 3.4 更新聚簇索引记录

更新聚簇索引的函数为`row_upd_clust_step`。

首先会尝试在同一个页面中更新记录，这被称作**乐观更新**，通过`btr_cur_optimistic_update`函数来完成。

如果不能在本页面中完成更新（比如说更新后的记录非常大，本页面容纳不下），就会尝试**悲观更新**，通过`btr_cur_pessimistic_update`函数来完成。

本例中使用乐观更新即可完成。

#### 3.4.1 记录 undo 日志

在更新记录前，首先要记录相应的 undo log，这是调用`trx_undo_report_row_operation`来记录的。

MySQL 的 undo log 是要写到一种专门存储 undo log 的页面中的。如果一个事务写入的 undo log 非常多，就需要占用多个 Undo 页面，这些页面会被串联成一个链表，称作 **Undo 页面链表**。

`trx_undo_page_report_modify`函数用于真正的向 Undo 页面中写入 undo log。另外，由于这里是在修改页面，一个事务执行过程中凡是修改页面的地方，都需要记录相应的 redo 日志，所以在这个函数的末尾，有一个记录修改这个 Undo 页面的 redo log 的函数`trx_undof_page_add_undo_rec_log`的调用。

可以看出，**是先将 undo log 写入 Undo 页面，然后在记录修改该页面对应的 redo log**。不过这里修改后的页面并没有加入 buffer pool 的 flush 链表，记录的 redo log 也没有加入到 redo log buffer。

当这个函数执行完成后：

* 先将这个过程产生的 redo 日志写入到 redo log buffer；
* 再将这个过程修改的页面加入到 buffer pool 的 flush 链表。

这个过程是在`mtr_commit`中完成的：

![](http://cnd.qiniu.lin07ux.cn/markdown/1642556766040-ec48f5bc21d3.jpg)

> MySQL 设计者把对底层页面的一次原子修改称作一个 Mini Trasaction，即 MTR。一个 MTR 中包含若干条 redo log，在崩溃恢复时，要么全部回复至该 MTR 对应的 redo log，要么全部不恢复。

也就是说，实际上虽然先修改 Undo 页面，后写 redo log，但是此时 InnoDB 并不认为 Undo 页面是脏页，就不会将其刷新到硬盘，redo 日志也没有写入到 redo log buffer，这些 redo log 也不会被刷新到 redo log 文件中。只有当 MTR 提交时，才先将 redo 日志复制到 redo log buffer，再将修改的 Undo 页面加入到 flush 链表。

所以可以粗略认为**修改 Undo 页面的 redo log 是先写的，而修改页面的过程是后发生的**。

> 有后台线程不断的将 redo log buffer 中的 redo log 刷入到磁盘的 redo 日志文件中，也有后台线程不断的将 buffer pool 里的脏页（只有加入到 flush 链表后的页面才能算做是脏页）刷新到磁盘中的表空间中。
> 
> MySQL 设计者规定，在刷新一个脏页到硬盘时，该脏页对应的 redo log 应该先被刷新到 redo 日志文件。
> 
> 而 redo 日志是顺序刷新的，也就是说，在刷新 redo log buffer 的某条 redo 日志时，在它之前的 redo 日志也都应该被刷新到 redo 日志文件中。

#### 3.4.2 修改页面内容

上一步骤是先把 undo log 写入到 Undo 页面中以及记录对应的 redo log，接下来该真正修改聚簇索引记录了。

首先使用`row_upd_rec_sys_fields`函数更新系统字段`trx_id`以及`roll_pointer`，然后使用`row_upd_rec_in_place`函数真正的修改记录内容。

> 在本例中的更新语句，更新前后的各个字段占用的存储空间大小是不变的，所以可以直接就低（in place）更新。

然后再使用`btr_cur_update_in_place_log`函数记录更新的 redo 日志。

像向 Undo 页面写入 undo log 一样，InnoDB 规定更新一个页面中的一条记录也属于一个 MTR。在该 MTR 提交时，也是先将 MTR 中的 redo 日志复制到 redo log buffer，然后再将修改的页面加入到 flush 链表。

所以也可以认为在这个过程中，**先记录修改页面的 redo log，然后再真正的修改页面**。

至此，一条聚簇索引记录就更新完毕了。

### 3.5 更新二级索引记录

更新二级索引记录的函数如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1642557599788-d18ecc32705b.jpg)

更新二级索引记录时并不会再记录 undo 日志，但由于是在修改页面内容，也会先记录对应的 redo log。

由于本例子中并不会更新二级索引记录，所以这里就跳过本步骤了。

## 四、更新后续

### 4.1 记录 binlog

在一条更新语句执行完成后（也就是将所有待更新记录都更新完了），就需要生成该语句对应的 binlog 日志了，使用的是`binlog_query`函数：

![](http://cnd.qiniu.lin07ux.cn/markdown/1642557754366-f26532bceac3.jpg)

不过需要注意的是，此时记录的 binlog 日志并不会被写道 binlog 日志文件中，而是被暂时保存到内存的某个地方。等之后事务提交的时候才会真正将该事务执行过程中产生的所有 binlog 统一写入到 binlog 日志文件。

### 4.2 提交事务

在事务提交时，binlog 才会被真正刷新到 binlog 日志文件中，redo 日志也会被刷新到 redo 日志文件中。这个过程就涉及到两阶段提交的知识了。

## 五、总结

本文描述了执行一条 UPDATE 语句的过程中都发生了什么事情。当优化器分析出成本最小的执行计划后，就开始对执行计划中的各个扫描区间中的记录进行更新。

具体更新一条记录的流程如下：

1. 先在 B+ 树中定位到该记录（这个过程也被称作加锁读），如果该记录所在的页面不在 buffer pool 里，先将其加载到 buffer pool 里再读取。

2. 读取到记录后判断记录更新前后是否一样，一样的话就跳过该记录，否则进行后续步骤。

3. 首先更新聚簇索引记录。更新聚簇索引记录时：
    
    1. 先向 Undo 页面写 undo log，而且因为是更该页面，所以更新前要记录对应的 redo log。
    2. 真正的更新记录数据，不过在真正更新记录前也要记录相应的 redo 日志。

4. 更新其他的二级索引记录。

至此，一条记录就更新完了，然后开始记录该语句对应的 bin log。但是在事务提交时才会统一将该事务运行过程中的所有 bin log 刷新到磁盘。





