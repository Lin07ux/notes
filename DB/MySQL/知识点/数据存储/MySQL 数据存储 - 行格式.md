> 转摘：[字节一面，问的有点细](https://mp.weixin.qq.com/s/sqW51yqeAXcDs9r84UFP7A)

行格式(Row Format)就是一条记录的存储结构。

InnoDB 提供了 4 种行格式：

* Redundant 非紧凑的行格式，是很古老的格式，在 MySQL 5.0 版本之前使用，现在基本不再使用；
* Compact 是一种紧凑的行格式，设计初衷就是为了让一个数据页能存放更多的行记录，从 MySQL 5.0 开始引入，并在 MySQL 5.1 之后作为默认行格式；
* Dynamic 紧凑的行格式，基于 Compact 进行改进，从 MySQL 5.7 之后作为默认行格式；
* Compressed 紧凑的行格式，基于 Compact 进行改进。

下面重点以 Compact 行格式进行介绍，因为 Dynamic 和 Compressed 都是以该格式为基础的。

Compact 行格式的一条记录分为**记录的额外信息**和**记录的真实数据**，其整体构成如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670561027)

## 一、记录的额外信息

记录的额外信息包括三个部分：变长字段长度列表、NULL 值列表、记录头信息。

为了更好的讲解这三部分信息的结构，下面都会通过如下的示例表作为例子：

```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `name` VARCHAR(20) NOT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

> 需要注意，这个表使用的字符集是 ASCII，也就是一个字符占用一个字节。

表中的数据如下：

 id   |  name  |  phone  |  age
-----:|:------:|:-------:|:------
  1   |  a     |  123    | 18
  2   |  b     |  1234   | (NULL)
  3   |  c     |  (NULL) | (NULL)

### 1.1 变长字段长度列表

变长字段是指其实际数据的长度是不固定的。比如，`varchar(n)`就是变长字段类型，而`char(n)`则是固定长度字段类型。

在存储数据的时候，对于变长字段字段来说，除了要存储实际的数据，还要存储其实际长度。因为在存储的时候，底层都是二进制串，有了字段的实际长度就能够很快的提取到该字段的实际数据。除了`varchar`类型，`text`和`blob`类型也是这种存储的。

**每个变长字段的长度会用 1 个字节或 2 个字节来表示**，单位为字节。也就是说，变长字段的长度范围为 1~65535，对应的列的长度就是 1~65535 字节。定义表结构的时候：

* 指定列的长度不超过 255 的时候，其对应的变长字段长度会用 1 个字节来表示；
* 指定列的长度在 256~65535 之间，则用 2 个字节表示。

在 InnoDB 中，**变长字段长度值会按照表定义中列顺序的逆序存放**，这涉及到行数据读取方式的考虑，后面会进行说明。

#### 1.1.1 示例说明

示例表中的第一条数据中变长字段长度如下：

* `id`列和`age`列不是变长字段，不需要存储长度；
* `name`列的值为`a`，长度是 1 个字节，长度对应的十六进制为`0x01`；
* `phone`列的值为`123`，长度是 3 字节（该列为 varchar 类型），长度对应的十六进制为`0x03`；

按照列顺序的逆序存放时，这行的变长字段长度列表里的内容就是`03 01`(`name`列在`phone`前面)：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670561879)

同样的道理，也可以得到第二条记录的行格式中，变长字段长度列表里的内容为`04 02`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670561924)

第三条记录中，因为`phone`列的值为 NULL，所以它并不对应实际的数据，此时就不需要在变长字段长度列表中存放该列的长度。所以第三行记录的变长字段长度列表中只会存储`name`字段的长度`03`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670562245)

#### 1.1.2 为什么变长字段长度列表要按照列顺序逆序存放？

*记录头信息*中指向下一个记录的指针，指向的是下一条记录的*记录头信息*和*真实数据*之间的位置。这样做的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。

而将变长字段长度列表中的信息按照表定义中列顺序的逆序存放，就可以使得位置靠前的列的真实数据和其对应的字段长度信息同时存在一个 CPU Cache Line 中，从而能够提高 CPU 的命中率。

另外，这样存放也使得变长字段长度列表在读取的时候，其顺序和读取记录真实数据的顺序是一致的。

同样的道理，NULL 值列表的值也是按照列顺序的逆序存放的。而且由于列是否为 NULL 值会影响变长字段长度列表中是否有对应的列的长度，所以 NULL 值列表要更靠近行记录的真实数据，这样就可以先读取 NULL 值，再读取变长字段的长度。

#### 1.1.3 每个数据表的行格式中都有变长字段长度列表吗？

其实变长字段长度列表并不是必须的，主要分两种不存在的情况：

* 数据表中没有定义变长字段列
* 变长字段列的值都是 NULL

这两种情况下，变长字段长度列表没有存在的意义，所以就不会出现，以节省空间。

### 1.2 NULL 值列表

在表定义的时候，可能会指定某些列的值允许为 NULL。如果在存放实际数据的时候，如果列值为 NULL，而把 NULL 值直接存入到真实数据中会比较浪费空间。所以 Compact 行格式会采用 bitmap 的方式来标记可以为 NULL 的列其值是否为 NULL，从而避免了空间的浪费。

NULL 值列表本身就相当于一个 bitmap，其每一位(bit)对应表中可为 NULL 的列的真实数据是否为 NULL：

* 二进制位的值为 1 时，代表该列的值为 NULL；
* 二进制位的值为 0 时，代表该列的值不为 NULL。

不过，**NULL 值列表必须包含整数个字节**（1 字节 8 位）。如果表中可为 NULL 的列的数量不为 8 的整数倍，那么 NULL 值列表会在高位补足适量的 0，以凑成整数个字节。

**NULL 值列表也是按照表中列顺序的逆序存放的**。

#### 1.2.1 示例

示例表中，定义了三个可为 NULL 的列：`name`、`phone`和`age`，所以该表的行格式中，NULL 值列表占用 1 个字节的空间，且其中的第三位是有效位，对应这三个列的真实数据是否为 NULL。

表中第一条数据中，没有任何一个列为 NULL，所以对应的是二进制`0 0 0`，那么其 NULL 值列表的值就是`0x00`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670563605)

第二条记录中，列`age`为 NULL，而`name`和`phone`列不为 NULL，所以对应的二进制为`1 0 0`，其 NULL 值列表的值就是`0x04`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670563679)

第三条记录中，`phone`和`age`都为 NULL，`name`不为 NULL，所以对应的二进制为`1 1 0`，其 NULL 值列表的值就是`0x06`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670563730)

填充了变长字段长度列表和 NULL 值列表后，这三条记录的行记录如下：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670563788)


#### 1.2.2 每个表的行格式都有 NULL 值列表吗？

NULL 值列表也不是必须的：当数据表的字段都定义成`NOT NULL`的时候，其行格式中就不会有 NULL 值列表了。

所以在设计数据库表的时候，通常都是建议将字段设置为`NOT NULL`，这样至少可以节省 1 字节的 NULL 值列表空间。

不过需要注意的是，只要定义了列可以为 NULL，那么不论该列的真实值是否为 NULL，行格式中都会有 NULL 值列表。

### 1.3 记录头信息

记录头信息中包含的内容很多，主要是用来指示数据状态、标识数据指针等。下面是比较重要的三个记录头信息字段：

* `delete_mask` 标识字条数据是否被删除。在执行`DELETE`的时候，并不会立即把真实数据记录给删除掉，而是先将其`delete_mask`标记设置为 1，之后有需要的时候才会进行真正数据记录删除清理。

* `next_record` 记录下一条记录的位置。InnoDB 存储引擎中，记录与记录之间是通过链表组织的，所以每条记录都会有下一条记录的位置信息。而且，这个位置是指向下一条记录中*记录头信息*与*真实数据*之间的位置。

* `record_type` 表示当前记录的类型：0 表示普通记录，1 表示 B+ 数非叶子节点记录，2 表示最小记录，3 表示最大记录。

## 二、真实数据

记录的真实数据部分除了定义的字段对应的值，还设置了三个隐藏字段：

* `row_id` 占用 6 个字节，但不是必须的。在建表的时候如果没有指定主键或者唯一键约束列，那么 InnoDB 就会为该记录自动生成一个`row_id`隐藏字段，否则该字段不存在。
    
* `trx_id` 占用 6 个字节，必须要的，记录事务 ID，表示这个数据是由哪个数据生成或修改的。

* `roll_pointer` 占用 7 个字节，必须的，记录上一个版本的指针。InnoDB 中使用 MVCC 机制来保存一个记录的多个版本，多个版本之间就是使用该字段进行串联的，指向的是 undo log 中的位置。

真实数据的行格式如下所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670564695)

**一行数据的变长字段长度列表、NULL 值列表和真实数据三者的总长度，最大不能超过 65535 字节**。

### 2.1 行溢出

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 16KB，也就是 16384 字节。而一个`varchar(n)`类型的列最多可以存储 65533 字节；一些大对象如 TEXT、BLOB 可能存储更多的数据。这时一个页可能就存不了一条记录了。

在一般情况下，InnoDB 的数据都是存放在**数据页**中。如果一个数据页存储不了一条记录，InnoDB 存储引擎会在记录的真实数据处保存改行的部分数据，而把剩余的数据存放到**溢出页**中，并在真实数据处用 20 字节存储指向溢出页的地址，这样就可以找到剩余数据所在的页。

![](https://cnd.qiniu.lin07ux.cn/markdown/1670685204)

上面这个是 Compact 行格式在发生行溢出后的处理，Compressed 和 Dynamic 行格式与之类似，但是它们不会在数据页的行记录中存储真实数据，而是将记录的全部真实数据都放在溢出页中。如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670685307)


