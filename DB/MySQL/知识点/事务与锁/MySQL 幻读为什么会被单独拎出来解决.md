> 转摘：[幻读为什么会被 MySQL 单独拎出来解决？](https://mp.weixin.qq.com/s/snEP-mwx6MkBBWmPH4ZvmA)

所谓幻读，就是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。

但是幻读有什么后果呢？为什么会被 MySQL 单独拎出来解决呢？MySQL 又是如何解决的呢？

### 1. 当前读和快照读

在了解幻读以及 MySQL 是如何解决幻读这个问题前，需要知道，什么是当前读、什么是快照读。

**快照读**：读取当前连接的快照视图中的数据，不需要进行加锁。

**当前读**：读取的是最新版本的数据，并且对读取的记录加锁，阻塞其他事务同时改动该记录，避免出现安全问题。

MVCC 作用于读取已提交和可重复读（默认）这两个隔离级别，而在这两个隔离级别下的普通 select 操作就是快照读。除了这两个隔离级别下的普通 select 操作，其余操作都是当前读：

```sql
SELECT ... LOCK IN SHARE MODE
SELECT ... FOR UPDATE
UPDATE
DELETE
INSERT
```

以可重复读隔离级别举个例子，假设目前有一张 user 表，有如下数据：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964072520-ccebf86c757d.jpg)

开启两个事务：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964087294-fa0a034acb93.jpg)

事务 1 先进行快照读，很正常的结果：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964114812-4f3f9a373001.jpg)

事务 2 修改记录`age = 99`，并提交：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964140477-d0b61c36df89.jpg)

这时候，事务 1 快照读读出来的数据依然是旧数据：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964163026-e15e8a767963.jpg)

如果事务 1 改用当前读，读取出来的就是最新的数据了：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964184481-7c9f505819ad.jpg)

### 2. 幻读是什么现象

在可重复读隔离级别下，普通的查询是快照读，当前事务是不会看到别的事务插入的数据的。因此，幻读问题在当前读下才会出现。

> 有很多文章说用 MVCC 来解决快照读下的幻读问题，其实没有必要纠结，因为没有 MVCC 机制就没有快照读这个东西。

那么幻读到底是怎么出现的呢？

假设有一张表`user(id, username, age)`，已经有两条数据，`(1, "Jack", 20), (2, "Tom", 18)`。有如下三个事务：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964366648-730b9f2f13fd.jpg)

假设事务 1 的`SELECT * FROM user WHERE name = "Jack" FOR UPDATE`语句只在`id = 1`这一行上加行锁。（`SELECT FOR UPDATE`语句会加行锁。）

可以看到，事务 1 执行了三次查询，都是要查出`name = "Jack"`的记录行。假设这里只在`name = "Jack"`的行上加行锁：

* 第一次查询只返回了`id = 1`这一行；
* 在第二次查询之前，事务 2 把`id = 2`这一行的 name 的值改成了`"Jack"`，因此事务 1 第二次查询的结果就是`id = 1`和`id = 2`这两行；
* 在第三次查询之前，事务 3 插入了一个`name = "Jack"`的新数据行，因此事务 1 第三次查询的结果就是`id in (1, 2, 3)`的这三行。

很显然，第三次查询读取到了`id = 3`这一行，这个现象就是幻读。

从逻辑上来说，这似乎是没有问题的，因为这三次查询都是加了`FOR UPDATE`的，要进行当前读。而当前度的规则就是要能够读到所有已经提交的记录的最新值，所有第二次查询和第三次查询的就是应该看到事务 2 和事务 3 的操作结果。

### 3. 幻读到底有什么问题

**首先是语义上的问题。**

事务 1 在第一次查询的时候就声明了，要把所有`name = "Jack"`的行锁住，拒绝别的事务对这些行进行读写操作。但实际上，这个语义被破坏了。

举个例子，对于上面的三个事务，再往事务 2 里加一条 SQL 语句（黄色的）：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638964842415-a22a5eca132b.jpg)

新加的这个 SQL 的意思是把`id = 2`的这一行的 age 值改成 40。而这行的`name`在前面被改成了`"Jack"`。

在事务 2 执行之前，事务 1 只是给`id = 1`的这一行加了行锁，并没有给`id = 2`的这行加锁。所以事务 2 是可以执行这条 update 语句的。

这样，事务 2 先将`id = 2`的 name 改成了`"Jack"`，然后再将 age 改为 40，破坏了事务 1 对要把所有`name = "Jack"`的行锁住的声明。

**其次，也是最重要的，数据一致性的问题**。

加锁是为了保护数据的一致性，这个一致性不仅包括数据的一致性，还包括日志文件的一致性。

举个例子，给事务 1 再加上一条 SQL 语句（黄色）：

![](http://cnd.qiniu.lin07ux.cn/markdown/1638965039413-eee5a5c98823.jpg)

对于上图中的四个时刻，数据库的状态变化如下：

1. 经过 T1 时刻，`id = 1`这一行变成了`(1, "Tom", 20)`，但是这个数据是在 T4 才正式提交的；
2. 经过 T2 时刻，`id = 2`这一行变成了`(2, "Jack", 40)`；
3. 经过 T3 时刻，表里面多了一条记录`(3, "Jack", 40)`。

binlog 就记录数据库中数据变动的操作，来看看这个时候 binlog 日志里面的内容：

1. T2 时刻，事务 2 提交，就写入 2 条 update 语句的记录：

    ```sql
    UPDATE user SET name = "Jack" WHERE id = 2
    UPDATE user SET age = 40 WHERE id = 2 /* (2, Jack, 40) */
    ```

2. T3 时刻，事务 3 提交了，写入了 1 条 insert 语句：

    ```sql
    INSERT user VALUES(3, "Jack", 30) /* (3, Jack, 30) */
    ```

3. T4 时刻，事务 1 提交，binlog 中写入了新的更新语句：

    ```sql
    UPDATE user SET name = "Tom" WHERE name = "Jack"
    ```

在 T4 时刻，按照 binlog 中记录的语句，就是说要将所有`name = "Jack"`的行，都给改成`name = "Tom"`。

这样就出现问题了：binlog 一般用于备库同步主库，这个 binlog 一旦在备库中执行，那岂不是将`id = 2`和`id = 3`这两行的 name 都给改成了`"Tom"`了？

也就是说，`id = 2`和`id = 3`这两行发生了数据不一致。

### 4. 如何加锁

从上面的例子可以看出，数据不一致会发生在这个假设上的：假设事务 1 的`SELECT FOR UPDATE`语句只会在`id = 1`这一行上加锁导致的。

很显然，指锁这一行是不合理的。那就让`SELECT FOR UPDATE`把所有扫描到的行都给锁住不就行了？

这样做，能让事务 2 在 T2 时刻提交时被阻塞住，直到事务 1 在 T4 时刻提交之后释放锁。

![](http://cnd.qiniu.lin07ux.cn/markdown/1638965868220-3471b3af2115.jpg)

这样看似没问题。看下这时的 binlog，执行序列如下：

```sql
-- 事务 3
INSERT INTO user VALUE(3, "Jack", 30) /* (3, Jack, 30) */

-- 事务 1
UPDATE user SET name = "Tom" WHERE name = "Jack"

-- 事务 2
UPDATE user SET name = "Jack" WHERE id = 2
UPDATE user SET age = 40 WHERE id = 2 /* (2, Jack, 40) */
```

可以看到，事务 2 的问题确实是解决了，`id = 2`的记录的 name 还能是`"Jack"`。

但是！事务 3 依旧会在事务 1 之前提交，它写入的`(3, "Jack", 30)`记录，按照 binlog 的执行顺序，依旧会被改成`(3, "Tome", 30)`。也就是说幻读的问题还是没有解决。

为什么已经把所有能够扫描到的记录都加上了锁，还是阻止不了`id = 3`这一行的插入和更新呢？

很简单：在给所有行加锁的时候，`id = 3`这一行还不存在，数据库扫描不到，也就当然加不上锁了。

![](http://cnd.qiniu.lin07ux.cn/markdown/1638966121736-3758d674aa09.jpg)

这也是为什么幻读问题会被单独拿出来解决的原因，即使把表中所有的记录都加上锁还是阻止不了新插入的记录。

### 5. MySQL 如何解决幻读

通过前面的分析，可以知道，**产生幻读的原因是：行锁只能锁住特定的行，但是新插入记录这个动作，操作的是被锁住的行之间的“间隙”**。

因此，为了解决幻读问题，InnoDB 只能引入新的锁，也就是间隙锁（Gap Lock）。

这样，当执行`SELECT * FROM user WHERE name = "Jack" FOR UPDATE`的时候，就不只是给数据库中已有的 n 行记录加上行锁，还同时加了 n + 1 个间隙锁（这两个锁合起来也称为 Next-Key Lock，临键锁）。

也就是说，在数据库一行行扫描的过程中，不仅扫描到的行加上了上锁，还给行两边的空隙也加上了锁。这样就确保了无法再在这个间隙中插入新的记录了。

> update/delete 语句用不上索引是很恐怖的。对非索引字段进行`SELECT FOR UPDATE`、`UPDATE`或者`DELETE`操作，由于没有索引，就会走全表查询，会对所有行记录以及所有间隙都进行上锁。而对于索引字段进行上述操作，只有索引字段本身和附近的间隙会被加锁。

总结下 MySQL 解决幻读的方法：

* 可重复读隔离级别下：快照读 MVCC + 当前读 Next-Key Lock（只在可成功复读隔离级别下生效）；
* Serializable 隔离级别下：在这个隔离级别下，事务在读操作时，先加表级别的共享锁，直到事务结束才释放；事务在写操作时，先加表级别的排它锁，直到事务结束才释放。也就是说，串行化锁定了整张表，幻读不存在的。


