> 转摘：[手把手教你分析Mysql死锁问题](https://www.cnblogs.com/jay-huaxiao/p/12685287.html)

> 下面的说明以 MySQL InnoDB 存储引擎为例。

## 一、锁类别

MySQL 中的锁根据不同的方式可以分为如下的几种类别：

![](http://cnd.qiniu.lin07ux.cn/markdown/1587716080800.png)

### 1.1 共享锁与排他锁

MySQL InnoDB 引擎实现了标准的行级锁，包括两种：

* 共享锁(简称`s 锁`)：允许持锁事务读取一行。
* 排它锁(简称`x 锁`)：允许持锁事务更新或删除一行。

如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：

* T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁
* T2 请求 x 锁不能被立即允许。

如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为 x 锁与任何的锁都不兼容。

兼容性如下表所示：

           | S         | X
-----------|-----------|-----------
 S         | 兼容       | 不兼容
 X         | 不兼容     | 不兼容

### 1.2 意向锁

关于意向锁，有如下的说明：

> Intention locks are *table-level locks* that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.

也就是说，**意向锁是一个表级锁**，起作用就是**指明事务接下来会用到哪种锁（共享锁、排他锁）**。所以，意向锁有两种类型：

* 意向共享锁(IS 锁)：事务想要获得一张表中某几行的读锁（行级读锁）；
* 意向排他锁(IX 锁)：事务想要获得一张表中某几行的写锁（行级写锁）。

申请意向锁的动作是自动完成的，就是说，事务申请一行的行锁的时候，InnoDB 存储引擎会自动为事务先申请该表的意向锁，并不需要调用方显式的申请。

**意向锁的存在是为了简化加表锁时的判断**。

比如事务要申请该表的写锁，如果没有意向锁就需要遍历表中的行，以检查是否有行锁的存在。而通过表级别的意向锁则可以大大简化这个判断过程，提升效率：任何事务加行锁的时候都会申请该表的相关类型的意向锁，其他事务在申请表锁时只需要判断该表是否被加了某类型的意向锁即可。

也就是说，意向锁相当于为表提供了其行数据是否有锁以及是什么类型的行锁的标识，从而简化后续其他锁的申请判断。

InnoDB 存储引擎中锁的兼容性如下表：

           | S         | X         | IS        | IX
-----------|-----------|-----------|-----------|-----------
 S         | 兼容       | 不兼容     | 兼容      | 不兼容
 X         | 不兼容     | 不兼容     | 不兼容     | 不兼容
 IS        | 兼容       | 不兼容     | 兼容      | 兼容
 IX        | 不兼容     | 不兼容     | 兼容       | 兼容

### 1.3 记录锁(Record Locks)

记录锁是最简单的行锁，仅仅锁住一行。如：`SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE`。

**记录锁永远都是加在索引上**的，即使一个表没有索引，InnoDB 也会隐式的创建一个索引，并使用这个索引实施记录锁。

记录锁会阻塞其他事务对其插入、更新、删除。

### 1.4 间隙锁(Gap Locks)

间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。

使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。

间隙锁只阻止其他事务插入到间隙中，他们不阻止其他事务在同一个间隙上获得间隙锁，所以`gap x lock`和`gap s lock`有相同的作用。

### 1.5 Next-Key 锁

Next-Key 锁是记录锁和间隙锁的组合，它指的是加在某条记录以及这条记录前面间隙上的锁。

### 1.6 插入意向锁(Insert Intention)

插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。

假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方，因为插入行不冲突。

间隙锁、插入意向锁、记录锁和 Next-Key 锁之间的兼容性如下表所示（横向是已持有锁，纵向是正在请求的锁）：

                  | GAP       | Insert Intention | Record    | Next-Key
------------------|-----------|------------------|-----------|-----------
 GAP              | 兼容       | 兼容              | 兼容      | 兼容
 Insert Intention | 冲突       | 兼容              | 兼容      | 冲突
 Record           | 兼容       | 兼容              | 冲突      | 冲突
 Next-Key         | 兼容       | 兼容              | 冲突      | 冲突


## 二、锁示例

### 2.1 select for update

`for update`仅适用于 InnoDB 引擎，且必须在事务块中(`BEGIN/COMMIT`之间)才能生效。

在进行事务操作时，通过**`for update`**语句，MySQL 会**对查询结果集中的每一行数都添加排他锁**，其他线程对该记录的更新与删除操作都会阻塞。这里的排它锁包含行锁、表锁。

InnoDB 引擎的锁实现意味着：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁！

假设有个表 products，包含 id、type 和 name 三个列，其中 id 是主键，有如下几种加锁情况：

* 明确指定主键，并且有此行记录，加行锁：

    ```sql
    SELECT * FROM products WHERE id = 3 FOR UPDATE;
    SELECT * FROM products WHERE id = 3 AND type = 1 FOR UPDATE;
    ```

* 明确指定主键，但无该记录，不加锁

    ```sql
    SELECT * FROM products WHERE id = -1 FOR UPDATE;
    ```

* 不指定主键，加表锁

    ```sql
    SELECT * FROM products WHERE name = 'Mouse' FOR UPDATE;
    ```

* 主键不明确，加表锁

    ```sql
    SELECT * FROM products WHERE id <> 1 FOR UPDATE;
    SELECT * FROM products WHERE id like '3' FOR UPDATE;
    ```


