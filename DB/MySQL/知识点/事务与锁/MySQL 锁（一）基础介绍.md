> 转摘：
> 
> 1. [手把手教你分析Mysql死锁问题](https://www.cnblogs.com/jay-huaxiao/p/12685287.html)
> 2. [终于被我说清楚了！](https://mp.weixin.qq.com/s/Ef73pSWb_k6yiTTlNCrEjg)

> 下面的说明以 MySQL InnoDB 存储引擎为例。

## 一、锁类别

MySQL 中的锁根据不同的方式可以分为如下的几种类别：

![](http://cnd.qiniu.lin07ux.cn/markdown/1587716080800.png)

### 1.1 共享锁与排他锁

MySQL InnoDB 引擎实现了标准的行级锁，包括两种：

* 共享锁(简称`s 锁`)：允许持锁事务读取一行。
* 排它锁(简称`x 锁`)：允许持锁事务更新或删除一行。

如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：

* T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁
* T2 请求 x 锁不能被立即允许。

如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才可以，因为 x 锁与任何的锁都不兼容。

兼容性如下表所示：

           | S         | X
-----------|-----------|-----------
 S         | 兼容       | 不兼容
 X         | 不兼容     | 不兼容

### 1.2 意向锁

关于意向锁，有如下的说明：

> Intention locks are *table-level locks* that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table.

也就是说，**意向锁是一个表级锁**，起作用就是**指明事务接下来会用到哪种锁（共享锁、排他锁）**。所以，意向锁有两种类型：

* 意向共享锁(IS 锁)：事务想要获得一张表中某几行的读锁（行级读锁）；
* 意向排他锁(IX 锁)：事务想要获得一张表中某几行的写锁（行级写锁）。

申请意向锁的动作是自动完成的，就是说，事务申请一行的行锁的时候，InnoDB 存储引擎会自动为事务先申请该表的意向锁，并不需要调用方显式的申请。

**意向锁的存在是为了简化加表锁时的判断**。

比如事务要申请该表的写锁，如果没有意向锁就需要遍历表中的行，以检查是否有行锁的存在。而通过表级别的意向锁则可以大大简化这个判断过程，提升效率：任何事务加行锁的时候都会申请该表的相关类型的意向锁，其他事务在申请表锁时只需要判断该表是否被加了某类型的意向锁即可。

也就是说，意向锁相当于为表提供了其行数据是否有锁以及是什么类型的行锁的标识，从而简化后续其他锁的申请判断。

InnoDB 存储引擎中锁的兼容性如下表：

           | S         | X         | IS        | IX
-----------|-----------|-----------|-----------|-----------
 S         | 兼容       | 不兼容     | 兼容      | 不兼容
 X         | 不兼容     | 不兼容     | 不兼容     | 不兼容
 IS        | 兼容       | 不兼容     | 兼容      | 兼容
 IX        | 不兼容     | 不兼容     | 兼容       | 兼容

### 1.3 插入意向锁(Insert Intention)

插入意向锁是在插入一行记录操作之前设置的一种间隙锁，这个锁释放了一种插入方式的信号，亦即多个事务在相同的索引间隙插入时如果不是插入间隙中相同的位置就不需要互相等待。

假设有索引值4、7，几个不同的事务准备插入5、6，每个锁都在获得插入行的独占锁之前用插入意向锁各自锁住了4、7之间的间隙，但是不阻塞对方，因为插入行不冲突。

间隙锁、插入意向锁、记录锁和 Next-Key 锁之间的兼容性如下表所示（横向是已持有锁，纵向是正在请求的锁）：

                  | GAP       | Insert Intention | Record    | Next-Key
------------------|-----------|------------------|-----------|-----------
 GAP              | 兼容       | 兼容              | 兼容      | 兼容
 Insert Intention | 冲突       | 兼容              | 兼容      | 冲突
 Record           | 兼容       | 兼容              | 冲突      | 冲突
 Next-Key         | 兼容       | 兼容              | 冲突      | 冲突

### 1.4 记录锁(Record Locks)

记录锁是最简单的行锁，仅仅锁住一行，阻塞其他事务对其插入、更新、删除。记录锁有 S 锁和 X 锁之分：

* S 型记录锁：当一个事务对一行记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁，但是不能对其加 X 型记录锁；
* X 型记录锁：当一个事物对一行记录加了 X 型记录锁后，其他事务不能继续对该记录加 S 型记录锁和 X 型记录锁。

如：`SELECT c1 FROM t WHERE id = 10 FOR UPDATE`，它会将`id = 1`这一行记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改和删除了。

**记录锁永远都是加在索引上**的，即使一个表没有索引，InnoDB 也会隐式的创建一个索引，并使用这个索引实施记录锁。

### 1.5 间隙锁(Gap Locks)

间隙锁是一种加在两个索引之间的锁，或者加在第一个索引之前，或最后一个索引之后的间隙。**间隙锁只存在于可重复读隔离级别，是为了解决该级别下的幻读现象**。

使用间隙锁锁住的是一个区间，而不仅仅是这个区间中的每一条数据。

*间隙锁只阻止其他事务插入到间隙中，它们不阻止其他事务在同一个间隙上获得间隙锁*，所以`gap x lock`和`gap s lock`有相同的作用。

### 1.6 Next-Key 锁

Next-Key 锁是记录锁和间隙锁的组合，它指的是**加在某条记录以及这条记录前面间隙上的锁**。

比如，表中有一个 id 范围为`(3, 5]`的 Next-Key Lock，那么其他事务既不能插入`id = 4`的记录，也不能修改`id = 5`的这条记录：

![](https://cnd.qiniu.lin07ux.cn/markdown/1672323101)

由于 Next-Key Lock 包含记录锁，而 X 型记录锁是排他的，所以 X 型的 Next-Key Lock 会阻止其他事务获取相同范围的 X 型的 Next-Key Lock 时。

## 二、加锁说明

### 2.1 加锁场景

MySQL MyISAM 存储引擎只支持表锁，而 InnoDB 存储引擎同时支持行锁和表锁。但在 InnoDB 引擎的锁实现中：**只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁**！

InnoDB 在可重复读隔离级别下，**普通的 SELECT 语句属于快照读，是不会对记录加锁的，而是通过 MVCC 来实现的**。无锁的快照读取使得 MySQL InnoDB 的读效率提升了很多。

而在锁定读（当前读）时会对读取的记录加行级锁：

```sql
-- 对读取的记录加共享锁（S 锁）
SELECT ... LOCK IN SHARE MODE;

-- 对读取的记录加排他锁（X 锁）
SELECT ... FOR UPDATE
```

上这两个语句必须处于事务中才能起所用，因为**当事务提交了锁就会被释放**。所以在使用上面这两条语句的时候，需要加上`BEGIN`或者`START TRANSACTION`开启事务的语句。

**UPDATE 和 DELETE 操作都会为对应的行记录加排他锁（X 锁）**。

### 2.2 查看锁信息

在 MySQL 中，可以通过查询`performance_schema.data_locks`表来看当前数据库中的加锁信息，也可以再查询的时候通过数据库名和表名进行过滤。

如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1672374750)

从上图可以看出，`test.user`表上加了两个锁：

* 表锁：X 类型的意向锁；
* 行锁：X 类型的记录锁。

其中，`LOCK_MODE`表示锁类型，X 表示排它锁，S 表示共享锁。比如：

* `LOCK_MODE: X`说明是 Next-Key Lock；
* `LOCK_MODE: X, REC_NOT_GAP`说明是记录锁；
* `LOCK_MODE: X, GAP`说明是间隙锁。

### 2.3 唯一索引等值查询

当使用唯一索引进行等值查询的时候，查询的记录在与不在也会影响加锁的规则：

* 存在：在索引树上定位到这条记录后为该记录添加记录锁 Record Lock；
* 不存在：在索引树上找到第一条大于该查询值的记录和第一条小于该查询值的记录，然后在这两条记录之间加上间隙锁 Gap Lock。

### 2.4 唯一索引范围查询

范围查询和等值查询的加锁规则是不同的：当唯一索引进行范围查询时，会对每一个扫描到的索引加 Next-Key 锁。

而如果遇到下面这些情况，会退化成记录锁或间隙锁：

* *>=* 的范围查询：因为存在等值查询的条件，如果等值查询的记录是存在于表中，那么该记录的索引中的 Next_key 锁会退化成记录锁；
* *<=* 的范围查询：扫描到终止范围查询的记录时，当条件值的记录不在表中，该终止记录的索引上的 Next-Key 锁会退化成间隙锁，否则不会退化。而其他扫描到的记录都是在这些记录的索引上加 Next-Key 锁；
* *<* 条件的范围查询：不论条件值记录是否存在，扫描到终止范围查询的记录时，该记录的索引的 Next-Key 锁都会退化成间隙锁。

### 2.5 非唯一索引等值查询

当使用**非唯一索引进行等值查询**的时候，因为存在两个索引：**主键索引和非唯一索引**（二级索引），所以在加锁时候会**同时对这两个索引加锁**。但是对主键索引加锁的时候，只有满足查询条件的记录才会加锁。

非唯一索引等值查询时，查询的记录存不存在时加锁的规则也会不同：

* 存在：由于不是唯一索引，所以肯定存在索引值相同的记录，于是等值查询过程是一个扫描的过程，直到扫描到第一个不符合条件的二级索引记录就停止扫描。在扫描过程中，对扫描到的二级索引记录加的是 Next-Key 锁，而对于第一个不符合条件的二级索引记录，该二级索引的 Next-Key 锁会退化成间隙锁。同时在符合查询条件的记录的主键索引上加记录锁。
* 不存在：扫描到第一条不符合条件的二级索引记录，该二级索引的 Next-Key 锁会退化成间隙锁。因为不存在满足查询条件的记录，所以不会对主键索引加锁。

当非唯一索引上加了 X 型间隙锁时，插入值为边界值的新记录时，有些情况可以成功插入，有些情况则不行。这与二级索引树的记录存放方式有关。

二级索引树是按照二级索引值按顺序存放的，在二级索引值相同的情况下，再按主键 ID 的顺序存放。知道了这个前提才能知道插入语句的时候，插入位置的下一条记录是什么。

比如，事务 A 在二级索引`age = 39`上加了 X 型的间隙锁，范围为`(22, 39)`。假设该二级索引的第一条主键值为`id = 20`，此时其他事务插入一条新的`age = 39`记录的时候：

* 如果插入的值为`age = 39, id = 3`，由于该记录在二级索引树的插入位置在`age = 39, id = 20`之前，而该位置的二级索引上已经被加了间隙锁，所以这次插入将会被阻塞；
* 如果插入的值为`age = 39, id = 22`，由于该记录在二级索引树的插入位置在`age = 39, id = 20`之后，该位置的下一条记录不存在，也就没有间隙锁了，所以这条插入语句可以插入成功，不被阻塞。

### 2.6 非唯一索引范围查询

非唯一索引的范围查询和主键索引的范围查询的加锁也有所不同，主要在于：**非唯一索引范围查询，索引的 Next-Key Lock 不会退化成间隙锁或记录锁**。也就是说，非唯一索引进行范围查询时，对二级索引记录加锁加的都是 Next-Key 锁。

### 2.7 for update 加锁示例

在进行事务操作时，通过**`for update`**语句，MySQL 会**对查询结果集中的每一行数都添加排他锁（行锁、表锁）**，其他事务对该记录的更新与删除操作都会阻塞。

假设有个表 products，包含`id`、`type`和`name`三个列，其中`id`是主键，有如下几种加锁情况：

* 明确指定主键，并且有此行记录，为对应的行加行锁：

    ```sql
    SELECT * FROM products WHERE id = 3 FOR UPDATE;
    SELECT * FROM products WHERE id = 3 AND type = 1 FOR UPDATE;
    ```

* 明确指定主键，但无该记录，不加锁

    ```sql
    SELECT * FROM products WHERE id = -1 FOR UPDATE;
    ```

* 不指定主键，加表锁

    ```sql
    SELECT * FROM products WHERE name = 'Mouse' FOR UPDATE;
    ```

* 主键不明确，加表锁

    ```sql
    SELECT * FROM products WHERE id <> 1 FOR UPDATE;
    SELECT * FROM products WHERE id like '3' FOR UPDATE;
    ```


