> 转摘：[MySQL 可重复读，差点就让我背上了一个 P0 事故！](https://mp.weixin.qq.com/s/MraH-Y8VktErKNum-sdd7Q)

MySQL 默认使用的是可重复读的事务隔离级别。在该级别下，InnoDB 引擎使用 MVCC 方式实现并发读取和写入，而在执行 SQL 查询的时候读取到的数据就会分成当前读和快照读。而这种处理方式会使得在某些情况下出现未预期的处理结果。

### 1. P0 事故：余额多扣！

现有一个交易系统，每次产生交易都会更新相应账户的余额，出账扣减余额，入账增加余额。为了保证资金安全，余额发生扣减时，需要比较现有余额与扣减金额大小：若扣减余额大于现有余额，则扣减失败。

对应的账户表结构，精简如下：

```sql
CREATE TABLE `account`
(
    `id`      bigint(20) NOT NULL,
    `balance` bigint(20) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_bin;
```

扣减余额时，SQL 语序如下表所示：

  时序                 |  事务
 ---------------------|--------------------------
 t1：取消自动提交       | `set autocommit = 0;`
 t2：查询校验当前账户数据 | `select * from account where id = 1;`
 t3：锁住当前账户记录    | `select * from account where id = 1 for update;`
 t4：进行其他操作        |
 t5：获取当前账户余额    | `select * from account where id = 1;`
 t6：判断余额是否足够    |
 t7：扣减余额           | `update account set balance = balance - 100 where id = 1;`
 t8：提交事务           | `commit;`
 
 > 这里有多次查询账户信息的操作，只是因为这些 SQL 语序并不在用一个方法中，而且没有被抽出复用，所以查询结果无法往下传递，所以需要多次查询。

为了防止并发更新余额，在 t3 时刻使用写锁锁住该行纪录。若加锁成功，则其他线程也执行到 t3 将会被阻塞，直到前一个线程事务提交。

在 t5 时刻，进入到下一个方法的时候，再次获取账户余额，然后在业务程序中比较余额与扣减金额，若余额充足，在 t7 时刻执行减余额的操作。

这个逻辑在 Oracle 数据库中运行正常，但是在 MySQL 中则会出现余额多扣的情况，也即是：余额明明小于扣减金额，但是却做了余额的更新操作，最后导致余额变成了负数。

### 2. 重现和分析

下面来重现并发时出现的这个问题：假设有两个事务正在并发的执行，两个事务之间的顺序如下表所示：

> MySQL 默认的事务隔离等级为 RR。数据库记录为 id = 1，balance = 1000，假设只有这两个事务在执行。

![](http://cnd.qiniu.lin07ux.cn/markdown/1591285822592.png)

在事务隔离级别为 RR 的情况下：

1. 事务 1 的查询结果为：

    * t2：`(1, 1000)`
    * t4：`(1, 1000)`
    * t6：`(1, 1000)`

2. 事务 2 的查询结果为：

    * t3：`(1,1000)`
    * t5：`(1,900)`
    * t11：`(1,1000)` 
> 其中，事务 2 中的 t5 时刻的查询会一直阻塞，直到事务 1 提交之后才会有结果。

将事务隔离等级修改成 RC 后，再次按照这个顺序执行，结果如下：

1. 事务 1 的查询结果为：

    * t2：`(1, 1000)`
    * t4：`(1, 1000)`
    * t6：`(1, 1000)` 
2. 事务 2 的查询结果为：

    * t3：`(1, 1000)`
    * t5：`(1, 900)`
    * t11：`(1, 900)` 
换成 RC 隔离级别之后，t11 的查询结果就完全不一样了，这其实就是因为在这两种隔离级别下，MySQL 在查询结果的时候，会用不同的版本的数据进行返回造成的。这里就涉及到如下的一些知识点：

* MVCC
* 一致性视图
* 快照读与当前读

### 3. MVCC

对于下面一个简单的查询时序例子(`id = 1, balance = 1000`)：

![](http://cnd.qiniu.lin07ux.cn/markdown/1591320588173.png)

事务隔离级别为 RR 的时候，事务 1 将记录的`balance`的值改为 900，然后事务 2 在 t5 时刻查询该行纪录，很显然，`balace`的值依然是 1000。如果事务 2 在 t5 时刻查询到的结果是`balace = 900`那就是读取到了事务 1 未提交的数据了，显然是不符合当前事务隔离级别的。

从上面例子中可以看到，`id = 1`的记录存证两个版本的数据，而这两个版本的数据分别为两个事务分别使用。这个功能就是通过 MySQL InnoDB 引擎的 MVCC 机制来实现的。

**MVCC: Multiversion concurrency control**，多版本并发控制。摘录一段淘宝数据库月报的解释：

> 多版本控制：指的是一种提高并发的技术。最早的数据库系统中，只有读读之间可以并发执行，读写、写读、写写都是需要阻塞执行的。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行执行，这样就大幅度提高了 InnoDB 的并发度。在内部实现中，与 PostgreSQL 在数据航上实现多版本不同，InnoDB 是在 undolog 中实现的，通过 undolog 可以找回数据的历史版本。召回的数据历史版本可以提供给用户读（按照隔离级别的定义，有些读请求只能看到比较老的数据版本），也可以在回滚的时候覆盖数据页上的数据。在 InnoDB 内部，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。

可以看到，MVCC 主要用来提高并发，还可以用来读取老版本的数据。

在学习 MVCC 的原理之前，需要先了解下 MySQL InnoDB 引擎的记录结构：

<div style="text-align: center">
    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1591321860550.png"/>
</div>

上图表示的是 Account 表的一行记录，除了用户数据之外，还会存储三个隐藏的字段，用来记录额外的信息：

* `DB_TRX_ID` 事务 id。
* `DB_ROLL_PTR` 回滚指针，指向 undolog。
* `ROW_ID` 行 id（与此次无关）。

MySQL InnoDB 里面每个事务都会有一个唯一事务 ID，它在事务开始的时候会跟 InnoDB 的事务系统申请的，并且严格按照顺序递增的。

每次事务更新数据时，将会生成一个新的数据版本，然后会把当前的事务 id 赋值给当前记录的`DB_TRX_ID`。并且数据更新记录（`1,1000 --> 1,900`）将会记录在 undo log（回滚日志）中，然后使用当前记录的`DB_ROLL_PTR`指向 undolog。

这样 MySQL 就可以通过`DB_ROLL_PTR`找到 undolog，并依次推导出之前版本记录内容。查找过程如下所示：

![查找过程](http://cnd.qiniu.lin07ux.cn/markdown/1591322108576.png)

如需要知道 V1 版本记录，首先根据当前版本 V3 的 DB_ROLL_PTR 找到 undolog，然后根据 undolog 内容，计算出上一个版本 V2。以此类推，最终找到 V1 这个版本记录。

> 需要注意的是：这里的 V1、V2 并不是物理记录，而是通过 undolog 推导出来的，没有真实存在，仅仅具有逻辑意义。

**一行记录可能同时存在多个版本，但并不是所有记录都能对当前事务可见**，不然前面示例中的 t5 时刻，事务 2 就能查询到最新的数据了。所以**查找数据版本时候，MySQL 必须判断数据版本是否对当前事务可见**。这个判断流程就需要使用到下面介绍的一致性视图了。

### 4. 一致性视图

MySQL 会在事务开始后建立一个一致性视图（*并不是立刻建立*），在这个视图中，会保存所有活跃的事务（*还未提交的事务*）。

假设当前事务保存的活跃事务数组如下图中所示：

<div style="text-align: center">
    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1591322438329.png"/>
</div>

图中：

* 黄色部分表示是已经在当前事务创建之前就完成了提交的事务 ID
* 绿色部分表示当前事务记录的目前尚未提交的事务 ID
* 红色部分表示在当前事务创建之后创建并提交了的事务 ID
* 蓝色部分表示在当前事务执行期间已经提交了事务 ID

判断版本对于当前事务是否可见时，基于以下规则判断：

1. 若事务 ID 小于当前活跃事务 ID 数组最小值，比如黄色部分中的版本 ID 为 40 的事务，其 ID 小于活跃事务数组的最小值 45，就代表该事务已提交，其对应的版本值对当前事务可见。

2. 若事务 ID 大于当前活跃事务数组的最大值，比如红色部分中的版本 ID 为 100 的事务，其 ID 大于数组最大事务 ID 的值 90，说明这个事务是当前事务创建之后生成的，所以这个版本的数据对于当前事务是不可见的。

3. 若事务 ID 是当前活跃事务数组中的一个，比如 ID 为 56 的事务，表示其还未提交，所以该版本对于当前事务不可见。

4. 若事务 ID 不是当前活跃事务数组中的一个，但事务 ID 位于活跃事务数组最小值与最大值之间，比如 ID 为 57 的事务，代表该事务已提交，所以该版本的数据对于当前事务是可见的。

5. 若事务 ID 为当前事务 ID，代表该版本的数据是当前事务变更的，自然对当前事务也是可见的。

以上规则比较绕，有些抽象，结合上面的图片相对好理解些。简单来说，这些规则的意思就是：

1. 未提交事务生成的记录版本，不可见；
2. 一致性视图生成前，已提交事务生成的记录版本，可见；
3. 一致性视图生成后，新事物生成的记录版本，不可见；
4. 自身事务更新的记录版本，可见。

一致性视图只会在 RR 和 RC 级别下才会生成：

* 对于 RR 来说，一致性视图会在**第一个查询语句**的时候生成；
* 对于 RC 来说，一致性视图会在**每个查询语句**时重新生成。

### 5. 当前读与快照读

MySQL 使用 MVCC 机制，可以读取之前版本的数据，这些旧版本数据不会且也无法再去修改，就像快照一样，所以将这种查询称为**快照读**。

当前并不是所有查询都是快照读，对于`select ... for update / in share mode`这类加锁查询只会查询当前记录最新版本的数据，称为**当前读**。

### 6. 问题分析

了解完上面的原理之后，再回头分析一下上面查询结果的原因：

![](http://cnd.qiniu.lin07ux.cn/markdown/1591324562410.png)

事务隔离级别为 RR 的时候：

1. t2、t3 时刻两个事务由于执行了查询语句，所以分别建立了一致性视图；

2. t4 时刻，由于事务 1 使用了`select ... for update`为`id = 1`这一行加了锁，所以在 t5 时刻，事务 2 就必须等待事务 1 释放锁之后才能继续执行，也就是被阻塞到事务 1 提交了。

3. t6 时刻，事务 1 根据一致性视图，不能读取到其他事务提交的版本记录，所以数据没有变，然后在 t8 时刻事务 1 完成余额的扣减，使得此记录的`balance = 900`，并在 t9 时刻，事务 1 完成了提交操作。

4. 由于事务 1 已提交，其持有的`id = 1`的行锁被释放，所以事务 2 在 t5 时刻的请求被执行。由于 t5 是当前读，所以查询的结果为最新版本数据`id = 1, balance = 900`。

5. 在 t11 时刻，事务 2 再次查询`id = 1`的记录的数据时，由于当前这条记录的最新版本数据中`balance = 900`，但是最新记录的版本事务 ID 却是事务 2 创建时未提交的事务，位于事务 2 的活跃事务数组中。所以最新记录版本对于事务 2 是不可见的。这样就只能根据 undolog 去获取前面的旧数据了，所以得到的结果就是`balance = 1000`。

而当将事务隔离级别修改成 RC 的时候，由于每次都会重新生成一致性事务，所以 t11 时刻会生成一个新的一致性视图，此时事务 1 已经提交了，该行记录的最新版本对于事务 2 就是可见的了，所以 t11 时刻查询到的结果就是最新的值，也就是`balance = 900`。

这样就能解释通为何在 RR 和 RC 隔离级别下获取和执行结果不一致，以及为何会出现余额不足依旧会被扣减的情况了。

### 6. 总结

MySQL 默认事务隔离级别为 RR，InnoDB 引擎会为每一行数据都保存一个或多个版本，而每个版本都有独一的事务 ID。MySQL 会通过一致性视图和记录版本事务 ID 来确保数据版本的可见性。

相关规则总结如下：

* 对于 RR 事务隔离级别，普通查询仅能查询到事务启动前就已经提交完成的版本数据。
* 对于 RC 事务隔离级别，普通查询可以查询到查询语句启动前就已经完成提交的版本数据。
* 当前读总是读取最新版本的数据。


