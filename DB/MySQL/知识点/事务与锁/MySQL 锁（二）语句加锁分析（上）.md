> 转摘：[超全面 MySQL 语句加锁分析（上篇）（求转）](https://mp.weixin.qq.com/s/wSlNZcQkax-2KZCNEHOYLA)

一条 SQL 语句需要加的锁受到很多条件制约，比如：

* 事务的隔离级别；
* 语句执行时使用的索引（比如：聚簇索引、唯一二级索引、普通二级索引）；
* 查询条件（比如：等值条件`=`、范围条件`=<`、`>=`等）；
* 具体执行的语句类型（比如：一般的`SELECT`、锁定读的`SELECT`、更新`UPDATE`和删除`DELETE`等）。

而且，**加锁**只是为了解决并发事务执行过程中引起的*脏写*、*脏读*、*不可重复读*、*幻读*这些问题的一种解决方案（**MVCC** 算是一种解决*脏读*、*不可重复读*、*幻读*这些问题的解决方案）。而加锁的出发点是为了解决这些问题，不同情境下要解决的问题不一样，所以加的锁也不一样，不可为了加锁而加锁。当然，有时候会因为 MySQL 的具体实现不同而导致一些情境下的加锁有些不好理解，这就需要死记硬背。

读取时的加锁主要分为普通读和锁定读两种，其中锁定读的语句包含下面四种语句，后面会放在一起讨论：

* 语句一：`SELECT ... LOCK IN SHARE MODE;`
* 语句二：`SELECT ... FOR UPDATE;`
* 语句三：`UPDATE ...;`
* 语句四：`DELETE ...;`

> 语句一和二是 MySQL 中规定的两种锁定读的语法格式，而语句三和四是由于在执行过程中需要首先定位到被改动的记录并给记录加锁，也可以被认为是一种锁定读。

## 一、准备工作

建立一个存储三个英雄的表`hero`：

```sql
CREATE TABLE hero (
    number INT,
    name VARCHAR(100),
    country varchar(100),
    PRIMARY KEY (number),
    KEY idx_name (name)
) Engine=InnoDB CHARSET=utf8;
```

然后向这个表中插入几条记录：

```SQL
INSERT INTO hero VALUES
    (1, 'l刘备', '蜀'),
    (3, 'z诸葛亮', '蜀'),
    (8, 'c曹操', '魏'),
    (15, 'x荀彧', '魏'),
    (20, 's孙权', '吴');
```

现在，`hero`表就有了两个索引：一个聚簇索引（主键索引）、一个二级索引。示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/LXtevH-20210129134314.jpg)

## 二、普通的 SELECT 读

普通的`SELECT`语句在不同的隔离级别下，一般不需要加锁：

* `READ UNCOMMITTED`：不加锁，直接读取记录的最新版本，此时可能会发生*脏读*、*不可重复读*、*幻读*的问题。

* `READ COMMITTED`：不加锁，在每次执行普通的`SELECT`语句时都会生成一个 ReadView，这样解决了*脏读*的问题，但是没有解决*不可重复读*和*幻读*的问题。

* `REPEATABLE READ`：不加锁，只在第一次执行普通的`SELECT`语句时生成一个 ReadView，这样把*脏读*、*不可重复读*、*幻读*的问题都解决了。

* `SERIALIZABLE`：此时需要分两种情况讨论：
    - 在禁用自动提交时(系统变量`autocommit=0`)时，普通的`SELECT`语句会被转为`SELECT ... LOCK IN SHARE MODE`这样的加锁读语句，也就是在读取记录前需要先获得记录的`S 锁`，具体的加锁情况和`REPEATABLE READ`隔离级别下一样。
    - 在启用自动提交(系统变量`autocommit=1`)时，普通的`SELECT`语句并不加锁，只是利用 MVCC 来生成一个 ReadView 去读取记录。之所以不加锁，是因为启动自动提交意味着一个事务中只包含一条语句，一条语句也就没有不可重复读、幻读的问题了。

对于`REPEATABLE READ`隔离级别下的普通查询来说，MVCC 其实并不能完全的避免幻读问题。比如，有如下一个示例：

```sql
# 事务 T1，REPEATABLE READ 隔离级别下
mysql> BEGIN;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM hero WHERE number = 30;
Empty set (0.01 sec)

# 此时事务 T2 执行了：INSERT INTO hero VALUES(30, 'g关羽', '魏'); 并提交

mysql> UPDATE hero SET country = '蜀' WHERE number = 30;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> SELECT * FROM hero WHERE number = 30;
+--------+---------+---------+
| number | name    | country |
+--------+---------+---------+
|     30 | g关羽   | 蜀      |
+--------+---------+---------+
1 row in set (0.01 sec)
```

这个现象的步骤如下：

1. 在`REPEATABLE READ`隔离级别下，事务 T1 第一次执行普通的`SELECT`语句时生成了一个 ReadView。
2. 然后事务 T2 向表中插入了一条新的记录，并立即提交了。
3. 事务 T1 对新插入的记录进行更新。由于 ReadView 不能阻止事务 T1 中继续执行`UPDATE/DELETE`语句来对新插入的记录进行改动（因为事务 T2 已经提交，所以事务 T1 的改动并不会造成阻塞），所以该语句能正常执行，并将这条新纪录的`trx_id`隐藏列的值变成了事务 T1 的事务 ID。
4. 事务 T1 再次执行普通的`SELECT`语句的时候，这条记录就可以被看到了。

## 三、READ UNCOMMITTED/READ COMMITTED 隔离级别下的锁定读

这两种隔离级别下语句的加锁方式基本一致，所以就放到一块儿讨论。

> 值得注意的是：采用**加锁**方式解决并发事务带来的问题时，其实*脏读*和*不可重复读*在任何一个隔离级别下都不会发生，因为**读-写**操作需要排队进行。

### 3.1 主键等值查询锁定读

#### 3.1.1 `SELECT ... LOCK IN SHARE MODE`语句

比如：
    
```sql
SELECT * FROM hero WHERE number = 8 LOCK IN SHARE MODE;
```

这个语句执行时只需要访问一下聚簇索引中`number`值为 8 的记录，索引只需要给它添加一个 **S 型记录锁**，如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/a86hhG-20210129144505.jpg)

#### 3.1.2 `SELECT ... FOR UPDATE`语句

比如：
    
```sql
SELECT * FROM hero WHERE number = 8 FOR UPDATE;
```
    
这个语句执行时只需要访问一下聚簇索引中`number`值为 8 的记录，所以只需要给它加一个 **X 型记录锁**就好了，如图所示：
    
![](http://cnd.qiniu.lin07ux.cn/markdown/Jmcvbf-20210129144710.jpg)

#### 3.1.3 `UPDATE ...`语句

比如：
    
```sql
UPDATE hero SET country = '汉' WHERE number = 8;
```
    
这条`UPDATE`语句并没有更新二级索引，所以其加锁方式和上面说的`SELECT ... FOR UPDATE`语句一致，也是给聚簇索引中`number`值为 8 的记录添加了一个 **X 型记录锁**。
    
如果`UPDATE`语句中更新了二级索引，比如：
    
```sql
UPDATE hero SET name = 'cao曹操' WHERE number = 8;
```
    
该语句的实际执行步骤是：首先更新对应的`number = 8`的聚簇索引记录，然后再更新对应的二级索引记录。所以其加锁步骤就是：
    
1. 为`number = 8`的聚簇索引记录加上 **X 型记录锁**；
2. 为该聚簇索引记录对应的`idx_name`二级索引记录（也就是`name = 'c曹操' && number = 8`的那条二级索引记录）加上 **X 型记录锁**。
    
如下图所示（图中带圆圈的数字来表示为各条记录加锁的顺序）：
    
![](http://cnd.qiniu.lin07ux.cn/markdown/0axvNa-20210129145254.jpg)

#### 3.1.4 `DELETE ...`语句

比如：
    
```sql
DELETE FROM hero WHERE number = 8;
```
    
删除表中的一条记录其实意味着对聚簇索引和所有的二级索引中对应的记录做 DELETE 操作。本例子中就是要先把`number = 8`的聚簇索引记录执行 DELETE 操作，然后把对应的`idx_name`二级索引记录删除，所以加锁的步骤和上边*更新带有二级索引列的`UPDATE`语句一致*。

### 3.2 使用主键进行范围查询的锁定读

#### 3.2.1 `SELECT ... LOCK IN SHARE MODE`和`SELECT ... FOR UPDATE`语句

这两种语句的加锁方式类似，只是`SELECT ... LOCK IN SHARE MODE`加的是 **S 型记录锁**，而`SELECT ... FOR UPDATE`加的是 **X 型记录锁**。

比如：

```sql
SELECT * FROM hero WHERE number <= 8 LOCK IN SHARE MODE;
```

这个语句看起来十分简单，但是它的执行过程还是有一点小复杂的：

1. 先到聚簇索引中定位到满足`number <= 8`的第一条记录，也就是`number = 1`的记录，然后为其加 **S 型记录锁**或 **X 型记录锁**。

2. 判断该记录是否符合*索引条件下推*中的条件

    索引条件下推(Index Condition Pushdown，简称 ICP)，就是把查询中与被使用索引有关的查询条件下推到存储引起中判断，而不是返回到 Server 层再判断。不过需要注意的是，索引条件下推只是为了减少回表次数，从而减少 IO 操作。而对于聚簇索引而言，并不需要回表，它本身就包含着全部的列，也起不到减少 IO 操作的作用。所以 InnoDB 规定，这个索引条件下推特性只适用于二级索引。也就是说，在本例中，与被使用索引条件有关的条件是`number <= 8`，而`number`列又是聚簇索引列，所以本例中并没有符合索引条件下推的查询条件，自然也就不需要判断该记录是否符合索引条件下推中的条件。
    
3. 判断该记录是否符合范围查询的边界条件

    因为在本例中是利用主键`number`进行范围查询，InnoDB 引擎规定：每从聚簇索引中取出一条记录时，都要判断一下该记录是否符合范围查询的边界条件（对于本例来说，就是`number <= 8`这个条件）。如果符合的话，将其返回给 Server 层继续处理，否则的话需要释放掉在该记录上加的锁，并给 Server 层返回一个查询完毕的信息。
    
    对于`number = 1`的记录，是符合这个条件的，所有会将其返回到 Server 层继续处理。

4. 在 Server 层继续处理该记录

    Server 层如果收到存储引擎层提供的查询完毕的信息，就结束查询，否则继续判断那些没有进行索引条件下推的条件。在本例中就是继续判断`number <= 8`这个条件是否成立。如果该记录符合剩余的条件，那么就把它发送给客户端，不然的话就会释放掉在该记录上加的锁。
    
    > 这里之所以又判断一次，是因为 InnoDB 引擎设计的策略就是这么简单粗暴：把凡是没有经过索引条件下推的条件都需要放到 Server 层再判断一次。

5. 然后对刚刚查询得到的记录（也就是`number = 1`的记录）组成的单向链表继续向后查找，重复执行 1~5 这几个步骤。

> 上述步骤是在 MySQL 5.7.21 这个版本中验证的，不保证其他版本有无出入。

这个步骤中，比较特殊的就是`number = 15`的这条记录。因为，根据上述的步骤，在获取到`number = 8`的记录之后，还会继续向后查找一条数据，并对其进行 1~5 这 5 个步骤的处理。也就是：

1. 先对`number = 15`记录加锁；
2. 无索引条件下推，跳过；
3. 该记录不符合`number <= 8`这个条件，所以会释放掉这条记录的锁，并返回查询完毕的结果给 Server 层。

可以看到，对于`number = 15`的记录，会先对其加锁，然后再把锁释放掉。过程如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/64uRCk-20210129164020.jpg)

这个过程有意思的一点就是，如果先在事务 T1 中执行：

```sql
# 事务T1
BEGIN;
SELECT * FROM hero WHERE number <= 8 LOCK IN SHARE MODE;
```

然后再到事务 T2 中执行：

```sql
# 事务T2
BEGIN;
SELECT * FROM hero WHERE number = 15 FOR UPDATE;
```

这个顺序操作是没有问题的，因为事务 T2 执行时，事务 T1 已经释放掉了`number = 15`的记录锁，但是如果先执行事务 T2，在执行事务 T1，此时由于事务 T2 已经持有了`number = 15`的记录锁，事务 T1 将会因为获取不到这个锁而等待。

而对于另一种使用主键进行范围查询的例子：

```sql
SELECT * FROM hero WHERE number >= 8 LOCK IN SHARE MODE;
```

这个例子和上面的示例的执行顺序是类似的，也是先到聚簇索引中定位到满足`number >= 8`这个条件的第一条记录，也就是`number = 8`这个记录。然后沿着由这个记录组成的单向链表一路向后找，对每一条找到的记录都先加锁，然后进行边界条件判断。但是对于`number >= 8`这个条件来说，边界条件跟没有一样，往后找到的每条记录都会符合这个边界条件。

当 InnoDB 找到索引中的最后一条记录，也就是`Supremum`伪记录后，在存储引擎内部就可以立即判断这是一条伪记录，不必要返回给 Server 层处理，而且也没必要给它也加上锁（也就是说在第 1 步中就压根儿没给这条记录加锁）。整个过程会给`number`值为 8、15、20 这三条记录加上S型正经记录锁，画个图表示一下就是这样：

![](http://cnd.qiniu.lin07ux.cn/markdown/ML79Eb-20210129165522.jpg)

#### 3.2.2 `UPDATE ...`语句

对于不更新二级索引列的`UPDATE`语句来说，加锁方式和上面所说的`SELECT ... FOR UPDATE`一致。比如：

```sql
UPDATE hero SET country = '汉' WHERE number >= 8;
```

如果`UPDATE`语句中更新了二级索引列，比如：

```sql
UPDATE hero SET name = 'cao曹操' WHERE number >= 8;
```

这时候会首先更新聚簇索引记录，再更新对应的二级索引记录，所以，加锁的步骤就是：

1. 为`number = 8`的聚簇索引记录加上 **X 型记录锁**；
2. 然后为上一步中的聚簇索引记录对应的`idx_name`二级索引记录加 上**X 型记录锁**；
3. 为`number = 15`的聚簇索引记录加上 **X 型记录锁**；
4. 然后为上一步中的聚簇索引记录对应的`idx_name`二级索引记录加上 **X 型记录锁**；
5. 为`number = 20`的聚簇索引记录加上 **X 型记录锁**；
6. 然后为上一步中的聚簇索引记录对应的`idx_name`二级索引记录加上 **X 型记录锁**；

如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/8odhjO-20210130001710.jpg)

而如果是下面的语句：

```sql
UPDATE hero SET namey = '汉' WHERE number <= 8;
```

则会对`number`值为 1、3、8 的聚簇索引记录以及它们对应的二级索引记录依次添加 **X 型记录锁**，和上面的语句中的加锁顺序类似，都是先对一条聚簇索引记录加锁后，再给对应的二级索引记录加锁。之后会继续对`number = 15`的聚簇索引记录加锁，但是随后 InnoDB 存储引擎判断它不符合边界条件，随机会释放掉该聚簇索引记录上的锁。在这个过程中并没有对`number = 15`的聚簇索引记录对饮的二级索引记录加锁。

#### 3.2.3 `DELETE ...`语句

下面的两种`DELETE`语句：

```sql
DELETE FROM hero WHERE number >= 8;
DELETE FROM hero WHERE number <= 8;
```

其加锁情况都和更新带有二级索引列的`UPDATE`语句一致。

### 3.3 使用二级索引进行等值查询的锁定读

在`READ UNCOMMITTED`和`READ COMMITTED`隔离级别下，使用普通的二级索引和唯一二级索引进行加锁的过程是一样的，所以就不分开讨论了。

#### 3.3.1 `SELECT ... LOCK IN SHARE MODE`语句

比如：

```sql
SELECT * FROM hero WHERE name = 'c曹操' LOCK IN SHARE MODE;
```

这个语句执行过程是先通过二级索引`idx_name`定位到满足`name = 'c曹操'`条件的二级索引，然后进行回表操作。所以加锁的步骤如下：

1. 先对二级索引记录加 **S 型记录锁**。
2. 再给对应的聚簇索引记录加 **S 型记录锁**。

示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/2t9pDV-20210130003314.jpg)

由于`idx_name`是一个普通的二级索引，所以在`idx_name`索引中定位到满足条件的第一条记录只会，就可以沿着这个记录继续向后查找。但是从上面的描述中可以看出来，并没有对下一套二级索引记录进行加锁。

这是因为，InnoDB 对等值匹配的条件有特殊处理：等值查询时，在查找到当前记录的下一条记录时，对其加锁前就直接判断该记录都是否满足等职匹配的条件，如果不满足就直接返回，也就是不加锁了；否则的话，需要将其加锁之后再返回给 Server 层。所以这里也就不需要对下一条二级索引进行加锁了。

由于这个语句的加锁条件是先二级索引、再聚簇索引，所以在并发的时候会出现**死锁**的情况。

比如，假设上面的这个语句在事务 T1 中运行，然后在事务 T2 中运行下面这个前面介绍过的语句：

```sql
UPDATE hero SET name = '曹操' WHERE number = 8;
```

这两个语句都要对`number = 8`的聚簇索引记录和对应的二级索引记录加锁，但是它们的加锁顺序不一样：这个语句会先对聚簇索引记录进行加锁，后对二级索引记录进行加锁。在并发的时候就可能出现这种情况：

* 事务 T1 持有了二级索引记录的锁，事务 T2 持有了聚簇索引记录的锁；
* 事务 T1 需要等待聚簇索引记录上的锁，而事务 T2 也需要等待二级索引记录上的锁。

这种两个事务分别持有一个锁，并且都在等待对方已经持有的那个锁的情况，就是所谓的**死锁**。此时两个事务都无法运行下去，必须选择一个进行回滚，对性能影响比较大。

#### 3.3.2 `SELECT ... FOR UPDATE`语句

比如：

```sql
SELECT * FROM hero WHERE name = 'c曹操' FOR UPDATE;
```

这种情况下与上面的语句加锁情况类似，都是给访问到的二级索引记录和对应的聚簇索引记录依次加锁，不同的是，这个语句加的是 **X 型共享锁**。

#### 3.3.3 `UPDATE ...`语句

与更新二级索引记录的`SELECT ... FOR UPDATE`的加锁情况类似，不过如果被更新的列中还有别的二级索引的话，对应的二级索引记录也会被加锁，且加的都是 **X 型共享锁**。

#### 3.3.4 `DELETE ...`语句

与`SELECT ... FOR UPDATE`的加锁情况类似，不过如果表中还有别的二级索引列的话，对应的二级索引记录也会被加锁。

### 3.4 使用二级索引进行范围查询的锁定读

#### 3.4.1 `SELECT ... LOCK IN SHARE MODE`语句

比如：

```sql
SELECT * FROM hero FORCE INDEX(idx_name) WHERE name >= 'c曹操' LOCK IN SHARE MODE;
```

> 因为优化器会计算使用二级索引进行查询的成本，在成本比较大的时候可能会选择以全表扫描的方式来进行查询，所以这里使用`FORCE INDEX(idx_name)`来强制使用二级索引`idx_name`来执行查询。

这个语句执行过程其实是先到二级索引只能够定位到满足`name >= 'c曹操'`的第一条记录，也就是`name = 'c曹操'`的记录，然后就可以沿着这条记录的链表一路向后找。从二级索引`idx_name`的示意图中可以看出，当前素有的记录都满足`name >= 'c曹操'`这个条件，所以所有的二级索引都会被添加上 **S 型记录锁**。

不过需要注意一下的是加锁顺序：对一条二级索引加锁完后，会接着对它对应的聚簇索引记录加锁，完成后才会对下一条二级索引记录进行加锁。以此类推。

示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/z1YVov-20210130005444.jpg)

再来看下边这个语句：

```sql
SELECT * FROM hero FORCE INDEX(idx_name) WHERE name <= 'c曹操' LOCK IN SHARE MODE;
```

这个语句的加锁情况有点不同：

前面使用`number <= 8`这个条件查询的时候，需要将`number = 15`的记录也加一个锁，然后因为判断其不符合边界条件而把锁释放掉。

而对于查询条件为`name <= 'c曹操'`的语句来说，执行该语句需要使用到二级索引，而与二级索引相关的条件是可以使用**索引条件下推**这个特性的：如果一条记录不符合索引条件下推中的条件的话，直接跳转到下一条记录，这个过程根本不将其返回到 Server 层；如果这已经是范围中的最后一条记录，那么直接向 Server 层报告查询完毕。

但是这里还有一个问题：先对一条记录加了锁，然后再判断该记录是不是符合索引条件下推的条件，如果不符合就直接跳到下一条记录或者直接向 Server 层报告查询完毕，但是这个过程中并没有把那条被加锁的记录上的锁释放掉！！！

本例中使用的查询条件是`name <= 'c曹操'`，在为`name = 'c曹操'`的二级索引记录以及它对应的聚簇索引加锁之后，会接着二级索引中的下一条记录，也就是`name = 'l刘备'`的那条二级索引记录。由于该记录不符合索引条件下推的条件，而且是范围查询的最后一条记录，会直接向 Server 层报告查询完毕，重点是这个过程中并不会释放`name = 'l刘备'`的二级索引记录上的锁，也就导致了语句执行完毕时的加锁情况如下所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/nVcv9r-20210130010411.jpg)

这样就会造成一个尴尬的情况：假如事务 T1 执行了上述语句，并且未提交，在事务 T2 上再执行下面的语句：

```sql
SELECT * FROM hero WHERE name = 'l刘备' FOR UPDATE;
```

此时，事务 T2 中的语句需要获取`name = 'l刘备'`的二级索引记录上的 **X 型记录锁**，但事务 T1 中仍然持有该二级索引记录上的 **S 型记录锁**。这就造成了事务 T2 无法获取到锁而进入等待状态。

> 为啥不能释放不符合索引条件下推中的条件的二级索引记录上的锁呢？并不清楚。使用的 MySQL 版本是5.7.21，不保证其他版本中的加锁情景是否完全一致。

#### 3.4.2 `SELECT ... FOR UPDATE`语句

和`SELECT ... FOR UPDATE`语句类似，只不过加的是 **X 型记录锁**。

#### 3.4.3 `UPDATE ...`语句

比如：

```sql
UPDATE hero SET country = '汉' WHERE name >= 'c曹操';
```

> `FORCE INDEX`只对`SELECT`语句起作用，虽然`UPDATE`语句也支持该语法，但实质上不起作用，`DELETE`语句则根本不支持该语法。

假设该语句执行时使用了`idx_name`二级索引来进行锁定读，那么它的加锁方式和上边所说的`SELECT ... FOR UPDATE`语句一致。如果还有其他的二级索引列也被更新，那么也会为对应的二级索引记录加锁。

不过这里还有一点有趣的地方。比如对于下面的语句：

```sql
UPDATE hero SET country = '汉' WHERE name <= 'c曹操';
```

由于索引条件下推这个特性只适用于`SELECT`语句，也就是说，`UPDATE`语句中无法使用，那么这个语句就会为`name = 'c曹操'`和`name = 'l刘备'`的二级索引记录以及它们对应的聚簇索引记录进行加锁，之后再判断边界条件时发现`name = 'l刘备'`的二级索引记录不符合`name <= 'c曹操'`条件，再把该二级索引记录和对应的聚簇索引记录上的锁释放掉。

这个过程如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/G6ST0z-20210130011436.jpg)

#### 3.4.4 `DELETE ...`语句

比如：

```sql
DELETE FROM hero WHERE name >= 'c曹操';
DELETE FROM hero WHERE name <= 'c曹操';
```

如果这两个语句采用二级索引来进行锁定读，那么它们的加锁情况就和更新带有二级索引列的`UPDATE`语句一致了。

### 3.5 全表扫描情况的锁定读

#### 3.5.1 `SELECT ... LOCK IN SHARE MODE`和`SELECT ... FOR UPDATE`语句
比如：

```sql
SELECT * FROM hero WHERE country = '魏' LOCK IN SHARE MODE;
```

由于 country 列上未建索引，所以只能采用全表扫描的方式来执行这条查询语句。存储引起每读取一条聚簇索引，就会为这条记录加上一个 **S 型记录锁**，然后返回给 Server 层，如果 Server 层判断`country = '魏'`条件成立，则将其发送给客户端，否则会释放掉该记录上的锁。

如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/GLwr5O-20210130011913.jpg)

使用`SELECT ... FOR UPDATE`进行加锁的情况与上边类似，只不过加的是 **X 型记录锁**。

#### 3.5.2 `UPDATE ...`和`DELETE ...`语句

对于这两种语句来说，在遍历聚簇索引中的记录时，都会给该聚簇索引记录加上 **X 型记录锁**，然后：

* 如果该聚簇索引记录不满足条件，直接把该记录上的锁释放掉。
* 如果该聚簇索引记录满足条件，则会对相应的二级索引记录加上 **X 型记录锁**：`DELETE`语句会对所有相应的二级索引记录加锁，而`UPDATE`语句只会为要更新的二级索引列对应的二级索引记录加锁。


