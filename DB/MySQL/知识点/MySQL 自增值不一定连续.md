> 转摘：[MySQL 的自增主键一定是连续的吗？](https://mp.weixin.qq.com/s/qci10h9rJx_COZbHV3aygQ)

自增主键可以让聚簇索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。但 **MySQL 的自增主键并不能保证一定是连续递增的**，主要有如下几种场景会导致自增值不连续：

* 指定自增列的值
* 自增初始值和自增步长不为 1
* 唯一键冲突导致插入失败
* 事务回滚
* 批量插入（非`insert...values (), ()`模式）

### 0. 自增主键的保存位置

MySQL 支持不用的存储引擎，而不同的存储引擎对于自增值的保存策略是不同的：

1. MyISAM 存储引擎的自增值保存在数据文件中，所以其不会丢失；

2. InnoDB 存储引擎的自增值根据版本的不同而有所不同：

    - **MySQL 5.x 版本中，自增值是保存在内存中的**，第一次打开表的时候会自动从表中找到自增值的最大值，并将其加 1 后作为这个表当前的自增值。这也意味着，每次 MySQL 重启后，表的自增值都会被重置为表中当前最大的自增值加 1。
    - **MySQL 8.0 版本后，自增值的变更记录被存放在了 redo log 中**，实现了**自增值持久化**的能力。也就是说，MySQL 重启后，表的自增值并不会被重置为表中当前最大的自增值加 1，而是从 redo log 中恢复为 MySQL 重启前的值。

不同的自增值保存方式会影响 MySQL 重启后自增值的初始化情况。目前仅有 MySQL 5.x 版本的 InnoDB 存储引擎会在重启之后进行自增值的重置。

### 1. 不连续场景一：指定自增列的值

在 MySQL 中，自增列被定义为`AUTO_INCREMENT`，其在插入数据时的行为如下：

* 如果自增列被指定为不是 0、Null 的值，那么自增列的值就使用指定的值；
* 否则，就把这个表当前的 AUTO_INCREAMENT 值作为自增列的值。

而且，根据插入时指定的自增列的值与当前自增值的大小关系，自增值的变化也有所不同：

* 如果指定的值小于当前的自增值，那么这个表的自增值不发生变化；
* 否则，把这个表当前的自增值修改为新的自增值。

所以，如果插入数据的时候，指定的自增列的值大于该表当前的自增值，那么就会造成自增值不连续。

### 2. 不连续场景二：自增步长不为 1

MySQL 自增值的变化是受`auto_increment_offset`和`auto_increment_increment`这两个参数的控制的。这两个参数分别表示自增的初始值和自增步长，默认情况下，它们的值都为 1。

所以，如果将`auto_increment_increment`设置的不为 1，那么在新增数据的时候，也会造成自增值不连续。

一般在分布式部署的时候，为了避免两个库生成的主键发生冲突，可以让一个库的自增 ID 是奇数，另一个库的自增 ID 都是偶数，这就需要修改`auto_increment_offset`和`auto_increment_increment`参数的值了。

另外，对于`auto_increment_increment`不为 1 的情况下，如果插入的自增列的值超过当前自增值，那么自增值将变更为从`auto_increment_offset`开始，累计多次`auto_increment_increment`后第一个大于插入的自增列的值的数字。

比如，如果`auto_increment_offset = 1`，`auto_increment_increment = 3`，当前表的自增值为 91。当插入一个自增列的值为 101 的数据后，该表的自增值将会变为 103。

### 3. 不连续场景三：唯一键冲突

在向表中插入数据的时候，如果表设置了唯一索引（主键也是一种唯一索引），那么还需要检查唯一键是否冲突。如果发生了唯一键冲突，就会造成插入失败。而插入失败也会造成自增列不连续。

比如，对于如下的表，列`a`设置了唯一索引，并写入初始数据`a = 1`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670338374)

然后再向其中插入一条`a = 1`的数据，会因为`a`列值重复而报错`Duplicate entry`：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670338420)

插入失败后，自增值已经从 2 增加到了 3。这跟 MySQL Insert 语句的执行流程有关：

1. 执行器调用 InnoDB 存储引擎接口，准备插入一行记录`(null, 1, 1)`；
2. InnoDB 存储引擎发现用户没有指定自增列 ID 的值，则获取该表当前的自增值，也就是 2 作为 ID 的值；
3. InnoDB 存储引擎将该表的自增值自增为 3；
4. 执行插入数据操作，尝试将`(2, 1, 1)`写入该表中，但是因为已经存在`a = 1`的记录，造成唯一索引冲突，所以报错，取消插入。

可以看到，在这个插入流程中，自增值被修改发生在真实的写入操作之前，而不论后续是否插入成功，自增值都已经发生了自增，不再回退。

因此，当唯一键发生冲突的时候，数据没有插入成功，但是自增值会发生自增，从而导致自增值不连续。

### 4. 不连续场景四：事务回滚

和唯一键冲突时的处理类似，**事务回滚时，自增值并不会发生回滚**。这就会造成，如果回滚了事务，就会造成自增值不连续。

之所以回滚事务的时候不回滚自增值，是为了提高数据库的性能。而如果会回滚自增值，那么就会造成严重的问题。

假设，现在有两个并行执行的事务 A 和 B，他们都需要获取自增值：

1. 申请自增值的时候，为了避免两个事务申请到相同的值，会加锁，然后顺序申请。假设事务 A 申请到了自增值 1，事务 B 申请到了自增值 2，那么这个时候该表的自增值变为了 3；
2. 事务 B 正常提交后，事务 A 因为一些情况发生了回滚，也就是自增值为 1 的那行记录没有插入，而自增值为 2 的记录插入成功了；
3. 如果允许自增值的回滚，那么事务 A 会回滚自增值，也就是把该表的自增值改回为 1 了，那么之后再有数据插入的时候，获取到的自增值，第二条插入的记录的自增列的值就会变为 2，而表中已有自增列为 2 的记录。这就造成问题了，特别是自增列为主键的情况下。

流程图如下所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670339325)

如果要解决回滚造成的问题，有两种方法：

1. 每次申请自增值之前，先判断表里面是否已经存在这个值，如果存在，则跳过这个值；
2. 把自增值的锁定范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增值。

很显然，这两种方法的成本都比较高，会导致性能问题。

因此，在事务回滚的时候，InnoDB 不允许自增值回滚。也正是因为这样，所以才保证了自增值是递增的，但是不保证自增值是连续的。

### 5. 不连续场景五：批量插入数据

MySQL 的批量插入数据可以分为两种形式：

1. 一个 INSERT 语句中提供多个 value 的形式，如`INSERT ... VALUES (...), (...), (...) ...`；
2. 选择一批数据后批量插入，如`INSERT ... SELECT ...`、`REPLACE ... SELECT ...`、`LOAD DATA ...`。

对于第一种类型的批量插入，MySQL 可以精确计算出需要多少个自增值，然后一次性申请，申请完成后自增值的锁就可以释放了。

而对于第二种类型的批量插入，MySQL 并不知道具体需要申请多少自增值，所以会采用下面的批量申请策略，避免一个个申请的低效问题：

1. 语句执行过程中，第一次申请自增值，会分配 1 个值；
2. 1 个自增值用完之后，第二次申请的时候，会分配 2 个值；
3. 2 个自增值用完之后，第三次申请的时候，会分配 4 个值；
4. 依次类推，同一个语句去申请自增值，每次申请到的数量都是上一次的两倍。

因为每次申请都是前一次的两倍，那么就可能会出现最后一次获取的自增值的数量比较多，但是并没有完全用完，从而使得自增值变的不连续了。

比如，现在一个表中有如下这些数据：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670380090)

新建一个和该表有相同结构定义的表：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670380113)

然后使用`insert...select`语法向新表中批量插入数据：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670380143)

此时，再看新表的自增值：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670380177)

可以看到，新表的自增值当前是 8 而不是 6。这是因为，`insert...select`在向新表中写入 5 行数据的过程中，会分三次去申请自增值 ID：

* 第一次申请到了一个自增值：`id = 1`
* 第二次申请到了两个自增值：`id = 2/3`
* 第三次申请到了四个自增值：`id = 4/5/6/7`

而前两次申请的自增值都正常用掉了，但是第三次申请的自增值只用了 4 和 5。虽然 6 和 7 没有被使用，但是该表的自增值依旧是变为 8，而不会把 6 和 7 回收继续使用。

此时如果再向该表中插入一条新的记录，那么其自增列 ID 的值就是 8 了：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670380431)


