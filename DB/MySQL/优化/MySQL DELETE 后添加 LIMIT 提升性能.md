在业务场景要求高的数据库中，对于单条删除和更新操作，在 DELETE 和 UPDATE 后面加`LIMIT 1`绝对是个好习惯。比如，在删除执行中，第一条就命中了删除行，如果 SQL 中有`LIMIT 1`这时就结束了，否则还会执行完全表扫描才结束，效率不言而喻。

在日常执行 UPDATE 时，添加 LIMIT 也是一个好习惯。

> TRUNCATE 和 DELETE 的区别：
> * 如果是清空表数据，建议直接使用 TRUNCATE，效率上远高于 DELETE，因为 TRUNCATE 不会走事务，不会锁表，也不会产生大量日志写入日志文件，执行后立即释放次胖空间，并重置 AUTO_INCREMENT 的值。
> * DELETE 删除时不会释放磁盘空间，后续执行 INSERT 写入的数据会覆盖在之前被删除的数据上。

以下面的 SQL 为例：

```sql
delete from t where sex = 1;
```

1. 降低写错 SQL 的代价：使用 LIMIT 子句后，如果删错了也只会丢失优先的数据，可以很快的使用 binlog 进行恢复。
2. 避免了长事务：DELETE 执行时 MySQL 会将所有涉及的行添加缩写和 Gap 锁，所有 DML 语句执行相关行会被锁住。如果删除量很大，会直接影响相关业务员使其无法使用。
3. DELETE 删除数据量大的时候，不加 LIMIT 容易把 CPU 打满，导致越删越慢。

> 针对上述第二点，前提是 sex 字段添加了索引，因为加锁都是基于索引的。**如果 sex 字段没有索引，就会扫描到主键索引上，此时就算`sex = 1`只有一条记录也是会锁表的。**

对于 DELETE LIMIT 的使用，有如下一道题：

> 如果要删除一个表里面的前 10000 行数据，有以下三种方法可以做到：
> * 第一种，直接执行`delete from T limit 10000;`；
> * 第二种，在一个连接中循环执行 20 次`delete from T limit 500;`；
> * 第三种，在 20 个连接中同时执行`delete from T limit 500;`。

这三种方法的比较如下：

* 方案一：事务相对较长，则占用锁的时间较长，会导致其他客户端等待资源时间较长。
* 方案二：串行化执行，将相对长的事务分成多次相对短的事务，则每次事务占用锁的时间相对较短，其他客户端在等待相应资源的时间也较短。这样的操作，同时也意味着将资源分片使用（每次执行使用不同片段的资源），可以提高并发性。
* 方案三：人为自己制造锁竞争，加剧并发量。 
整体来看，方案二相对比较好，具体还要结合实际业务场景。 
> 转摘：[delete后加 limit，好处多多!](https://mp.weixin.qq.com/s/-gBLqKX-6vFrIvLBoVibBQ)

