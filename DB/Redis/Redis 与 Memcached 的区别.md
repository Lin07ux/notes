Redis 和 Memcached 都是基于内存的缓存 NoSQL 数据库，使用 key-value 形式存储和访问数据，一般都是用于缓存系统，提升系统的响应速度和数据操作效率。但是这两者也有较大的区别。

### 1. 数据支持类型

Memcached 仅支持简单的字符串数据，在内存中维护一张巨大的 HashTable，使得对数据查询的时间复杂度降低到`O(1)`，保证了对数据的高性能访问。

而 Redis 除了简单的字符串值，还支持 List、Set、ZSet、Hash 数据结构。

### 2. 网络 IO 模型

**Memcached 是多线程、非阻塞、IO 复用的网络模型**，分为监听主线程和 worker 子线程。监听线程监听网络连接，接受请求后，将连接描述字 pipe 传递给 worker 线程，进行读写 IO，网络层使用 libevent 封装的事件库。多线程模型可以发挥多核作用，但是引入了 cache coherency 和锁的问题，带来了性能损耗。

**Redis 使用单线程的 IO 复用模型**，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll、kqueue 和 select 事件循环方式。单线程可以将速度优势发挥到最大，但是 Redis 也提供了一些简单的计算功能，比如排序、聚合等，对于这些操作，单线程模型施加会严重影响整体吞吐量，CPU 计算过程中，整个 IO 调度都是被阻塞的。

### 3. 数据存储及持久化

Memcached 不支持内存数据的持久化操作，所有的数据都以 in-memory 的形式存储。

Redis 支持持久化操作，并提供了两种不同的持久化方法来讲数据存储到硬盘里面，一种是快照(snapshotting)，它可以将存在于某一时刻的所有数据都写入硬盘里面。另一种方法叫只追加文件(append-only file，AOF)，它会在执行写命令时，将被执行的写命令复制到硬盘里面。

### 4. 数据一致性问题

Memcached 提供了`cas`命令，可以保证多个并发访问操作同一份数据的一致性问题。

Redis 没有提供`cas`命令，并不能保证这点，不过 Redis 提供了事务的功能，可以保证一串命令的原子性，中间不会被任何操作打断。

### 5. 内存管理机制

传统 C 语言中的`malloc/free`函数是最常用的分配和释放内存的方法，但是这种方法存在着很大的缺陷：

* 首先，对于开发人员来说不匹配的`malloc`和`free`容易造成内存泄露；
* 其次频繁调用会造成大量内存碎片无法回收重新利用，降低内存利用率；
* 最后作为系统调用，其系统开销远远大于一般函数调用。

所以，为了提高内存的管理效率，高效的内存管理方案都不会直接使用`malloc/free`调用。Redis 和 Memcached 均使用了自身设计的内存管理机制，但是实现方法存在很大的差异，下面将会对两者的内存管理机制分别进行介绍。

Memcached 使用预分配的内存池的方式，使用 slab 和大小不同的 chunk 来管理内存，Item 根据大小选择合适的 chunk 存储，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费，并且在内存仍然有很大空间时，新的数据也可能会被剔除。

Redis 使用现场申请内存的方式来存储数据，并且很少使用 free-list 等方式来优化内存分配，会在一定程度上存在内存碎片，但可以减少`malloc/free`调用的频次。Redis 会把带过期时间的数据单独存放在一起，并把它们称为临时数据，非临时数据是永远不会被剔除的，即便物理内存不够，导致 swap 也不会剔除任何非临时数据（但会尝试剔除部分临时数据），这点上 Redis 更适合作为存储而不是 cache。

### 6. 集群管理不同

Memcached 本身并不支持分布式，因此只能在客户端通过像一致性哈希这样的分布式算法来实现 Memcached 的分布式存储：当客户端向 Memcached 集群进行数据的读写前，首先通过内置的分布式算法计算出该条数据的目标节点，然后将命令直接发送到该节点上进行执行。

Redis 虽然也可以采取客户端分布式存储，但更偏向于在服务器端构建分布式存储。最新版本的 Redis 已经支持了分布式存储功能 Redis Cluster：

* Redis Cluster 没有中心节点，具有线性可伸缩的功能。
* Redis Cluster 的节点与节点之间通过二进制协议进行通信，节点与客户端之间通过 ascii 协议进行通信。
* Redis Cluster 将整个 key 的数值域分成 4096 个哈希槽，每个节点上可以存储一个或多个哈希槽，也就是说当前 Redis Cluster 支持的最大节点数就是4096。
* Redis Cluster 使用的分布式算法很简单：`crc16( key ) % HASH_SLOTS_NUMBER`。
* Redis Cluster 为了保证单点故障下的数据可用性，引入了 Master 节点和 Slave 节点。每个 Master 节点都会有对应的两个用于冗余的 Slave 节点。这样在整个集群中，任意两个节点的宕机都不会导致数据的不可用。当 Master 节点退出后，集群会自动选择一个 Slave 节点成为新的 Master 节点。




