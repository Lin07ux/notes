Redis 提供了将数据定期自动持久化至硬盘的能力，包括 RDB 和 AOF 两种方案。两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。

Redis 的数据持久化机制是可以关闭的，如果只把 Redis 作为缓存服务使用，Redis 中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭 Redis 的数据持久化机制。

但通常来说，仍然建议至少开启 RDB 方式的数据持久化，因为：

* RDB 方式的持久化几乎不损耗 Redis 本身的性能。

* Redis 无论因为什么原因 crash 掉之后，重启时能够自动恢复到上一次 RDB 快照中记录的数据。这省去了手工从其他数据源（如 DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快。

## 一、RDB

采用 RDB 持久方式，Redis 会定期保存数据快照至一个 rbd 文件中，并在启动时自动加载 rdb 文件，恢复之前保存的数据。

### 1.1 配置

可以在配置文件中配置 Redis 在`seconds`秒内如果发生了`changes`次数据修改，则进行一次 RDB 快照保存。而且可以配置多条 save 指令，让 Redis 执行多级的快照保存策略。

例如下面的配置会让 Redis 每 60 秒检查一次数据变更情况，如果发生了 100 次或以上的数据变更，则进行 RDB 快照保存：

```conf
save 60 100
```

Redis 默认开启 RDB 快照，默认的 RDB 策略如下：

```conf
save 900 1
save 300 10
save 60 10000
```

也可以通过`BGSAVE`命令手工触发 RDB 快照保存。

### 1.2 优缺点

**RDB 的优点：**

* 对性能影响最小。在进行 RDB 持久化时，Redis 主进程唯一需要做的事情就是 fork 出一个子进程，所有持久化工作都由子进程完成。
* 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。
* 使用 RDB 文件进行数据恢复比使用 AOF 要快很多。

**RDB 的缺点：**

* 快照是定期生成的，所以在 Redis crash 时或多或少会丢失一部分数据。
* 如果数据集非常大且 CPU 不够强（比如单核 CPU），Redis 在 fork 子进程时可能会消耗相对较长的时间（长至 1 秒），影响这期间的客户端请求。

## 二、AOF

Redis AOF(append only file) 持久方式会把每一个*写请求*都记录在一个日志文件里。在 Redis 重启时，会把 AOF 文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。

AOF 的主要作用是解决了数据持久化的实时性，目前已经是 Redis 持久化的主流方式。

### 2.1 配置
 AOF 默认是关闭的，相关配置如下：

```conf
# 开启 AOF
appendonly yes
# 配置文件同步
appendfsync always/everysec/no
# AOF 文件名，默认为 appendonly.aof
appendfilename appendonly.aof
# 设置持久化文件路径
dir /usr/redis/data/aof/
```

AOF 提供的三种文件同步方式的区别如下：

* `appendfsync no`：不进行 fsync，将 flush 文件的时机交给 OS 决定，速度最快；
* `appendfsync always`：每写入一条日志就进行一次 fsync 操作，数据安全性最高，但速度最慢；
* `appendfsync everysec`：折中的做法，交由后台线程每秒 fsync 一次。

### 2.2 重写

随着 AOF 不断地记录写操作日志，必定会出现一些无用的日志。例如某个时间点执行了命令`SET key1 "abc"`，在之后某个时间点又执行了`SET key1 "bcd"`，那么第一条命令很显然是没有用的。

大量的无用日志会让 AOF 文件过大，也会让数据恢复的时间过长。所以 Redis 提供了 AOF rewrite 功能，可以重写 AOF 文件，只保留能够把数据恢复到最新状态的最小写操作集。

AOF rewrite 可以通过`BGREWRITEAOF`命令触发，也可以配置 Redis 定期自动进行：

```conf
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

上面两行配置的含义是：

* Redis 在每次 AOF rewrite 时，会记录完成 rewrite 后的 AOF 日志大小，当 AOF 日志大小在该基础上增长了 100% 后，自动进行 AOF rewrite
* 同时如果增长的大小没有达到 64mb，则不会进行 rewrite。

### 2.3 优缺点

**AOF 的优点：**

* *最安全*，在启用`appendfsync always`时，任何已写入的数据都不会丢失，使用在启用`appendfsync everysec`也至多只会丢失 1 秒的数据。
* AOF 文件在发生断电等问题时也*不会损坏*、*可修复*，即使出现了某条日志只写入了一半的情况，也可以使用 redis-check-aof 工具轻松修复。
* AOF 文件*易读*、*可修改*，在进行了某些错误的数据清除操作后，只要 AOF 文件没有 rewrite，就可以把 AOF 文件备份出来，把错误的命令删除，然后恢复数据。 
AOF 的缺点：

* AOF 文件通常比 RDB 文件更大
* 性能消耗比 RDB 高
* 数据恢复速度比 RDB 慢

## 三、优化

Redis 持久化一直是影响 Redis 性能的高发地，需要从不同层面对其进行优化。

### 3.1 fork

对于高流量的 Redis 实例，OPS 常在数万以上，如果 fork 操作在秒级别，就将会拖慢 Redis 数万条命令的执行，对线上的延迟影响会非常明显。

优化方式如下：

1. 优先使用物理机或高效支持 fork 操作的虚拟化技术，避免使用 Xen。
2. 控制 Redis 实例的最大可用内存，因为 fork 耗时跟内存量成正比，线上建议每个 Redis 实例内存控制在 10GB 以内。
3. 合理配置 Linux 内存分配策略，避免物理内存不足导致 fork 失败。
4. 降低 fork 操作的频率，如适度放宽 AOF 自动触发时机，避免不必要的全量复制等。

### 3.2 cpu

子进程负责把进程内的数据分批写入文件，这个过程属于 CPU 密集操作，通常子进程对单核 CPU 利用率接近 90%。

Redis 是 CPU 密集型服务，不要做绑定单核 CPU 操作。由于子进程非常消耗 CPU，会和父进程产生单核资源竞争。不要和其他 CPU 密集型服务部署在一起，造成 CPU 过度竞争。如果部署多个 Redis 实例，尽量保证同一时刻只有一个子进程执行重写工作。

### 3.3 内存

内存消耗优化：

1. 如果部署多个 Redis 实例，尽量保证同一时刻只有一个子进程在工作。
2. 避免在大量写入时做子进程重写操作，这样将导致父进程维护大量页副本，造成内存消耗。

### 3.4 硬盘

优化方法如下：

1. 不要和其他高硬盘负载的服务部署在一起。如：存储服务、消息队列服务等。
2. AOF 重写时会消耗大量硬盘 IO，可以开启配置`no-appendfsync-on-rewrite`，默认关闭。表示在 AOF 重写期间不做 fsync 操作。
3. 当开启 AOF 功能的 Redis 用于高流量写入场景时，如果使用普通机械磁盘，写入吞吐一般在 100MB/s 左右，这时 Redis 实例的瓶颈主要在 AOF 同步硬盘上。
4. 对于单机配置多个 Redis 实例的情况，可以配置不同实例分盘存储 AOF 文件，分摊硬盘写入压力。

> 注：配置·no-appendfsync-on-rewrite=yes·时，在极端情况下可能丢失整个AOF重写期间的数据，需要根据数据安全性决定是否配置。



