跳跃表(shiplist)是实现 sortset(有序集合)的底层数据结构之一。

> 1. 跳跃列表可以参看这个文章的解释：[漫画算法：什么是跳跃表？](http://blog.jobbole.com/111731/)
> 2. [带你彻底击溃跳表原理及其Golang实现！（内含图解）](https://mp.weixin.qq.com/s/XEIrp1oTsBYDCv3b-m_11g)

### 1. 数据结构

Redis 的跳跃表实现由 zskiplist 和 zskiplistNode 两个结构组成，其中 zskiplist 保存跳跃表的信息(表头，表尾节点，长度)，zskiplistNode 则表示跳跃表的节点。

```c
typeof struct zskiplistNode {
   // 后退指针
   struct zskiplistNode *backward;
   
   // 分值
   double score;
   
   // 成员对象
   robj *obj;
   
   // 层
   struct zskiplistLevel {
           // 前进指针
           struct zskiplistNode *forward;
           // 跨度
           unsigned int span;
   } level[];
} zskiplistNode;
```

zskiplistNode 的对象示例图(带有不同层高的节点)：

![](http://cnd.qiniu.lin07ux.cn/markdown/1558875022579.png)

zskiplist 的结构如下：

```c
typeof struct zskiplist {
   // 表头节点，表尾节点
   struct skiplistNode *header, *tail;
   
   // 表中节点数量
   unsigned long length;
   
   // 表中最大层数
   int level;
} zskiplist;
```

示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1558875230291.png)

### 2. 查询方式

根据上面的示意图可知，每个 zskiplistNode 节点中都包含有分值、元素值和一系列的 Level 数组，而且 zskiplistNode 节点是按照分值排序的。

每个 node 的 level 数组大小都不同，level 数组中的值是指向下一个 node 的指针的跨度值(span)，跨度值是两个节点的 score 的差值。越高层的 level 数组值的跨度值就越大，底层的 level 数组值的跨度值越小。

level 数组就像是不同刻度的尺子。度量长度时，先用大刻度估计范围，再不断地用缩小刻度，进行精确逼近。

当在跳跃表中查询一个元素值时，都先从第一个节点的最顶层的 level 开始。比如说，在上图的跳表中查询 o2 元素时，先从 o1 的节点开始，因为 zskiplist 的 header 指针指向它。

先从其 level[3] 开始查询，发现其跨度是 2，o1 节点的 score 是1.0，所以加起来为 3.0，大于 o2 的 score 值 2.0。所以可以知道 o2 节点在 o1 和 o3 节点之间。这时，就改用小刻度的尺子了。就用 level[1] 的指针，顺利找到 o2 节点。

### 3. 跳表原理

#### 3.1 有序单链表和二分查找法

顾名思义，有序单链表就是节点的排列是有序的链表。如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661429742-e5b8f8ace9e4.jpg)

如果想从中找到一个节点，比如 15，除了从头节点开始遍历，还可以使用二分法来查找，其时间复杂度为`O(logN)`。二分算法通过对比目标数据和中间数据的大小，在每轮查找中直接淘汰一半的数据：

* 中间节点数字为 10（10 或 8 都可以作为中间节点），比目标值 15 小，所以排除 10 之前的 4 个数据，继续在 10~21 中查找；
* 中间节点为 18，比目标值 15 大，排除 18 及之后的 2 条数据，继续在 10~15 中查找；
* 中间节点值为 15，与目标一致，结束查找。

设想在链表中，参考二分算法的思想，为“中间节点”增加索引，就能像二分算法一样进行链表数据的查找了：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661431030-7ebf5dfaccae.jpg)

现在将每一个中间节点抽了出来，组成了另一条链表，即为一级索引。一级索引的每个节点都指向原单链表对应的节点，这样可以通过二分算法来快速查找有序单链表中的节点了。

如果原链表节点数量太多，将会导致一级索引的节点数量也很多，这时需要继续向上建立索引，选取一级索引的中间节点建立二级索引：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661431208-262f615787ee.jpg)

这就是**跳表的本质：对有序链表加多层索引，以空间换时间的策略解决单链表中查询速度的问题，同时也能快速实现范围查询。**

链表节点数少的时候，跳表的提升效果有限，但当链表长度达到 1000 甚至 10000 的时候，从其中查找一个数的效率会得到极大的提升。

#### 3.2 跳表索引的更新

平衡树在极端情况下会退化成一个单链表，所以在每次插入或删除节点时，需要进行相关操作来维持树的平衡性。

跳表具有媲美平衡树的效率，它也同样需要在节点变动的时候进行其他操作来维持索引的均衡分布，否则会出现索引退化聚集的问题。

跳表的索引一般是通过**晋升机制**来实现。在前面的例子中，同一级的每两个节点中会有一个被建立二级索引。也就是说，在同一级，每个节点晋升到上一级索引的概率为 1/2。

如果不严格按照每两个节点中有一个晋升，而且按照每个节点有 1/2 的概率晋升，当节点数量少的时候，可能会有部分索引聚集，当当节点数量足够大的时候，建立的索引也就足够分散了，就越接近严格的每两个节点中有一个晋升的效果。

当然，晋升的概率可以根据需求进行调整，如 1/3 或 1/4。晋升概率稍小时，空间复杂度小，但其查询效率会降低。

#### 3.3 时间复杂度

跳表的时间复杂度为`O(log n)`。

假设跳表的晋升概率为 p，原链表节点数为 n，一级索引节点数为`n * (p ^ 1)`，二级索引节点数为`n * (p ^ 2)`，以此类推，h 级索引节点数应为`n * (p ^ h)`。

最高层的期望节点数应为`1/p`，小于等于这个期望数，则在高一层索引的期望节点数将为 1，没有意义了。

根据上述推算，易得一个跳表的期望索引高度 h 为：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661773096-de660deb83b5.jpg)

加上底层的原始链表，跳表的期望总高度 H 为：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661773115-2cdcc494e7b8.jpg)

加上底层的原始链表，跳表的期望总高度 H 为：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661774051-358db30c63f0.jpg)

查找索引时，运用倒推的四位，从原始链表上的目标节点倒推到顶层索引的起始节点，示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661774083-4da1e65817e4.jpg)

当在底层节点时，只有两种路径可走：向上或向左。向上的概率为 p，向左的概率为 1-p。

假设`C(i)`为一个无限长度的跳表中向上爬 i 层的期望代价（即经过的节点数量），爬到第 0 层时，无需经过任何节点，所以有：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661774225-85b89025f105.jpg)

爬到第 1 层时，可能有两种情况：

* 有 p 的概率是从第 0 层直接爬升到 1 个节点，这种情况经过的节点数为：

    ![](http://cnd.qiniu.lin07ux.cn/markdown/1661775660-351f575cd23a.jpg)

* 有 1-p 的概率是从第 1 层向左移动一个节点，则经过的节点数为：

    ![](http://cnd.qiniu.lin07ux.cn/markdown/1661775685-00ba8ed83baf.jpg)

则有：

![](http://cnd.qiniu.lin07ux.cn/markdown/1661775694-1766949044fe.jpg)

解得：`C(i) = i / p`。

当爬升到期望中的最高层——第 h 层时，则期望部署为 h/p。在第 h 层继续向左走的的期望步数不会超过当前节点期望总和的 1/p，全部加起来，从最底层的目标节点到最顶层的头结点，期望部署为`h/p+2/p`，将上面的 h 的公式带入，忽略常量，时间复杂度为`O(log n)`。

#### 3.4 空间复杂度

空间复杂度基本上就是等比数列之和的计算，比值为 p，所以空间复杂度为`O(n)`


