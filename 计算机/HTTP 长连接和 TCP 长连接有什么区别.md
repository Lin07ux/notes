> 转摘：[字节一面：HTTP 长连接和 TCP 长连接有区别？](https://mp.weixin.qq.com/s/6Az2B2gUJYW7od4cLDqOxg)

### 1. 总结

HTTP 的 Keep-Alive 和 TCP 的 KeepAlive 的区别如下：

* **HTTP 的 Keep-Alive 是由应用层（用户态）实现**的，称为 HTTP 长连接，可以使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，减少 HTTP 短连接带来的开销，其底层需要 TCP 保活；

* **TCP 的 KeepAlive 是由 TCP 层（内核态）实现**的，称为 TCP 保活机制。当客户端和服务端长达一定时间没有进行数据交互时，内核为了验证该链接是否有效，就会发送探测报文，检测对方是否保持着该 TCP 连接，然后决定是否要关闭该连接。

### 2. HTTP 的 Keep-Alive

#### 2.1 HTTP 长连接

HTTP 协议采用的是请求-应答模式，也就是客户端发起了请求，服务端才会返回响应。

由于 HTTP 是基于 TCP 传输协议实现的，客户端与服务器端要进行 HTTP 通信前，需要先建立 TCP 连接，然后客户端发送 HTTP 请求，服务器收到后就返回响应。当请求-应答模式完成之后，就会释放 TCP 连接。

这种“建立 TCP -> 请求资源 -> 响应资源 -> 释放连接”的方式就是 **HTTP 短连接**，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1670071012)

当网页资源比较多的时候，每次 HTTP 请求应答一次就建立并释放一次 TCP 连接，会比较浪费资源，效率也不高。所以 HTTP 就通过 Keep-Alive 实现了让多个 HTTP 请求应答使用同一个 TCP 连接的功能，避免了 TCP 连接的重复建立和释放开销。这种方法称为 **HTTP 长连接**。

![](https://cnd.qiniu.lin07ux.cn/markdown/1670071176)

**HTTP 长连接的特点是：只要任意一端没有明确提出断开连接，则会继续保持 TCP 连接状态。**

在 HTTP 1.1 中 Keep-Alive 是默认开启的，而 HTTP 1.0 中默认是关闭的，如果要浏览器开启 Keep-Alive 则必须在请求的包头中添加：

```
Connection: Keep-Alive
```

当服务器收到请求做出响应的时候，也会在响应头中添加这个响应头。这样这个 HTTP 连接就不会中断，而是保持连接，直到客户端或服务器端提出断开连接。

如果要关闭 Keep-Alive，需要在 HTTP 的请求头中添加如下字段：

```
Connection: close
```

#### 2.2 Keep-Alive Timeout

使用了 HTTP 长连接收，如果客户端完成一次 HTTP 请求后，再无其他请求，那么这个长连接一直保持着就会浪费资源。为了解决这个问题，Web 服务器一般都会提供`keeyalive_timeout`参数，用来指定 HTTP 长连接的超时时间。

也就是说，如果设置了 HTTP 长连接的超时时间为 60 秒，那么 Web 服务器就会给每个长连接启动一个定时器。如果客户端在完成一个 HTTP 请求后，在 60 秒内没有再发起新的请求，定时器的时间一到，就会触发回调函数来释放该连接。

![](https://cnd.qiniu.lin07ux.cn/markdown/1670071638)

#### 2.3 HTTP 流水线

HTTP 长连接不仅仅减少了 TCP 连接资源的开销，而且为 HTTP 流水线技术提供了实现基础。**HTTP 流水线就是指：客户端可以一次性的发送多个请求，发送过程中不需要等待服务器的响应**。HTTP 流水线技术可以减少整体的请求响应时间。

不过，虽然客户端一次性发送多个请求，但是服务器端还是按照客户端请求的顺序逐个进行相应的。而且客户端需要等服务器端响应完第一批发送的请求后，才能再次发出另一批请求。如果服务器响应的过程发生了阻塞，那么客户端就无法发送下一批的请求，此时就造成了**队头阻塞**的问题。

比如，客户端一次性发送了 A、B 两个请求，服务端就会按照先后顺序，先响应 A 请求，然后再响应 B 请求。当 A、B 两个请求的响应都达到客户端后，客户端才能再次发送下一批的请求。

![](https://cnd.qiniu.lin07ux.cn/markdown/1670071960)

### 3. TCP 的 KeepAlive

TCP 的 KeepAlive 其实就是 TCP 的保活机制，应用程序如果想使用 TCP 保活机制，需要通过 Socket 接口设置`SO_KEEPALIVE`选项才能生效。

开启 TCP 的保活机制后，如果两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送一个探测报文，针对这个报文：

* 如果对端程序是正常工作的，对端就会正常的响应这个探测报文，这样 TCP 保活时间就会被重置，等待下一个 TCP 保活时间的到来。
* 如果对端主机崩溃，或者由于其他原因导致探测报文不可达，那么这个探测报文就不会有相关的响应。连续几次达到保活探测次数后，TCP 会报告该 TCP 连接已经死亡，进而内核就会关闭该 TCP 连接。

所以，TCP 保活机制可以在双方没有数据交互的情况下，通过探测报文来确定对方的 TCP 连接是否存活，而且这个机制是在内核中完成的，应用层并不会对此有任何感知。

![](https://cnd.qiniu.lin07ux.cn/markdown/1670072221)



