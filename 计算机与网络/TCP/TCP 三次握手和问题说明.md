### 1. TCP 三次握手建立连接的过程

TCP 是面向连接的协议，所以使用 TCP 前必须先建立连接，而**建立连接是通过三次握手来进行的**。三次握手的过程如下图：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680281708)

具体步骤如下：

0. 一开始，客户端和服务端都处于`CLOSE`状态，先是服务端主动监听某个端口，处于`LISTEN`状态；

1. 客户端随机初始化其发送序列号`client_isn`，将此序号置于 TCP 报文首部的「序号」字段中，同时把`SYN`标志位设置为 1，表示这是一个 SYN 报文。然后客户端将这个报文发送给服务端，表示向服务端发起连接。该报文不包含应用层数据，而且发送该报文之后，客户端就处于`SYN-SENT`状态：

    ![](https://cnd.qiniu.lin07ux.cn/markdown/1680281993)

2. 服务端收到客户端的 SYN 报文后，首先服务端也随机初始化自己的序号`server_isn`，并将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入`client_isn + 1`，接着把 SYN 和 ACK 标志位设置为 1。最后把该报文发送给客户端，该报文也不包含应用层数据，之后服务端处于`SYN-RCVD`状态。

    ![](https://cnd.qiniu.lin07ux.cn/markdown/1680356897)

3. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文：首先将该应答报文的 TCP 首部 ACK 标志位设置为 1，其次「确认应答号」字段填入`server_isn + 1`，最后把报文发送到服务端。这次报文可以携带客户端到服务端的数据，之后客户端处于`ESTABLISHED`状态。

4. 服务端收到客户端的应答报文后，也进入`ESTABLISHED`状态。

从这个过程可以看到：**第三次握手是可以携带数据的，但是前两次握手是不可以携带数据的。**

一旦完成三次握手，双方就都处于`ESTABLISHED`状态，此时连接就已建立完成，客户端和服务端就可以相互发送数据了。

### 2. 在 Linux 系统中如何查看 TCP 状态

在 Linux 系统中，可以通过`netstat -napt`命令查看 TCP 的连接状态：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680357400)

### 3. 为什么是三次握手而不是两次或四次

TCP 连接是用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合包括 Socket、序列号和窗口大小。所以，重要的是为什么三次握手才可以初始化 Socket、序列号和窗口大小并建立 TCP 连接。

TCP 连接需要三次握手的原因主要是以下三个方面：

* 三次握手才可以阻止重复历史连接的初始化（主要原因）
* 三次握手才可以同步双方的初始序列号
* 三次握手才可以避免资源浪费

**原因一：避免历史连接**

RFC 793 指出的 TCP 连接使用三次握手的首要原因：

> The principle rreason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.

简单来说，三次握手的首要原因是为了防止旧的重复连接初始化造成混乱。

考虑一个场景：客户端先发送了 SYN(seq=90) 报文，然后客户端宕机了，而且这个 SYN 报文还被网络阻塞了，服务端并没有收到。接着客户端重启后，又重新向服务端建立连接，发送了 SYN(seq=100) 报文。

> 注意：不是重传 SYN，重传时 SYN 的序列号是一样的。

使用三次握手建立 TCP 连接阻止历史连接的原理如下：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680358169)

客户端连续发送多次 SYN（都是同一个四元组）建立连接的报文，在网络拥堵的情况下：

* 一个「旧 SYN 报文」比「最新的 SYN 报文」早到达服务端，那么此时服务端就会发回`SYN + ACK`报文给客户端，此报文中的确认号是 91（90 + 1）；
* 客户端收到后，发现自己期望收到的确认号应该是 101（100 + 1），而不是 91，于是就会回复 RST 报文来终止连接；
* 服务端收到 RST 报文后，就会释放连接；
* 后续最新的 SYN 报文抵达了服务端后，客户端和服务端就可以正常的完成三次握手了。

上述中的「旧 SYN 报文」称为历史连接，**TCP 使用三次握手建立连接的最主要原因就是防止「历史连接」初始化了连接**。

在上述场景中，如果服务端在收到 RST 报文前先收到了「新 SYN 报文」，也就是服务端收到了客户端报文的顺序是：「旧 SYN 报文」->「新 SYN 报文」，此时会发生什么？

* 当服务端第一次收到 SYN 报文，也就是收到「旧 SYN 报文」时，就会回复`SYN + ACK`报文给客户端，此报文中的确认号是 91（90 + 1）。
* 这时服务端再收到「新 SYN 报文」时，就会回 Challenge Ack 报文给客户端。这个 ACK 报文并不是确认收到「新 SYN 报文」的，而是上一次的 ACK 确认号，也就是 91（90 + 1）。
* 客户端收到此 ACK 报文时，发现自己期望收到的确认号应该是 101，而不是 91，于是就回复 RST 报文。

*两次握手的问题*

如果是两次握手就能建立连接，就无法阻止历史连接。主要是因为**在两次握手的情况下，服务端没有中间状态给客户端来阻止历史连接，导致服务端可能建立一个历史连接，造成资源浪费**。

在两次握手的情况下，服务端在收到 SYN 报文后，就进入了 ESTABLISHED 状态，意味着这时可以给对方发送数据，但是客户端此时还没有进入 ESTABLISHED 状态。假设这次是历史连接，客户端判断到此次连接为历史连接，那么就会回复 RST 报文来断开连接。而服务端在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接。

![](https://cnd.qiniu.lin07ux.cn/markdown/1680364783)

可以看到，如果采用两次握手就建立 TCP 连接的时候，服务端在向客户端发送数据前，并没有阻止掉历史连接，导致服务端建立了一个历史连接，又白白发送了数据，浪费了服务端的资源。

因此，要解决这种现象，最好就是在服务端发送你数据前，也就是建立连接之前就阻止掉历史连接连接，这样就不会造成资源浪费。而要实现这个功能，就需要三次握手来解决。所以，TCP 使用三次握手建立连接的最主要原因是防止「历史连接」初始化了连接。

客户端发送三次握手（ACK 报文）后就可以发送数据了，而被动方此时还是`SYN-RCVD`状态。如果`ACK`丢了，那客户端发送的数据是不是也白白浪费了？

不是的，即使服务端还是在`SYN-RCVD`状态，收到了客户端发送的数据，还是可以建立连接的，并且还可以正常收到这个数据包。这是因为数据报文中是有 ACK 标识位，也有确认号，这个确认号就是确认收到了第二次握手。如下图：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680365476)

所以，服务端收到这个数据报文，是可以正常建立连接的，然后就可以正常接收这个数据包了。

**原因二：同步双方初始序列号**

TCP 协议的通信双方都必须维护一个「序列号」，序列号是可靠传输的一个关键因素，它的作用是：

* 接收方可以使用它去除重复的数据；
* 接收方可以根据数据包的序列号按序接收；
* 可以标识发送出去的数据包中哪些是已经被对方接收到的（通过 ACK 报文中的序列号知道）。

可见，序列号在 TCP 连接中占据着非常重要的作用。所以当客户端发送携带「初始序列号」的 SYN 报文的时候，需要服务端发回一个 ACK 应答报文，表示客户端的 SYN 报文已被服务端成功接收。当服务端发送「初始序列号」给客户端的时候，也需要得到客户端的应答回应。这样一来一回才能保证双方的初始序列号能被对方可靠的接收，完成同步。

![](https://cnd.qiniu.lin07ux.cn/markdown/1680368384)

在确认初始序列号的过程中，需要两个一来一回的过程来进行确认。不过因为服务端在回应客户端的 SYN 报文时候可以将其 SYN 一起发出去，这样就能简化一次握手过程。所以 TCP 连接的建立并不需要四次握手。

而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。

**原因三：避免资源浪费**

如果只有两次握手，当客户端发送的 SYN 报文在网络中阻塞，客户端没有接收到 ACK 报文就会重新发送 SYN。由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 ACK 报文，所以客户端每收到一个 SYN 报文就只能先主动建立一个连接。

这就会造成：客户端因 SYN 报文在网络中的阻塞而重复发送多次 SYN 报文，服务端在收到请求后就会建立多个冗余的无效连接，造成不必要的资源浪费。

![](https://cnd.qiniu.lin07ux.cn/markdown/1680368743)

即：两次握手会造成在消息滞留的情况下，服务端重复接受无用的连接请求 SYN 报文而早晨重复分配资源。

**TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始序列号。**不使用两次或四次握手的原因：

* 两次握手无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
* 四次握手则是没有必要，因为可以将第二次和第三次握手的报文合并为一个报文发出，减少一次通信次数。

### 4. 为什么每次 TCP 连接建立时初始化的序列号都要求不一样

主要原因有两个：

* 防止历史报文被下一个相同四元组的连接接受（主要原因）；
* 为了安全性，防止黑客伪造相同的序列号的 TCP 报文被对方接收。

假设每次建立连接时，客户端和服务端的初始化序列号都是从 0 开始：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680369272)

历史报文会影响相同四元组的连接，过程如下：

* 客户端和服务端建立一个 TCP 连接，客户端发送的数据被网络阻塞，然后超时重传了这个数据包，而此时服务端设备断电重启了。之前与客户端建立的连接就消失了。于是在收到客户端的数据包的时候就会发送 RST 报文断开客户端的连接。
* 紧接着，客户端又重新与服务端建立了与上一个连接相同的四元组的连接；
* 在新连接建立完成后，上一个连接中被网络阻塞的数据包正好抵达了服务端，刚好该数据包的序列号是在服务端的接收窗口中的，所以该数据包就会被服务端正常接收，造成数据错乱。

可以看到，**如果每次建立 TCP 连接时，客户端和服务端的初始化序列号都是一样的，很容易出现历史报文被下一个相同四元组的连接接收的问题**。

如果每次建立连接时客户端和服务端的初始化序列号都不一样，就会大概率的因为历史报文的序列号不在对方的接收窗口，而避免了历史报文被错误接收的问题，如下图：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680369643)

注意：每次建立 TCP 连接时初始化序列号不同只能是在很大概率上避免历史报文被下一个相同四元组的连接接收，并不是完全避免。因为序列号会有回绕的问题，所以需要用时间戳的机制来判断历史报文。

### 5. 初始序列号 ISN 是如何产生的

起始 ISN 是基于时钟产出的，每 4 微秒增加 1，循环一圈需要 4.55 小时。

RFC 793 提到初始序列号 ISN 随机生成算法为：`ISN = M + F(localhost, localport, remotehost, remoteport)`。

* M 是一个计时器，这个计时器每隔 4 微秒增加 1；
* F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证 HASH 算法不能被外部轻易推算得出结果。用 MD5 算法是一个比较好的选择。

可以看到，随机数会基于时钟计时器递增，基本不可能会随机生成一样的初始序列号。

### 6. 第一次握手丢失了会发生什么

当客户端想和服务端建立 TCP 连接的时候，首先第一个发送的就是 SYN 报文，然后客户端就进入了`SYN_SEND`状态。

在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且重传的 SYN 报文的序列号都是一样的。

> 不同版本的操作系统可能超时时间不同，有的 1 秒，有的 3 秒。这个超时时间是写死在内核中的，如果想要更改就需要重新编译内核，比较麻烦。

在 Linux 中，客户端重传 SYN 报文的最大次数由`tcp_syn_retries`内核参数控制，可以自定义这个参数的值，默认一把为 5：

```shell
$ cat /proc/sys/net/ipv4/tcp_syn_retries
5
```

通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒，第四次是在 8 秒，第五次是在 16 秒。也就是说：**每次超时的时间是上一次的 2 倍**。

在第五次重传依旧超时的情况下，会继续等待 32 秒。如果期间服务端仍然没有回应 ACK 报文，客户端就不再重传 SYN 包了，然后会断开这个没有建立起来的 TCP 连接。

所以，SYN 报文重传的总耗时最大为`1+2+4+8+16+32=63秒`，大约为 1 分钟。

例如，假设`tcp_syn_retries`参数值为 3，那么当客户端的 SYN 报文一直在网络中丢失时，会发生下图的过程：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680418918)

具体过程为：

由于`tcp_syn_retries = 3`，当客户端超时重传 3 次 SYN 报文后，已达到最大重试次数，于是不再重新发送 SYN 报文，而是继续等待一段时间（时间为上次超时时间的 2 倍）。如果还是没有收到服务端的第二次握手报文，那么客户端就会断开连接。

### 7. 如果已经建立了 TCP 连接但是客户端突然出现了故障怎么办

客户端出现故障是指客户端的主机发送了宕机或者断电等情况，造成客户端无法正常的对 TCP 连接中的数据进行接收和处理。

此时如果服务端不给客户端发送数，那么服务端将不会感知到客户端发生了故障这件事情，也就是说服务端的 TCP 连接将一直处于`ESTABLISHED`状态，占用着系统资源。

为了避免这个问题，TCP 实现了保活机制，原理如下：

* 定义一个时间段，在这个时间段内如果没有任何连接相关的活动，TCP 保活机制就会开始起作用；
* 每隔一段时间，TCP 保活机制会发送一个探测报文，该探测报文包含的数据非常少；
* 如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。

在 Linux 内核中有对应的参数可以设置保活时间、保活探测的次数、保活探测的时间间隔，以下都是默认值：

* `net.ipv4.tcp_keepalive_time=7200` 表示保活时间为 7200 秒（2 小时）。也就是说，如果 2 小时内没有任何连接相关的活动，就会启动保活机制；
* `net.ipv4.tcp_keepalive_intvl=75` 表示每次检测间隔为 75 秒；
* `net.ipv4.tcp_keepalive_probes=9` 表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。

也就是说，在 Linux 系统中，至少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。

注意：应用程序若想使用哪个 TCP 保活机制需要通过 socket 接口设置`SO_KEEPALIVE`选项才能生效。如果没有设置就无法使用 TCP 保活机制。

如果开启了 TCP 保活，需要考虑以下几种情况：

* 第一种：对端程序是正常工作的。当 TCP 保活的探测报文发送给对端，对端会正常响应，这样 TCP 保活的时间将被重置，等待下一个 TCP 保活时间的到来；
* 第二种：对端主机宕机并重启。当 TCP 保活的探测报文发给对端后，对端是可以响应的，但由于没有该连接的有效信息，会发出一个 RSTT 报文，这样服务端就能发现 TCP 连接已经被重置了；
* 第三种：对端主机宕机或其他原因导致报文不可达。当 TCP 保活的探测报文发送到对端后，无法得到响应，连续几次达到保活探测次数后，TCP 会报告应用层该 TCP 连接已经死亡。

> 进程崩溃，后操作系统在回收进程资源的时候会自动发送 FIN 报文来关闭 TCP 连接。而宕机则是无法感知的，所以需要 TCP 保活机制来探测对方是不是发生了主机宕机。

TCP 保活机制检测的时间有点长，可以在应用层实现一个心跳机制来加快探测。比如，Web 服务软件一般都会提供`keepalive_timeout`参数，用来指定 HTTP 长连接的超时时间。如果设置了 HTTP 长连接的超时时间为 60 秒，Web 服务软件就会启动一个定时器，当客户端在完成一个 HTTP 请求后 60 秒内没有再次发起新的请求，定时器时间一到就会触发回调函数来释放该连接。

![](https://cnd.qiniu.lin07ux.cn/markdown/1680423689)

### 8. 如果已经建立了连接，但是服务端的进程崩溃会发生什么

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 资源，于是内核会启动四次挥手出来来释放 TCP 连接。这个过程由内核自动完成，不需要应用进程的参与。所以即使服务端的进程退出了，也是能与客户端正常关闭连接的。
