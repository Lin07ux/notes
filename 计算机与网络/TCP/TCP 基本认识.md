### 1. 什么是 TCP 协议

TCP 是**面向连接的**、**可靠的**、**基于字节流的**传输层通信协议：

* 面向连接：一定是「一对一」才能连接，不能像 UDP 协议那样可以一个主机同时向多个主机发送消息，也就是无法一对多；
* 可靠：无论网络链路层中出现了怎样的变化，TCP 都可以保证一个报文一定能到达接收端；
* 字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个 TCP 报文，如果接收方不知道「消息的边界」，是无法独处一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，也是不能将其提供给应用层处理的。同时，对「重复」的 TCP 报文会被自动丢弃。

### 2. 为什么需要 TCP 协议

网络层 IP 层是「不可靠」的，不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。如果需要保障网络数据包的可靠性、有序性和完整性，就需要由其上层「传输层」的 TCP 协议来负责。

TCP 是一个工作在**传输层**的**可靠**的数据传输协议，它能保证接收端接收到的网络包是**无损坏**、**无间隔**、**非冗余**和**按序**的。

### 3. 什么是 TCP 连接

RFC 793 中对「连接」的定义如下：

> Connections: The reliability and flow control mechanisms described above require that TCPs initialize and maintain certain status information for each data stream. The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.

简单来说，TCP 连接就是：**用于保证可靠性和流量控制而维护的某些状态信息，这些信息的组合，包括 Socket、序列号和窗口大小，被称为 TCP 连接**。

所以，建立一个 TCP 连接是需要客户端与服务端达成上述三个信息的共识：

* **Socket**：由 IP 地址和端口号组成
* **序列号**：用来解决乱序问题等；
* **窗口大小**：用来做流量控制。

### 4. 如何唯一确定一个 TCP 连接

TCP 四元组可以用来唯一确定一个连接，四元组包含如下信息：

* 源地址
* 源端口
* 目标地址
* 目标端口

源地址和目的地址的字段（32 位）是在 IP 头部中设置，作用是通过 IP 协议发送报文给对方主机；源端口和目的端口的字段（16 位）是在 TCP 头部中设置，作用是告诉 TCP 协议应该把报文发给哪个进程。

由于 TCP 连接是通过四元组来唯一确定的，所以理论上，一个只有单一 IP 地址的服务器，在某个本地端口上监听时，可以建立的最大 TCP 连接数为：`2^32(客户端 IP 数) * 2^16(客户端端口数) = 2^48`。

当然，服务端最大并发的 TCP 连接数远不能达到这个理论上限，其数量会受到以下因素的影响：

* **内存限制**：每个 TCP 连接都要占用一定的内存，操作系统的内存是有限的，无法支撑如此多的 TCP 连接；

* **文件描述符限制**：每个 TCP 连接都是一个文件，如果文件描述符被占满了就会发生`Too many open files`的错误。Linux 对可打开的文件描述符的数量分别做了三个层级的限制：

    - **系统级**：当前系统可打开的最大数量，通过`cat /proc/sys/fs/file-max`查看；
    - **用户级**：单个用户可打开的最大数量，通过`cat /etc/security/limits.conf`查看；
    - **进程级**：单个进程可打开的最大数量，通过`cat /proc/sys/fs/nr_open`查看。

### 5. TCP 头格式有哪些

TCP 头的格式中包含很多内容，如：源端口号、目标端口号、序列号、确认应答号以及一些标识等，其结构如下图所示；

![](https://cnd.qiniu.lin07ux.cn/markdown/1680168740-06bf98eb74bc8429d80c9d9697008b01.png)

其中：

* **序列号**：在建立 TCP 连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端。每发送一次数据，序列号值就累加一次该次「发送数据字节数」的大小。**用来解决网络包乱序问题**。

* **确认应答号**：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答号以后就可以认为在这个序号之前的数据都已经被正常接收了。**用来解决丢包的问题**。

* **控制位**：

    - `ACK`：为 1 时，「确认应答号」的字段变为有效。TCP 规定除了最初建立连接时的 SYN 包之外，该位必须设置为 1；
    - `RST`：为 1 时表示 TCP 连接中出现异常，必须强制断开连接；
    - `SYN`：为 1 时表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定；
    - `FIN`：为 1 时表示今后本端不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换`FIN`位为 1 的 TCP 段。

### 6. TCP 和 UDP 的区别是什么

与 TCP 的各种复杂控制相比，UDP 非常简单，它不提供复杂的控制机制，仅仅是利用 IP 层提供面向「无连接」的通信服务。

UDP 协议的头部只有 8 个字节（64 位），格式如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680276938)

* 目标和源端口号：与 TCP 头部中的目标和源端口功能一样，用于确定应该把报文发给哪个进程；
* 包长度：该字段保存了 UDP 首部和数据的长度之和；
* 校验和：为了提供可靠的 UDP 首部和数据而设计，防止收到在网络传输中受损的 UDP 包。

TCP 和 UDP 的区别在于：

1. *连接*

    * TCP 是面向连接的传输层协议，传输数据前需要先建立连接；
    * UDP 不需要连接，可以立即传输数据。

2. *服务对象*

    * TCP 是一对一的两点服务，即一条连接只有两个端点；
    * UDP 支持一对一、一对多、多对多的交互通信。

3. *可靠性*

    * TCP 保证可靠交付数据，数据可以无差别、不丢失、不重复、按序到达；
    * UDP 尽最大努力交付数据，不保证可靠交付数据。但是可以基于 UDP 传输协议实现一个在应用层保证可靠的传输协议，比如 QUIC 协议。

4. *拥塞控制、流量控制*

    * TCP 有拥塞控制和流量控制机制，保证数据传输的安全性，是一个无私的协议；
    * UDP 没有拥塞控制，即使网络非常拥堵了，也不影响其发送速率。

5. *首部开销*

    * TCP 首部长度较长，会有较大的开销，首部在没有使用「选项」字段时是 20 个字节，如果使用了「选项」字段则会变长；
    * UDP 首部只有 8 个字节，并能去是固定不变的，开销较小。

6. *传输方式*

    * TCP 是流式传输，没有边界，但保证顺序和可靠；
    * UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。

7. *分片不同*

    * TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片；
    * UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完成数据，接着传给传输层。

### 7. TCP 和 UDP 的应用场景

由于 TCP 是面向连接的，能保证数据的可靠性交付，因此经常用于：

* FTP 文件传输；
* HTTP/HTTPS。

由于 UDP 是面向无连接的，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：

* 包总量较少的通信，如 DNS、SNMP 等；
* 视频、音频等多媒体通信；
* 广播通信。

### 8. TCP 和 UDP 可以使用同一个端口吗

**可以**。

一段数据，在数据链路层中，是通过 MAC 地址来寻找局域网中的主机；在网络层中通过 IP 地址来寻找目标主机或路由器；在传输层通过端口号进行寻址，来确定该数据应发送到的应用程序。所以，传输层的 **「端口号」的作用是为了区分同一个主机上不同应用程序的数据包**。

TCP 和 UDP 协议在内核中是两个完全独立的软件模块。当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP 还是 UDP 协议的，进而就能根据协议类别确定将其发送给哪个模块处理。进入到 TCP 和 UDP 模块的报文会再根据其「端口号」确定将数据送给哪个应用程序。

因此，TCP 和 UDP 各自的端口号也是相互独立的，两者同时使用一个端口号并不会发生冲突。

### 9. TCP 为何有首部长度没有包长度，而 UDP 则相反

TCP 的首部总长度在开启选项的时候是不固定的，所以需要增加首部长度字段来记录首部长度，以来区分 TCP 报文中的首部和数据；而 UDP 的首部长度是固定的，所以无需增加首部长度字段。

TCP 报文中负载数据长度的计算公式为：`TCP 数据的长度 = IP 总长度 - IP 首部长度 - TCP 首部长度`。

其中：IP 总长度和 IP 首部长度是在 IP 首部信息中保存的，而 TCP 首部长度则在 TCP 首部中保存，由此就可以计算出 TCP 负载数据的长度。

UDP 也是基于 IP 层进行传输的，按说 UDP 也不需要包长度的，不过有以下两种说法来解释其存在的意义：

* 第一种说法：为了网络设备硬件设计和处理的方便，首部长度需要是 4 字节的整数倍。如果 UDP 首部去掉了「包长度」字段，那 UDP 首部长度就不是 4 字节的整数倍了，所以为了补全 UDP 首部长度是 4 字节的整数倍，才补充了「包长度」字段；
* 第二种说法：如今的 UDP 协议是基于 IP 协议发展的，但最初可能并非如此，依赖的可能是别的不提供自身报文长度或首部长度的网络协议层，因此 UDP 报文首部需要长度字段以供计算。

### 10. TCP Socket 编程

#### 10.1 TCP Socket 编程的流程是什么

![](https://cnd.qiniu.lin07ux.cn/markdown/1680434606)

1. 服务端和客户端初始化 socket，得到文件描述符；
2. 服务端调用`bind`，将 socket 绑定在指定的 IP 地址和端口；
3. 服务端调用`listen`进行监听；
4. 服务端调用`accept`等待客户端连接；
5. 客户端调用`connect`，向服务端的地址和端口发起连接请求；
6. 服务端`accept`返回用于传输的`socket`的文件描述符；
7. 客户端调用`write`写入数据，服务端调用`read`读取数据；
8. 客户端断开连接时，会调用`close`，之后客户端`read`读取数据时就会读到`EOF`。
9. 待处理完数据后，服务端调用`close`，表示连接关闭。

这里需要注意的是：服务端调用`accept`时，连接成功了会返回一个已完成连接的 socket，后续用它来传输数据。所以，监听的 socket 和真正用来传送数据的 socket，是「两个」socket，一个叫做**监听 socket**，一个叫作**已完成连接 socket**。

成功连接建立之后，双方开始通过`read`和`write`函数来读写数据，就像往一个文件流里面写数据一样。

#### 10.2 listen 的时候 backlog 参数的意义是什么

Linux 内核中会维护两个队列：

* 半连接队列（SYN 队列）：接收到一个 SYN 建立连接请求，处于`SYN_RCVD`状态；
* 全连接队列（Accept 队列）：已完成 TCP 三次握手过程，处于`ESTABLISHED`状态。

![](https://cnd.qiniu.lin07ux.cn/markdown/IMG_6453.PNG)

服务器端在监听端口的时候，会使用`listen`系统调用：

```c
int listen (int socketfd, int backlog)
```

其中参数：

* `socketfd`为 Socket 文件描述符；
* `backlog`其作用在历史版本中有一定的变化。

在早起 Linux 内核中，`backlog`是 SYN 队列的大小，也就是未完成的队列大小。在 Linux 2.2 内核之后，`backlog`变成Accept 队列的大小，也就是已完成 TCP 连接建立的队列长度。

所以现在通常认为 **backlog 是 Accept 队列的长度**。Accept 队列长度的**上限值为`somaxconn`的大小**，也就是说，Accept 队列长度为`min(backlog, somaxconn)`。

#### 10.3 Accept 发生在三次握手的哪一步

客户端连接服务器的时候，会先经过 TCP 三次握手连接：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680437109)

* 在客户端在接收到服务端的第二次握手的 SYN + ACK 报文后，会使应用程序从`connect`调用中返回，表示客户端到服务端的单向连接建立成功；
* 当服务端收到客户端的第三次握手的 ACK 报文后，服务端 TCP 连接就进入到`ESTABLISHED`状态，同时服务端协议栈使得`accept`阻塞调用返回。这个时候服务端到客户端的单向连接也建立成功。至此，客户端与服务端两个方向的连接都建立成功。

从上面的描述过程可知，**客户端你 connect 成功返回是在第二次握手，服务端 accept 成功返回是在三次握手成功之后**。

#### 10.4 客户端调用 close 后连接断开的流程是什么

客户端主动调用了`close`后，客户端和服务端之间就会进行四次挥手流程：

![](https://cnd.qiniu.lin07ux.cn/markdown/1680444351)

* 客户端调用`close`表明客户端没有数据需要发送了，此时就会向服务端发送 FIN 报文，进入`FIN_WAIT_1`状态；
* 服务端收到了 FIN 报文，TCP 协议栈会为 FIN 包插入一个文件结束符`EOF`到接收缓冲区中，应用程序可以通过`read`调用来感知这个 FIN 包。这个 **`EOF`会被放在已排队等候的其他已接收的数据之后**，这就意味着服务端需要处理这种异常情况，因为`EOF`表示在该连接上再无额外数据到达。此时，服务端就进入`CLOSE_WAIT`状态。
* 接着，当处理完数据后，自然就会读到`EOF`，于是在处理完数据后，也调用`close`关闭它的套接字，这会使得服务端发出一个 FIN 包，之后处于`LAST_ACK`状态；
* 客户端收到服务端的 FIN 包，并发送 ACK 确认包给服务端，此时客户端将进入`TIME_WAIT`状态；
* 服务端收到 ACK 确认包后，就进入了最后的 CLOSE 状态；
* 客户端经过 2MSL 时间之后也进入 CLOSE 状态。

#### 10.5 没有 accept 能建立 TCP 连接吗

**可以**。

accept 系统调用并不参与 TCP 三次握手过程，它只是负责从 TCP 全连接队列取出一个已经建立连接的 socket，用户层通过 accept 系统调用拿到了已经建立连接的 socket，就可以对该 socket 进行读写操作了。

#### 10.6 没有 listen，能建立 TCP 连接吗

**可以**。

客户端是可以自己连接自己形成连接（**TCP 自连接**），也可以两个客户端同时向对方发出请求建立连接（**TCP 同时打开**）。

这两个情况都有个共同点：**没有服务端参与，没有 listen，就能建立 TCP 连接**。