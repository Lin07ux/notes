> 转摘：[动图图解！既然IP层会分片，为什么TCP层也还要分段？](https://mp.weixin.qq.com/s/kn0YKDBki4sAbSORXqZs4Q)

### 1. 什么是 TCP 分段和 IP 分片

网络就像一根管子，不用地方的管子的粗细也可能不同。

一个数据包想通过管子到另一个地方，就需要经过一个或多个管子。而要经过这一系列的管子，就需要数据包的大小不能够大于这一系列管子中最细的那根管子。

问题来了，数据包过大时怎么办？

答案比较简单：就是把数据包切分成小块。这样数据就可以变小而顺利的进行传输了。

类似下面的分割：

![](http://cnd.qiniu.lin07ux.cn/markdown/1645951099659-14688a7eb548.jpg)

再看网络分层协议，数据先经过传输层，再到网络层。这个分割的行为在传输层和网络层都有可能发生：

* 在传输层（TCP 协议）里，叫做**分段**，分割的最大长度是`MSS`；
* 在网络层（IP 协议）里，叫做**分片**，分割的最大长度是`MTU`。

> 以下提到的 IP 没有特殊说明的情况下，都是指 IPv4。

### 2. MSS

#### 2.1 什么是 MSS

**MSS: Maximum Segment Size**。TCP 提交给 IP 层的最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload。MSS 是 TCP 用来限制应用层最大的发送字节数。

假设 MTU = 1500 byte，那么：MSS = 1500 - 20(IP Header) - 20(TCP Header) = 1460 byte。此时，如果应用层有 2000 byte 要发送，就需要两个数据段才可以完成发送，第一个 TCP 分段为 1460 byte，第二个则为 540 byte。

![](https://cnd.qiniu.lin07ux.cn/markdown/1645951434495-529562ccfb10-MSS-%E5%88%86%E6%AE%B5.gif)

#### 2.2 如何查看 MSS

TCP 建立连接的时候需要三次握手，而 MSS 会在三次握手的过程中传递给对方，用于通知对端，本端最大可以接收的 TCP 报文数据大小（不包含 TCP 和 IP 报文首部）。

![](http://cnd.qiniu.lin07ux.cn/markdown/1645951513681-dcb37a211ab3.jpg)

比如上图中，A 将自己的 MSS 发送给 B，建议 B 在发送数据给 A 的时候，采用`MSS = 1372`进行分段；而 B 在发数据给 A 的时候，同样会带上`MSS = 1420`。两者在对比后，会采用较小的那个值（1372）作为通信的 MSS 值，这个过程叫做 **MSS 协商**。

#### 2.3 协商后 MSS 不会变吗

三次握手中，协商了 MSS 后，就固定不变了吗？

并不是，每次执行 TCP 发送消息的函数时，会重新计算一次 MSS，在进行分段操作。

#### 2.4 协商时不传 MSS 会怎么样

TCP 的报头格式如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1645952061238-f342cbbc94e1.jpg)

其实 MSS 是作为可选项引入的，只不过一般情况下 MSS 都会传。

**如果没有接收到对端 TCP 的 MSS，本端 TCP 默认采用 MSS = 536 byte**。

为什么是 536 呢？因为 IP 层也会进行切片和重组，而 576 byte 则是 IP 层的最小重组缓冲区大小，去除 TCP Header 和 IP Header 之后，数据大小就是 536 byte 了：

```
536(Data) + 20(TCP Header) + 20(IP Header) = 576 byte
```

### 3. MTU

#### 3.1 什么是 MTU

**MTU: Maximum Transmit Unit**，最大传输单元。其实这个是由数据链路层提供的，是为了告诉上层的 IP 层，自己的传输能力是多大。IP 层就会根据它进行数据包企鹅哦按。一般 MTU = 1500 byte。

假设 IP 层有 <= 1500 byte 需要发送，只需要一个 IP 包就可以完成了；如果多余 1500 byte 数据需要发送，需要分片才能完成发送。分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的 IP 包里机上各种信息。比如，这个分片在原来的 IP 包里的偏移 offset。

MTU 分片示意图如下所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1645951434495-529562ccfb10-MTU-%E5%88%86%E7%89%87.gif)

#### 3.2 如何查看 MTU

在 MacOS 中，通过`ifconfig`命令即可查看到 MTU 的值的大小：

```shell
$ ipconfig
lo0: flags=8049<UP,LOOPBACK,RUNNING,MULTICAST> mtu 16384
    ...
en0: flags=8863<UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST> mtu 1500
    ...
p2p0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 2304
    ...
```

可以看到，这里有好几个 MTU，可以简单理解为每个网卡的处理能力不同，所以对应的 MTU 也不同。当然这个值是可以修改的。

在一台机器的应用层到这台机器的网卡这条链路上，基本上可以保证`MSS < MTU`，两者之间的关系如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99f.jpg)

#### 3.3 为什么 MTU 一般是 1500

这其实是由传输效率决定的。

首先，虽然平时使用网络的时候感觉挺稳定的，但这其实是因为 TCP 在背地里做了各种重传等保证了传输的可靠。其实背地里线路是会不时的丢包的。而越大的数据包，发生丢包的概率就越大。

那是不是包越小就越好呢？也不是。

比如，选择一个比较小的长度，`MTU = 300 byte`，那么 TCP 的`payload = 300 - 20(IP Header) - 20(TCP Header) = 260 byte`。此时有效传输效率为`260 / 300 = 86%`。

而 MTU 为 1500 byte 时，有效传输效率就为`1460 / 1500 = 96%`，显然会比`86%`高多了。

所以，包越小越不容易丢包，但是传输效率较低；包越大越容易发生丢包，但是传输效率较高。权衡之下，选择了 1500 byte 作为 MTU 值。

### 4. 为什么 IP 层会分片，TCP 还要分段

由于 IP 层就会做分片这件事，所以就算 TCP 不分段，到了 IP 层，数据包也会被分片，数据也能正常传输。

既然网络层会分片，那 TCP 层未说明还要分段？是不是会有些多此一举？

假设有一份比较大的数据，且在 TCP 层不分段。这份数据在发送的过程中如果出现了丢包现象，TCP 会进行重传，那么重传的就是这一大份数据。虽然 IP 层会把这一大份数据切分为 MTU 长度的 N 个小包，但是 TCP 重传的单位却是这个原始的大数据。

![](https://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99g-tcp-%E4%B8%8D%E5%88%86%E6%AE%B5.gif)

如果 TCO 层对这份数据进行分段，分为 N 个小于等于 MSS 长度的数据包，到了 IP 层后加上 IP 头和 TCP 头，还是小于 MTU，那么 IP 层也不会在进行分包。此时在传输线路上发生了丢包，那么 TCP 重传的时候也就只是重传那一小部分的 MSS 段。这样效率会比 TCP 不分段时更高。

![](https://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99h-tcp-%E5%88%86%E6%AE%B5.gif)

类似的，传输层除了 TCP 外，还有 UDP 协议，但 UDP 本身不会分段，所以当数据量较大时，只能交给 IP 层去分片，然后传到底层进行发送。

也就是说，正常情况下，在一台机器的传输层到忘了层这条链路上，如果传输层对数据进行了分段，那么 IP 层一般就不会在进行分片。如果传输层没有分段，那么 IP 层就可能会进行分片。

说白了，**数据在 TCP 分段，就是为了在 IP 层不需要分片，同时发生重传的时候就只需要重传分段后的小份数据**。

### 5. TCP 分段了，IP 层就一定不会分片了吗

上面提到了，在发送端，TCP 分段后，IP 层一般就不会再分片了。

但是整个传输链路中，可能还会有其他网络层设备，而这些设备的 MTU 可能小于发送端的 MTU。此时虽然数据包在发送端已经分段过了。但是在 IP 层就还会再分片一次。

如果链路上还有设备有更小的 MTU，那么还会再继续分片，最后所有的分片都会在接收端处进行组装。

![](https://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99i-IP-%E5%88%86%E7%89%87%E5%86%8D%E5%88%86%E7%89%87.gif)

因此，就算 TCP 层分段了，在链路上的其它节点的 IP 层也是有可能现在分片的。而且哪怕数据被第一次 IP 分片过了，也是有可能被其他机器的 IP 层进行二次、三次、四次...分片的。

### 6. IP 层怎么做到不分片

上面提到的 IP 层在传输过程中因为各个节点间的 MTU 可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。

那么 IP 层是否可以做到不分片？

如果有办法知道整个链路上最小的 MTU 是多少，并且以最小 MTU 长度发送数据，那么不管数据传到哪个节点，都不会发生分片。

**整个链路上，最小的 MTU 就叫做 PMTU(path MTU)**。有一个获得这个 PMTU 的方法，叫 **Path MTU Discovery**。

操作系统中，可以通过如下命令查看是否开启 PMTU 发现功能：

```shell
$ cat /proc/sys/net/ipv4/ip_no_pmtu_disc
0
```

默认为 0，意思是开启 PMTU 发现功能。现在一般机器上都是开启的状态。

其原理比较简单。

首先看下 IP 的数据报头：

![](http://cnd.qiniu.lin07ux.cn/markdown/1645955145141-e88f46f019d4.jpg)

这里有个标红的标志位`DF`(Don't Fragment)，当它置为 1 时，意味着这个 IP 报文不分片。

当链路上某个路由器接收到了这个报文，而该 IP 报文长度大于路由器的 MTU，路由器就会根据这个 IP 报文的`DF`位进行操作：

* 如果为`0`（允许分片），就会将这个报文进行分片，再传递到下一个路由器；
* 如果为`1`，就会报数据丢弃，同时返回一个 ICMP 包给发送端，并告诉发送端数据不可达，需要分片，而且带上当前机器的 MTU。

理解了上述的原理后，再看下 PMTU 发现是怎么实现的：

1. 应用通过 TCP 正常发送消息，传输层 TCP 分段后，到网络层加上 IP 头，`DF`置为 1，消息再到更底层执行发送；
2. 此时链路上有台路由器由于各种原因导致 MTU 变小了；
3. IP 消息到这台路由器时，路由器发现消息长度大于自己的 MTU，且消息自带的`DF`不让分片，就把消息丢弃，同时返回一个 ICMP 错误给发送端，带上自己的 MTU。

    ![](https://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99j-%E8%8E%B7%E5%BE%97pmtu.gif)

4. 发送端收到这个 ICMP 消息，会更新自己的 MTU，同时记录到一个 PMTU 表中。
5. 因为 TCP 的可靠性，会尝试重传这个数据，同时 IP 层会以这个 MTU 值计算出 MSS 进行分段，此时新的 IP 包就可以顺利被刚才的路由器转发。
6. 如果路径上还有更小的 MTU 的路由器，那上面发送的事情还会再发生一次。

    ![](https://cnd.qiniu.lin07ux.cn/markdown/1645953395468-215c8fd3f99k-pmtu%E5%90%8Etcp%E9%87%8D%E4%BC%A0.gif)

### 7. 总结

* 数据在 TCP 分段，在 IP 层就不需要分片，同时发生重传的时候只重传分段后的小份数据。

* TCP 分段时使用 MSS，IP 分片时使用 MTU；

* MSS 是通过 MTU 计算得到，在三次握手和发送消息的时候都有可能产生变化。

* IP 分片是不得已的行为，尽量不在 IP 层分片，尤其是链路上中间设备的 IP 分片。因为在 IPv6 中已经禁止中间节点设备对 IP 报文进行分片，分片只能在链路的最开头和最末尾两端进行。

* 建立连接后，路径上节点的 MTU 值改变时，可以通过 PMTU 发现更新发送端 MTU 的值。这种情况下，PMTU 发现通过浪费 N 次发送机会来换取的 PMTU，TCP 因为有重传可以保证可靠性，在 UDP 就相当于消息直接丢了。


