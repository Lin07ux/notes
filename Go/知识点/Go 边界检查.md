> 转摘：[这 Go 的边界检查，简直让人抓狂~](https://mp.weixin.qq.com/s/397sL-TCaZrOGR2-s1NFLw)

### 1. 什么是边界检查

边界检查(Bounds Check Elimination)，简称为 BCE。它是 Go 语言中防止数组、切片越界而导致内存不安全的检查手段。如果检查下标已经越界了，就会产生 panic。

边界检查使得代码能够安全的运行，但是也使得代码运行效率略微降低。

比如，下面这段代码，会进行三次的边界检查：

```go
package main

func f(s []int) {
  _ = s[0] // 检查第一次
  _ = s[1] // 检查第二次
  _ = s[2] // 检查第三次
}

func main() {}
```

在编译的时候，使用如下命令即可看到是有三次边界检查的：

```shell
$ go build -gcflags="-d=ssa/check_bce/debug=1" main.go
# command-line-arguments
./main.go:4:7: Found IsInBounds
./main.go:5:7: Found IsInBounds
./main.go:6:7: Found IsInBounds
```

### 2. 边界检查的条件

并不是所有的对数组、切片进行索引操作都需要边界检查。

比如下面这个示例就不需要进行边界检查：

```go
package main

func f() {
  s := []int{1, 2, 3, 4}
  _ = s[:9] // 不需要边界检查
}

func main() {}
```

这是因为编译器根据上下文已经得知，`s`这个切片的长度是多少，终止索引是多少，能立马判断到底有没有越界。所以这里就不再需要进行边界检查了，而是在编译阶段就知道这个地方会不会 panic。

因此可以得出结论：**对于在编译阶段无法判断是否会越界的索引操作才会需要边界检查**。

比如：

```go
package main

func f(s []int) {
  _ = s[:9] // 需要边界检查
}

func main() {}
```

### 3. 边界检查的特殊案例

#### 3.1 案例一

在如下实例代码中，由于在最前面已经检查过索引 2 会不会越界，因此聪明的编译器可以推断出后面的 0 和 1 是否会越界，就不用再进行边界检查了：

```go
package main

func f(s []int) {
  _ = s[2] // 检查一次
  _ = s[1]  // 不会检查
  _ = s[0]  // 不会检查
}

func main() {}
```

#### 3.2 案例二

在下面这个示例中，可以在逻辑上保证不会越界的代码，同样是不会进行越界检查的。

```go
package main

func f(s []int) {
  for index, _ := range s {
    _ = s[index]
    _ = s[:index+1]
    _ = s[index:len(s)]
  }
}

func main() {}
```

#### 3.3 案例三

在下面的示例代码中，虽然切片的长度和容量可以确定，但是索引是通过`rand.Intn()`函数去得到随机值，在编译器看来，这个索引值是不确定的，它有可能大于数组的长度，也有可能小于数组的长度。因此第一次分隔切片需要进行边界检查，而第二次则从逻辑上就能推断出，也就不会再进行边界检查了。

```go
package main

import "math/rand"

func f() {
  s := make([]int, 3, 3)
  index := rand.Intn(3)
  _ = s[:index] // 第一次要检查
  _ = s[index:] // 第二次不需要检查
}

func mian() {}
```

但如果把上面的代码稍微改动一下，让切片的长度和容量变得不一样，那么两次分隔切片就都需要进行检查了：

```go
package main

import "math/rand"

func f() {
  s := make([]int, 3, 5) // 容量大于长度
  index := rand.Intn(3)
  _ = s[:index] // 第一次要检查
  _ = s[index:] // 第二次也要检查
}

func mian() {}
```

因为只有当切片的长度和容量相等时，`:index`成立，才能一定能推出`index:`也成立，这样的话，就只需要做一次检查即可。

一旦数组的长度和容量不相等，那么 index 在编译器看来是有可能大于切片长度的，甚至大于切片的容量。

假设 index 取的的随机值为 4，大于切片的长度且小于切片的容量，此时`s[:index]`虽然可以成功，但是`s[index:]`是要失败的，因此第二次的边界检查是有必要的。

> 虽然`rand.Intn(3)`的最大值只能为 3，但是编译器在编译的时候并不知道 index 的最大值只能取到 3。

小结一下：

1. 当切片的长度和容量相等时，`s[:index]`成立能保证`s[index:]`也成立，因此只需要一次检查即可；
2. 当切片的长度和绒里不相等时，`s[:index]`成立不能保证`s[index:]`也成立，因此需要检查两次。

#### 3.4 案例四

当切片和数组作为参数传递给函数时，编译器在编译的时候无法的纸数组的长度和容量是否相等，因此只能都做检查：

```go
package main

import "math/rand"

func f(s []int, index int) {
  _ = s[:index] // 第一次要做检查
  _ = s[index:] // 第二次也要做检查
}

func main() {}
```

但是如果把两个表达式的顺序反过来，就只要做一次检查就行了，因为`s[index:]`能成立，那么`s[:index]`也必然能成立：

```go
package main

import "math/rand"

func f(s []int, index int) {
  _ = s[index:] // 第一次要做检查
  _ = s[:index] // 第二次不需要做检查
}

func main() {}
```

### 4. 主动消除边界检查

虽然编译器已经非常努力去消除一些应该消除的边界检查，单难免会有一些遗漏。对于那些编译器还未考虑到的场景，但开发者又极力追求程序的运行效率时，可以使用一些小技巧给出一些暗示，告诉编译器哪些地方可以不用做边界检查。

比如下面这个示例，从代码的逻辑上来说，是完全没有必要做边界检查的，但是编译器并没有那么智能，实际上每个 for 循环都会做一次边界检查：

```go
package main

func f(is []int, bs []byte) {
  if len(is) >= 256 {
    for _, n := range bs {
      _ = is[n] // 每个循环都要做边界检查
    }
  }
}

func main() {}
```

这时可以试着在 for 循环前加上这么一句`is = is[:256]`来告诉编译器新 is 的长度为 256，最大索引值为 255，达到了 byte 的最大值，因此`is[n]`从逻辑上来说是一定不会越界的：

```go
package main

func f(is []int, bs []byte) {
  if len(is) >= 256 {
    is = is[:256]
    // 或者
    // _ = is[255]
    for _, n := range bs {
      _ = is[n] // 每个循环都要做边界检查
    }
  }
}

func main() {}
```

### 6. 结语

上面列出的例子并没有涵盖标准编译器支持的所有边界检查消除的情形，本文列出的仅仅是一些常见的情形。

尽管标准编译器中的边界检查消除特性依然不是 100%完美，但对很多场景的情形确实很有效。

自从标准编译器支持此特性以来，在每个版本更新中，此特性都在不断的改进增强。在以后的版本中，标准编译器会变得更加智能，以至于上面最后一个例子中提供给编译器的暗示有可能将变得不再必要。

参考文档：[边界检查消除](https://gfw.go101.org/article/bounds-check-elimination.html)

