> 转摘：[【修正版】动图图解！GMP模型里为什么要有P？背后的原因让人暖心](https://mp.weixin.qq.com/s/SEE2TUeZQZ7W1BKkmnelAA)

### 1. GM 模型

在 Go 1.1 版本之前，其实用的就是 GM 模型：

* `G` 协程，在代码里用`go`关键字执行一个方法就等于起了一个`G`；
* `M` 内核线程，操作系统内核其实看不见`G`（也看不见`P`），只知道自己在执行一个线程。`G`和`P`都是在用户层上的实现。

![GM 图](http://cnd.qiniu.lin07ux.cn/markdown/1646051415926-aad73f631c86.jpg)

除了`G`和`M`以外，还有一个**全局协程队列**，这个全局队列里放的是多个处于**可运行状态**的`G`。`M`如果要想获取`G`，就需要访问这个全局队列。同时，内核线程`M`是可以同时存在多个的，因此访问的时候就需要考虑并发安全问题。因此这个全局队列就有一个全局的大锁，每次访问都需要去获取这把大锁。

并发量小的时候还好，当并发量大了，这把大锁就成了性能瓶颈。

![GM 模型](https://cnd.qiniu.lin07ux.cn/markdown/16460517683097-bcd931b2d1c1e82b97f38c551c7b9cab.gif)

### 2. GMP 模型

基于*没有什么是加一个中间层不能解决的*思路，Go 在原有的`GM`模型的基础上加了一个调度器`P`，可以简单理解为是在`G`和`M`中间加了个中间层。

![GMP 图](http://cnd.qiniu.lin07ux.cn/markdown/1646051998124-08abc962ab23.jpg)

于是就有了现在的`GMP`模型：

* `P`加入后，还带来了一个**本地协程队列**，它跟前面提到的**全局协程队列**类似，也是用于存放`G`。想要获取等待运行的`G`，会优先从本地队列里拿，而且访问本地队列无需加锁。而全局协程队列依然是存在的，但是功能被弱化，不到万不得已是不会去全局队列里拿`G`的；

* `GM`模型里的`M`想要运行`G`，直接去全局队列里拿就行了；`GMP`模型里的`M`想要运行`G`，就得先获取`P`，然后从`P`的本地队列获取`G`。

    ![GMP 模型](https://cnd.qiniu.lin07ux.cn/markdown/16460517683097-84e5f37fdebcdb618e6ceaa2ebbaf7b4.gif)

* 新建`G`时，新`G`会优先加入到`P`的本地队列；如果本地队列满了，则会把本地队列中的一半的`G`移动到全局队列。

* `P`的本地队列为空时，就从全局队列里去取。

    ![GMP 模型-获取全局协程队列](https://cnd.qiniu.lin07ux.cn/markdown/16460517683097-fc715501702928a7b62d4d0053ab8e60.gif)

* 如果全局队列为空时，`M`会从其他`P`的本地队列**偷(stealing)**一半的`G`放到自己的`P`的本地队列。

    ![GMP 模型-stealing](https://cnd.qiniu.lin07ux.cn/markdown/16460517683097-02e3e04e1fb12def852e5e0e7c018123.gif)

* `M`运行`G`，`G`执行之后，`M`会从`P`获取下一个`G`，不断重复下去。

    ![GMP 模型-循环执行](https://cnd.qiniu.lin07ux.cn/markdown/16460517683097-d9f31d9a58bb76db5d04b80167f89b77.gif)

### 3. 为什么 P 的功能不直接加在 M 上

主要还是因为`M`其实是内核线程，内核只知道自己在跑线程，而 Go 的运行时（包括调度、垃圾回收等）其实都是用户空间里的逻辑。操作系统不知道、也不需要知道用户空间的 Go 应用有什么逻辑，这一切都交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适。

