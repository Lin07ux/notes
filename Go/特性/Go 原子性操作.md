> 转摘：[Go 五种原子性操作的用法详解](https://mp.weixin.qq.com/s/gLmOz7F_2t5IYtdus5xBRQ)

原子性：

> 一个或多个操作在 CPU 执行的过程中不被中断的特性，称为**原子性(Atomicity)**。这些操作对外表现成一个不可分割的整体，他们要么都被执行，要么都不执行，外界不会看到他们只执行到一半的状态。

CPU 执行一系列的操作时不可能不发生中断，但是如果在执行多个操作时，能让他们的中间状态对外界不可见，那就可以宣称他们拥有了“不可分割”的原子性。类似的解释在数据库事务的 ACID 概念里也有。

### 1. Go 中的原子操作

Go 标准包`sync/atomic`提供了对原子操作的支持，其提供的原子操作有如下几大类：

* **增减**：保证对操作数进行原子的增加，操作方法名格式为`AddXXXType`，其中`XXX`表示支持的类型，包括：`int32`、`int64`、`uint32`、`uint64`、`uintptr`。
* **载入**：保证读取到操作数前没有其他任务对它进行变更，操作方法名格式为`LoadXXXType`，其中`XXX`表示支持的类型，包括：基础类型数据、`Pointer`（也就是支持载入任何类型的指针）。
* **存储**：保证存储数据前没有其他任务对它进行变更，操作方法名格式为`StoreXXXType`，其中`XXX`表示支持的类型，与**载入**操作支持的类型一样。
* **比较并交换**：也就是`CAS`(Compare And Swap)。Go 的很多并发原语实现就是依赖的 CAS 操作，同样是支持上面列的那些类型。
* **交换**：不比价直接交换，较少使用。

### 2. 互斥锁 与 原子操作 的区别

Go 标准包`sync`中的`Mutex`是经常用来表征并发安全的，在

