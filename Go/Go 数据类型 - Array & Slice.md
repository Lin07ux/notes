数组可以以特定的顺序在变量中存储相同类型的多个元素。切片与数组类似，只是其长度不会保存在类型中。

### 1. 长度

数组的长度是在声明时就确定的固定值。可以通过显示声明长度，也可以由 Go 自动推断长度：

* `[N]type{value1, value2, ..., valueN}` 声明长度
* `[...]type{value1, value2, ..., valueN}` 自动推断

比如：

```go
numbers := [5]int{1, 2, 3, 4, 5}
numbers := [...]int{1, 2, 3, 4, 5}
```

切片的声明无需设置任何长度信息：

```go
numbers := []int
names   := []string
```

切片也是有容量概念的。比如，一个容量为 2 的切片`mySlice`，使用`mySlice[10] = 1`进行赋值，会出现运行时错误。但是可以使用`append()`函数在原有的切片后追加一个元素，并返回扩容后的新切片。

### 2. 类型

**数组的大小也属于类型的一部分**。如果尝试将`[4]int`类型的变量作为`[5]int`类型的参数传入函数，是不能通过编译的，因为他们是不同的类型，就像尝试将`string`当做`int`类型的参数传入函数一样。

比如，对于下面的函数：

```go
func Sum(numbers [5]int) (sum int) {
    for _, number := range numbers {
        sum += number
    }
    return
}
```

如果调用这个函数的时候，尝试将`[4]int`类型的数组作为参数传入，是不能通过编译的。

而**切片类型不会将集合的长度保存在类型中**，也就是说切片的类型只与其元素类型相关，与长度无关。

因为这个原因，所以数组比较笨重，大多数情况下都不会使用它，而是使用切片类型来替代。

### 3. 循环

在迭代数组和切片时，可以使用`array[index]`语法来访问指定索引对应的值；也可以使用`range`语法来迭代数组和切片中的每一个值，每次迭代都会返回数组元素的索引和值。

> 如果不需要使用索引，可以使用`_`空白标识符来忽略索引。

```go
for _, number := range numbers {
    //
}
```

### 部分切片

切片支持部分切割得到新的切片的操作。

语法：`slice[low:high]`。

如果冒号的某一侧没有数字，就会一直取到该侧最边缘的元素位置。比如，`numbers[2:]`表示从索引 1 的元素开始到最后一个元素都被获取。

如果对空切片进行分切，会出现运行时错误。

