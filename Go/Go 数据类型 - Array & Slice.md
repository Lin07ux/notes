## 一、基础

数组可以以特定的顺序在变量中存储相同类型的多个元素。切片与数组类似，只是其长度不会保存在类型中，且底层由一个数组来保存数据。

一个 Slice 由三部分组成：指针、长度和容量：

* 指针指向第一个 Slice 元素对应的底层数组元素的地址。要注意的是：Slice 的第一个元素并不一定就是底层数组的第一个元素。
* 长度对应 Slice 中元素的数目，且长度不能超过其容量。超出长度意味着扩展了 Slice。
* 容量一般是从 Slice 的开始位置到底层数据的结尾位置。切片操作如果超出了容量上限将导致一个 panic 异常。

多个 Slice 可以共享底层的数据（数组），并且引用的数组部分区间可能相互重叠。也因此，修改 Slice 的元素时，可能会造成其他的 Slice 的元素值也发生变化。同时，由于 Slice 指向实际数据的是一个指针，所以复制一个 Slice 只是对底层的数组创建了一个新的 Slice 别名。

### 1.1 长度

数组的长度是在声明时就确定的固定值。可以通过显示声明长度，也可以由 Go 自动推断长度：

* `[N]int` 声明长度，但不初始化
* `[N]type{value1, value2, ..., valueN}` 声明长度并且初始化
* `[...]type{value1, value2, ..., valueN}` 自动推断且初始化

比如：

```go
var a [3]int
numbers := [5]int{1, 2, 3, 4, 5}
numbers := [...]int{1, 2, 3, 4, 5}
```

切片的声明无需设置任何长度信息：

```go
numbers := []int
months   := []string{"January", /*...*/, "December"}
```

切片也是有容量概念的。比如，一个容量为 2 的切片`mySlice`，使用`mySlice[10] = 1`进行赋值，会出现运行时错误。但是可以使用`append()`函数在原有的切片后追加一个元素，并返回扩容后的新切片。

数组和切片的长度都可以使用`len()`函数来得到。切片的容量可以使用`cap()`函数来获取。

### 1.2 类型

**数组的大小也属于类型的一部分**。如果尝试将`[4]int`类型的变量作为`[5]int`类型的参数传入函数，是不能通过编译的，因为他们是不同的类型，就像尝试将`string`当做`int`类型的参数传入函数一样。

比如，对于下面的函数：

```go
func Sum(numbers [5]int) (sum int) {
    for _, number := range numbers {
        sum += number
    }
    return
}
```

如果调用这个函数的时候，尝试将`[4]int`类型的数组作为参数传入，是不能通过编译的。

而**切片类型不会将集合的长度保存在类型中**，也就是说切片的类型只与其元素类型相关，与长度无关。

因为这个原因，所以数组比较笨重，大多数情况下都不会使用它，而是使用切片类型来替代。

### 1.3 初始化

数组和 Slice 都可以采用顺序初始化，也可以使用指定索引和值列表的方式进行初始化，或者使用两种风格的混合语法初始化。如下：

```go
type Currency int

const (
  USD Currency = iota // 美元
  EUR                 // 欧元
  GBP                 // 英镑
  RMB                 // 人民币
)

symbols := [...]string{RMB: "￥", USD: "$", GBP: "￡", EUR: "€"}
fmt.Println(RMB, symbols[RMB])  // "3 ￥"
```

这种形式声明时，初始化索引的顺序是无关紧要的，而且没用到的索引是可以省略的（将使用零值初始化未置顶的索引的值）：

```go
r := [...]int{99: -1}
```

这里定义了一个含有 100 个元素的数组`r`，最后一个元素被初始化为`-1`，其他元素都是用`0`初始化的。

### 1.4 循环

在迭代数组和切片时，可以使用`array[index]`语法来访问指定索引对应的值；也可以使用`range`语法来迭代数组和切片中的每一个值，每次迭代都会返回数组元素的索引和值。

> 如果不需要使用索引，可以使用`_`空白标识符来忽略索引。

```go
for _, number := range numbers {
    //
}
```

### 1.5 比较

如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，可以直接通过`==`和`!=`比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的，否则它们就必然是不等的。

> 类型（包含长度）不同的数组是不可相互比较的。

```go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // true false false

d := [3]int{1, 2}
fmt.Println(a == d) // compile error: cannot compare [2]int == [3]int
```

但是两个 Slice 是无法直接进行比较的，因此不能直接使用`==`和`!=`来比较两个 Slice。标准库提供了高度优化的`bytes.Equal()`函数来判断两个字节型 Slice(`[]byte`) 是否相等，但是对于其他类型的 Slice 则需要自行实现比较，如下：

```Go
func Equal(x, y []string) bool {
  if len(x) != len(y) {
    return false
  }
  
  for i := range x {
    if x[i] != y[i] {
      return false
    }
  }
  
  return true
}
```

Slice 之间不直接支持比较运算符是因为：

1. 一个 Slice 的元素是间接引用的，甚至可以包含其自身，虽然有很多办法处理这种情况，但是没有一个是简单有效的。
2. 因为 Slice 的元素是间接引用的，一个固定的 Slice（指 Slice 本身而非元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改。

> Slice 唯一合法的比较操作是和`nil`比较：`if summer == nil { /* ... */ }`。

### 1.6 传参

数组作为函数参数时也是按值传递的，也就是会被赋值一份，并将副本传入函数作为参数，而且函数内对数组的修改也不会反映到外部的数组中。

由于数组类型包含了僵化的长度信息，而且没有任何添加或删除数组元素的方法，所以除了像 SHA256 这类需要处理特定大小数组的特例外，数组很少会用作函数参数；相反，一般会使用 Slice 来替代数组。

### 1.7 零值

一个零值的 Slice 等于`nil`：一个`nil`值的 Slice 并没有底层数组，且其长度和容量都是 0。但是也有非`nil`值的 Slice 的长度和绒里也是 0 的情况，如：`[]int{}`、`make([]string, 3)`。

与任意类型的`nil`值一样，可以用`[]int(nil)`类型转换表达式来生成一个对应类型 Slice 的`nil`值：

```go
var s []int    // len(s) == 0, s == nil
s = nil        // len(s) == 0, s == nil
s = []int(nil) // len(s) == 0, s == nil
s = []int{}    // len(s) == 0, s != nil
```

如果需要测试一个 Slice 是否为空，应该使用`len(s) == 0`来判断，而非`s == nil`来判断。

除了与`nil`相等比较的结果外，一个`nil`值的 Slice 的行为和其他任意 0 长度的 Slice 一样，除了文档已经明确说明的地方，所有的 Go 语言函数应该以相同的方式对待两者。

## 二、高级

### 2.1 部分切片

切片支持部分切割得到新的切片的操作。

语法：`slice[low:high]`。

如果冒号的某一侧没有数字，就会一直取到该侧最边缘的元素位置。比如，`numbers[2:]`表示从索引 1 的元素开始到最后一个元素都被获取。

如果对空切片进行分切，会出现运行时错误。

