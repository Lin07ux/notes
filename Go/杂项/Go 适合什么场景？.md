> [Go 适合 IO 密集型？并不准确！](https://mp.weixin.qq.com/s/0nwe-YrMGrl2futS5wkT6A)

## 一、Go 的适用场景

### 1.1 Go 程序适合什么样的场景？

计算机程序场景分为 CPU 密集型和 IO 密集型：

* CPU 密集型是一直在运算 CPU 指令，常见于算法运行；
* IO 密集型是经常下发 IO，比如网卡、磁盘或者其他外设。

Go 程序适合 IO 密集型的场景，更准确的说是：**Go 适合的是网络 IO 密集型的场景**，而非磁盘 IO 密集型场景。甚至可以说，**Go 对于磁盘 IO 密集型并不友好**。

### 1.2 网络 IO 和磁盘 IO 的区别

Go 对于网络 IO 和磁盘 IO 会有差别，根本原因在于**网络 socket 句柄和文件句柄的不同**。网络 IO 能够用异步化的事件驱动的方式来管理，磁盘 IO 则不行。

Socket 句柄可读可写事件都有意义：

* socket buffer 里有数据，说明对端网络发数据过来了，既满足可读事件；
* 有 buffer 可写，说明还能发送数据，满足可写事件。

所以 socket 的句柄实现了`.poll`方法，可以用 epoll 池来管理。

文件句柄可读可写事件则没有意义，因为文件句柄理论上是永远都是可读可写的，不会阻塞调用。所以文件的`.poll`一般是不实现的，自然也用不了 epoll 池来管理。

能否用 epoll 池来管理 fd 则决定了能否在 Go 里用 epoll 池 IO 复用的形式来实现 IO 并发：

* Socket 句柄可以设置为 nonblocking（非阻塞方式），这样当网络 IO 还未就绪的时候就可以在 Go 代码里把调度权切走，去执行其他协程，这样就实现了网络 IO 的并发。
* 磁盘 IO 的 read/write 都是同步的 IO，没有实现`.poll`，无法使用 epoll 池来监控读写事件，所以磁盘 IO 的完成只能同步等待。

而且，**磁盘 IO 的等待会带来 Go 最不能容忍的事情：卡线程。**

## 二、Go 的 read/write 系统调用

### 2.1 Go 卡线程的影响

Go 的代码执行者是系统线程，也就是 GMP 模型中的 M。M 不断的从队列 P 中取 G（协程任务）来执行。当 G 出现事件等待的时候（比如网络 IO），就会被立即切走，取下一个 G 来执行。这样就让 M 一直不停的满载运行，保证 Go 协程任务的高吞吐。

如果某个 G 卡线程了，就相当于这个 M 被废了，吞吐能力就下降了。如果 M 全卡住了，就相当于整个程序卡死了。这是 Go 绝对无法容忍的。

然而，对于类似系统调用这种卡线程的情况是无法人为控制的。Go runtime 为了解决这个问题，就只能创建更多的线程来把保证一直有可运行的 M。

所以，当系统调用很慢的时候，M 的数量就会变多，甚至会暴涨。在磁盘大量随机读，并且压力过载的情况，Go 程序线程数持续上涨，最终超过 1 万个而被 panic 了。

### 2.2 Go 的 read/write 系统调用

当文件句柄 read/write 的时候，走系统调用时，前后会包装两个函数：`entersyscall`、`exitsyscall`：

```go
entersyscall

// 系统调用 read/write 

exitssyscall
```

这两个调用都是为了和 Go runtime 的调度逻辑做交互，协商解决卡线程问题：

* `entersyscall`的作用：把当前 M 的 P 设置为`_Psyscall`状态，打上标识，解除 P -> M 的绑定，但是保留 M -> P 的绑定。

* `exitsyscall`的作用：由于 M 到 P 的指向还在，那么优先还是用原来的 P；如果原来的 P 被处理掉了，就会用一个新的 P；如果没有可用的 P，就把当前 M 上的 G 挂到全局队列上。

所以，这里最重要的就是一个状态的标记。Go 的 sysmon（内部监控线程）发现有这种卡了超过 10ms 的 M，就会把 P 剥离出来，给到其他的 M 去处理执行，M 数量不够就会创建一个新的 M。

系统调用的路基是属于 Go 程序外部代码，Go 用`entersyscall`和`exitsyscall`来包装一下，主要就是和调度做交互。cgo 也是外部代码，也是使用这种方式来配合调度的。

## 三、总结

* Go 准确的说是适合**网络 IO 密集型**的场景；
* **磁盘 IO 密集型可能会导致系统线程增多**，甚至暴涨，乃至超过 1 万个导致程序被 panic；
* 系统调用的逻辑是属于 Go 程序**外部代码逻辑**，Go 使用`entersyscall`和`exitsyscall`来包装一下，主要是和调度交互。

