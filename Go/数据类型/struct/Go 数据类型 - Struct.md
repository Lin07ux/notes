> 转摘：
> 
> * [空结构体引发的大型打脸现场](https://mp.weixin.qq.com/s/o9E4Ry1Ui-VPyz41KPJvlw)
> * [用 Go struct 不能犯的一个低级错误！](https://mp.weixin.qq.com/s/QnMOwYUANdydbiM8yGznHA)

## 一、基础

## 二、高级

### 2.1 结构体比较

如果结构体的全部成员都是可以比较的，那么结构体也是可以比较的，此时可以使用`==`或`!=`运算符对两个机构体进行比较。这会对两个结构体的每个成员都进行比较：如果每个成员都相等，则这两个结构体相等；否则他们不相等。

```go
type Point struct { X, Y int }

p := Point{1, 2}
q := Point{2, 1}

// 下面两个判断是等价的
fmt.Println(p.X == q.X && p.Y == q.Y) // false
fmt.Println(p == q)                   // false
```

和其他可比较类型一样，可比较的结构体类型也可以用于 map 的 key 类型：

```go
type Address struct {
  port int
  host string
}

hits := make(map[Address]int)
hits[address{443, "golang.org"}]++
```

### 2.2 结构体嵌入和匿名成员

一个结构体中可以包含另一个结构体作为其子成员，这就是结构体的嵌入。结构体可以嵌入任意的其他结构体类型，甚至是它自身的结构体类型。

比如，下面定义的是一些简单的几何形状：

```go
type Point struct {
  X, Y int
}

type Circle struct {
  Center Point
  Radius int
}

type Wheel struct {
  Circle Circle
  Spokes int
}
```

结构体的嵌入会使其定义更加清晰明了，但是也会造成成员的访问较为繁琐：

```go
var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
```

Go 语言有一个特性：**只声明一个成员对应的数据类型而不指定成员的名称**，这类成员就叫做**匿名成员**。匿名成员的数据类型必须是命名的类型或指向一个命名类型的指针。得益于**匿名嵌入**的特性，**可以直接访问叶子属性而不需要给出完整的属性路径**。这样就能简化嵌套类型属性的访问：

```go
type Circle struct {
  Point
  Radius int
}

type Wheel struct {
  Circle
  Spokes int
}

var w Wheel
w.X = 8       // equivalent to w.Circle.Point.X = 8
w.Y = 8       // equivalent to w.Circle.Center.Y = 8
w.Radius = 5  // equivalent to w.Circle.Radius = 5
w.Spokes = 20
```

匿名成员也有一个隐式的名称，就是其所属命名类型的名称，所以子结构体属性的完整访问路径依然有效。

但是结构体字面值并没有简短表示匿名成员的语法，因此下面的语句都不能编译通过：

```go
w = Wheel{8, 8, 5, 20} // compile error: unknown fields
w = Wheel{X: 8, Y: 8, Radius: 5, Spokes: 20} // compile error: unknown fields
```

实际上，**嵌入匿名成员的方式**，不仅仅是**获得了匿名成员类型的所有属性**，而且**也获得了该类型导出的全部方法**。这个机制可以用于将一些有简单行为的对象**组合成有复杂行为的对象**。

匿名成员还有如下特性：

1. 因为匿名成员其实也有名称，因此不能同时包含两个类型相同的匿名成员，这会导致命名冲突。
2. 同时，因为成员的名字是由其类型隐式地决定的，所以匿名成员也有可见性的规则约束。
3. 即便匿名成员的类型不是导出的（导致匿名成员的隐式名称也不是导出的，比如改成小写字母开头的`point`和`circle`），依然可以用间断性是访问匿名成员嵌套的成员。但是**在包外则不可访问（无论是全路径还是简短语法）**。
4. 匿名成员简短访问的特性只是对访问嵌套成员的点运算符提供了简短的语法糖。
5. 匿名成员并不要求必须是结构体类型，其他任何命名的类型都可以作为结构体的匿名成员。

## 三、特性

### 3.1 空结构体地址

空结构体不占用内存，其`size`值为 0。

**在堆内存分配时，`size = 0`的对象统一会返回`zerobase`变量的地址**：

```go
// runtime/malloc.go
func newobject(typ *_type) unsafe.Pointer {
  return mallocgc(typ.size, typ, true)
}

func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  if gcphase == _GCmarktermination {
	 throw("mallocgc called with gcphase == _GCmarktermination")
  }

  if size == 0 {
	 return unsafe.Pointer(&zerobase)
  }

  // ...
}   
```

所以空结构体在进行参数传递时，发生值拷贝前后其地址都是一样的：

```go
type User struct {}

func FPrint(u User) {
  fmt.Printf("FPrint: %p\n", &u)  // FPrint: 0x118eff0
}

func main() {
  u := User{}
  FPrint(u)
  fmt.Printf("main: %p\n", &u)    // main: 0x118eff0
}
```

### 3.2 内嵌空结构体的内存对齐

空结构体作为另一个结构体的嵌入字段时，是否需要进行内存对齐与空结构体在新的结构体中的位置有关：

1. 空结构体嵌入在新结构体的最后面时，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变；
2. 空结构体嵌入到其他位置（最前面、中间）时，不占用空间，

之所以会这样，是因为如果空结构体在一个结构体的最后，那么指向这个空结构体字段的指针所表示的地址就不属于这个结构体了，可能会造成安全隐患。

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println("Size:")
	fmt.Println("Test1: ", unsafe.Sizeof(Test1{}))
	fmt.Println("Test2: ", unsafe.Sizeof(Test2{}))
	fmt.Println("Test3: ", unsafe.Sizeof(Test3{}))
	fmt.Println("Test4: ", unsafe.Sizeof(Test4{}))
	fmt.Println("Test5: ", unsafe.Sizeof(Test5{}))
	fmt.Println("Test6: ", unsafe.Sizeof(Test6{}))
}

type es struct {}

type Test1 struct {
	es
	n  byte
}

type Test2 struct {
	es
	n  byte
	m  byte
}

type Test3 struct {
	n  byte
	es
}

type Test4 struct {
	n  byte
	m  byte
	es
}

type Test5 struct {
	n  byte
	es
	m  byte
}

type Test6 struct {
	m  byte
	n  byte
	es
	x  byte
	y  byte
}
```

输出结果如下：

```
Size:
Test1:  1
Test2:  2
Test3:  2
Test4:  3
Test5:  2
Test6:  4
```

> 如果将示例中的类别进行更换，则输出结果也会有所不同。

### 3.3 空结构体与内存逃逸分析

对于如下的代码：

```go
func main() {
  a := new(struct{})
  b := new(struct{})
  println(a, b, a == b) // 0xc000092f57 0xc000092f57 false
  
  c := new(struct{})
  d := new(struct{})
  fmt.Println(c, d)     // &{} &{}
  println(c, d, c == d) // 0x118c370 0x118c370 true
}
```

上面代码中定义了 4 个空结构体类型的变量，但是打印出来的结果却是：`a != b`、`c == d`。而且，如果把`fmt.Println(c, d)`语句注释掉，那么打印出来的结果就变成了：`a != b`、`c != d`。所以，这种奇怪的结果是由`fmt.Println()`方法引起的，而且`fmt.Printf()`方法也会引起同样的问题。

关键原因其实就是`fmt.Println()`和`fmt.Printf()`方法内部涉及到大量的发射相关方法的调用，造成了变量的逃逸行为，也就是使得这些变量被分配到了堆上：

```shell
$ go build -gcflags="-m" main.go
./main.go:12:13: inlining call to fmt.Println
./main.go:6:10: new(struct {}) does not escape
./main.go:7:10: new(struct {}) does not escape
./main.go:10:10: new(struct {}) escapes to heap
./main.go:11:10: new(struct {}) escapes to heap
./main.go:12:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape
```

可以看到变量`c`和`d`都发生了逃逸到堆的行为。如果将`fmt.Println()`方法注释掉，那么它们就都不会发生逃逸了。

而空结构体类型的变量逃逸到堆上之后，Go runtime 会将其优化为指向`runtime.zerobase`的一个地址。也就是说，发生逃逸之后，`c`和`d`本质上都指向了`runtime.zerobase`。那么两者再相比就必然是相等的了，所以会打印出`true`。

而没有发生逃逸的时候，即便两个空结构体类型变量的地址是一样的（指向相同的内存），依然是不相等的。这是 Go 团队刻意而为之的设计，就是不希望大家依赖这个来做判断依据：

> This is an intentional language choice to give implementations flexibility in how the handle pointers to zero-sized objects. If every pointer to a zero-sized object were required to be different, then each allocation of a zero-sized object would have to allocate at least one byte. If every pointer to a zero-sized object were required to be the same, it would be different to handle taking the address of a zero-sized field within a larger struct.
> 
> 这是一个刻意的选择，为了能够实现可扩展操作空结构体指针的行为。如果指向空结构体的指针需要互不相同，那么为空结构体对象分配内存的时候就至少需要分配 1 字节；如果指向空结构体的指针需要都一样，那么就需要为从一个大结构体中取出其空结构体字段的地址采用不同的处理方式了。
> 
> Pointers to distinct zero-sized variables may or may not be equal.
> 
> 指向空结构体的指针，可能相等，也可能不相等。

因此，Go 的这个特性与 map 的随机性如出一辙，就是来避免大家对这类逻辑的直接依赖。

而在没有逃逸的场景下，两个空 struct 的比较动作，其实已经在代码优化阶段被直接优化掉了，转为了`false`。因此，虽然代码上看上去是在做`==`比较操作，实际上结果是`a == b`被直接转换为了`false`，直接都不需要比较了。

如果想让没有逃逸也相等，在代码编译的时候禁止优化就可以了。比如，对于前面的代码，执行如下命令就可以得到相等的结果了：

```shell
$ go run -gcflags="-N" main.go 
0xc000092e75 0xc000092e75 true
&{} &{}
0x118d370 0x118d370 true
```

总结下，对于空结构体的比较：

* 若空结构体变量逃逸到堆上，则其默认被分配的就是`runtime.zerobase`变量，是专门用于分配到堆上的 0 字节对象的地址。因此，此时两个空结构体相比较就相当于是`runtime.zerobase == runtime.zerobase`的比较了，结果自然是`true`。
* 若没有发生逃逸，也就是分配到了栈上。此时，以为 Go 在语言设计上的故意意图，空结构体指针相比是可能相等也可能不相等。所以在 Go 编译器的代码优化阶段，就会对其进行优化，直接返回 false。


