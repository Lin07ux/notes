> 转摘：[Go 结构体函数调用底层实现](http://remcarpediem.net/article/293e04b1/)

下面通过实例来了解结构体变量声明和相关函数调用在机器码或汇编层面的体现。

示例的结构体定义如下：

```go
type User struct {
  ID   int32
  Name string
  Age  int32
}

func (u User) addAgeVal(a int32) int32 {
  n := u.Age + a
  return n
}

func (u *User) addAgePtr(a int32) int32 {
  n := u.Age + a
  return n
}
```

## 一、声明和初始化

### 1.1 未逃逸结构体变量的声明和初始化

对于下面的代码：

```go
func main() {
  u := User{
    ID:   1,
    Name: "Lin07ux",
    Age:  25,
  }
  
  println(u.Age)
}
```

使用命令`go tool compile -S -N -l main.go`编译得到汇编结果，其中关于变量`u`的声明和初始化部分如下：

```asm
// 声明并清空变量 u 空间中各字段的值
// 初始化 u.ID 字段的值为 0
0x001d 00029 (main.go:20)	MOVL    $0, "".u+16(SP)
// 清空 X0 寄存器，然后使用 X0 寄存器的值初始化 u.Name 字段的所占的栈空间
0x0025 00037 (main.go:20)	XORPS   X0, X0
0x0028 00040 (main.go:20)	MOVUPS  X0, "".u+24(SP)
// 初始化 u.Age 字段的值为 0
0x002d 00045 (main.go:20)	MOVL    $0, "".u+40(SP)
// 将 u.ID 字段的值设置为为 1
0x0035 00053 (main.go:21)	MOVL    $1, "".u+16(SP)
// 将字符串 Lin07ux 字面量的地址加载到 u.Name 字段的栈空间（8 字节）
0x003d 00061 (main.go:22)	LEAQ    go.string."Lin07ux"(SB), AX
0x0044 00068 (main.go:22)	MOVQ    AX, "".u+24(SP)
// 将字符串 Lin07ux 字面量的长度 7 设置到 u.Name 后面的栈空间
0x0049 00073 (main.go:22)	MOVQ    $7, "".u+32(SP)
// 将 u.Age 字段的值设置为 25
0x0052 00082 (main.go:23)	MOVL    $25, "".u+40(SP)
```

由这段代码可见，**结构体真的就是基础类型变量的集合，并没有其他额外信息的加载**。

对于 struct 变量的声明和初始化，首先就是将对应的栈内空间清零，然后依次处理各个字段的初始化值加载到对应的栈空间位置，即完成初始化过程。如果某个字段未被设置初始值，那么就不会为加载值到其对应的栈空间，也就是保持为其零值状态。

所以，**在栈空间中，并不存在结构体类型，而是只有由一系列基础类型数值和指针等组成的内存空间，这段空间整体代表着一个结构体类型实例。**

由于`User.ID`和`User.Age`字段是基础类型，比较简单，就直接进行初始化了。而`User.Name`是 string 类型，稍有区别。

Go 的 string 类型在运行时是被解释为`reflect.StringHeader`类型的：

```go
type StringHeader struct {
  Data uintptr
  Len  int
}
```

所以，对应上面的汇编代码，在为`u.Name`字段初始化赋值时，首先是将`Lin07ux`字符串字面量的地址加载到栈空间中（对应`StringHeader.Data`），然后还需要将这个字符串的长度 7 也加载到栈空间中（对应`StringHeader.Len`）。示意图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1636082742321-44054458e205.jpg)

结合汇编代码和上面的图示，可以看到，从栈顶(SP)到栈底，依次是：

* 8 字节内存，代表`u.ID`，值为常量值 1；
* 16 字节内存，代表`u.Name`，其中又分为：
    - 8 字节内存，代表`u.Name.Data`，值为字符串字面量的内存地址；
    - 8 字节内存，代表`u.Name.Len`，值为字符串字面量长度的常量值；
* 8 字节内存，代表`u.Age`，值为常量值 23。

### 1.2 逃逸结构体变量的声明和初始化

上面代码中，变量`u`未发生逃逸，所以其内存都直接分配在了栈中。如果将变量`u`声明为指针类型，并且符合逃逸规则，该结构体就会被分配在堆上。此时相应的初始化操作就会发生变化。

在前面的程序中，增加如下的方法，用于创建一个会逃逸到堆上的`User`类型实例指针：

```go
func makeUser() *User {
  return &User{
    ID:   1,
    Name: "Lin07ux",
    Age:  25,
  }
}
```

这个方法中的`User`数据逃逸到了堆上：

```shell
$ go build -gcflags="-m -l" main.go
# command-line-arguments
./main.go:9:7: u does not escape
./main.go:14:7: u does not escape
./main.go:26:7: &User{...} escapes to heap  # 发生逃逸
<autogenerated>:1: .this does not escape
```

使用`go tool compile -N -S -l main.go`命令，得到这个方法的汇编代码如下（省略部分）：

```asm
// 声明 makeUser 方法，帧空间 40 字节，参数（返回值）空间 8 字节
0x0000 00000 (main.go:25)	TEXT    "".makeUser(SB), ABIInternal, $40-8
// 初始化返回值为 0（指针类型的零值）
0x0021 00033 (main.go:25)	MOVQ    $0, "".~r0+48(SP)
// 将 User 类型的地址加载到栈首，作为 runtime.newobject() 方法的参数
0x002a 00042 (main.go:26)	LEAQ    type."".User(SB), AX
0x0031 00049 (main.go:26)	MOVQ    AX, (SP)
0x0035 00053 (main.go:26)	CALL    runtime.newobject(SB)
// 将 runtime.newobject() 方法的返回值，也就是 User 结构体实例的指针
// 加载到对应的寄存器和栈内地址
0x003a 00058 (main.go:26)	MOVQ    8(SP), AX
0x003f 00063 (main.go:26)	MOVQ    AX, ""..autotmp_2+24(SP)
// 使用指针 (AX) 将 u.ID 设置为 1
0x0044 00068 (main.go:27)	MOVL    $1, (AX)
0x004a 00074 (main.go:26)	MOVQ    ""..autotmp_2+24(SP), AX
0x004f 00079 (main.go:26)	TESTB   AL, (AX)
// 使用指针 16(AX) 将 u.Name.Len 设置为 7(字符串字面量 Lin07ux 的长度)
0x0051 00081 (main.go:28)	MOVQ    $7, 16(AX)
// 使用指针 8(AX) 将 u.Name.Data 设置为字符串字面量 Lin07ux 的地址
0x0068 00104 (main.go:28)	LEAQ    go.string."Lin07ux"(SB), CX
0x006f 00111 (main.go:28)	MOVQ    CX, 8(AX)
0x0075 00117 (main.go:26)	MOVQ    ""..autotmp_2+24(SP), AX
0x007a 00122 (main.go:26)	TESTB   AL, (AX)
// 使用指针 24(AX) 将 u.Age 设置为 25
0x007c 00124 (main.go:29)	MOVL    $25, 24(AX)
0x0083 00131 (main.go:26)	MOVQ    ""..autotmp_2+24(SP), AX
// 将 User 结构体实例的指针加载到返回地址中
0x008d 00141 (main.go:32)	MOVQ    AX, "".~r0+48(SP)
```

可以看到，当发生逃逸时，在开始初始化结构体实例之前，会先将结构体类型的指针加载到栈顶，作为`runtime.newobject()`方法的参数。然后就能在堆上分配对应的类型空间，并得到空间的起始地址。之后，就能类似在栈上初始化类型字段一样，逐步的将堆上的结构体字段进行赋值。

逃逸分配到堆上的示意图参见上图的右侧部分。两者对比，可以看到：当结构体分配在栈上时，其内部成员变量会依次排列在栈中；分配在堆上时，只会在栈上保留一个指向堆地址的指针，而该指针指向结构体实例在堆上的起始位置。

## 二、结构体方法

下面来看一下结构体作为方法接收器时，是如何进行方法调用的，包括如何传递参数和返回值，如何进行值接受和指针接收转换等。

将上面代码中的`main()`方法改成如下的代码：

```go
func main() {
  u := makeUser()
  
  s1 := u.addAgeVal(1)
  s2 := u.addAgePtr(2)

  println(s1 == s2)
}
```

此时，其对应的汇编代码中，会先做如下的操作：

```asm
// 调用 makeUser() 生成 User 类型的变量 u
0x0021 00033 (main.go:20)	CALL    "".makeUser(SB)
0x0026 00038 (main.go:20)	MOVQ    (SP), AX
// 将在堆上生成的 User 类型实例的起始地址赋值给变量 u
0x002a 00042 (main.go:20)	MOVQ    AX, "".u+64(SP)
0x002f 00047 (main.go:22)	TESTB   AL, (AX)
// 将变量 u 的字段，按照 ID、Name、Age 的顺序依次加载到栈内 72(SP) ~ 104(SP) 的内存中
0x0031 00049 (main.go:22)	MOVL    (AX), CX
0x0033 00051 (main.go:22)	MOVL    24(AX), DX
0x0036 00054 (main.go:22)	MOVQ    8(AX), BX
0x003a 00058 (main.go:22)	MOVQ    16(AX), AX
0x003e 00062 (main.go:22)	MOVL    CX, ""..autotmp_3+72(SP)
0x0042 00066 (main.go:22)	MOVQ    BX, ""..autotmp_3+80(SP)
0x0047 00071 (main.go:22)	MOVQ    AX, ""..autotmp_3+88(SP)
0x004c 00076 (main.go:22)	MOVL    DX, ""..autotmp_3+96(SP)
```

### 2.1 值接收器方法

在`main()`方法中，与`s1 := u.addAgeVal(1)`语句相关的汇编代码如下：

```asm
// 将变量 u 的字段，按照 ID、Name、Age 的顺序依次加载到栈内 (SP) ~ 32(SP) 的内存中
// 这是为 User.addAgeVal() 方法的调用值接收器
0x0050 00080 (main.go:22)	MOVQ    ""..autotmp_3+80(SP), AX
0x0055 00085 (main.go:22)	MOVQ    ""..autotmp_3+88(SP), BX
0x005a 00090 (main.go:22)	MOVL    CX, (SP)
0x005d 00093 (main.go:22)	MOVQ    AX, 8(SP)
0x0062 00098 (main.go:22)	MOVQ    BX, 16(SP)
0x0067 00103 (main.go:22)	MOVL    DX, 24(SP)
// 为 User.addAgeVal() 方法的参数 a 赋值为 1
0x006b 00107 (main.go:22)	MOVL    $1, 32(SP)
0x0073 00115 (main.go:22)	PCDATA  $1, $1
// 调用 User.addAgeVal() 方法，并将结果保存到 s1 中，栈内地址为 60(SP)
0x0073 00115 (main.go:22)	CALL    "".User.addAgeVal(SB)
0x0078 00120 (main.go:22)	MOVL    40(SP), AX
0x007c 00124 (main.go:22)	MOVL    AX, "".s1+60(SP)
```

Go 的调用规则要求：函数的参数和返回值都是通过栈来传递，而且都由调用方在其帧栈空间内提供。

从上的代码中，可以得到如下信息：

* **对于值接收器的结构体方法，结接收器是其隐式的第一个参数**，所以上述代码中，在调用`User.addAgeVal()`方法之前，第一步就是将变量`u`的全部数据都拷贝到栈空间上，这也正对应了值接收器的拷贝机制；

* 接下来就是为值接收器方法准备其他的其他参数。对于`User.addAgeVal()`方法，就是还需要为其提供一个 int32 的参数`a`，这里就对应着`32(SP)`位置的值，也就是`1`。

* 最后，就是使用`CALL`指令来调用`User.addAgeVal()`方法，并得到函数的返回值，复制给变量`s1`。

需要注意的是，因为变量`s1`是 int32 类型的，只会占用 4 个字节，所以这里是存在`60(SP)`位置，而不是类似`64(SP)`这样 8 的整数倍（64 位 CPU）的位置。后面会看到，`s2`变量存储在`56(SP)`位置，和`s1`一起占用了 8 个字节的栈空间。

再看一下`User.addAgeVal()`方法的汇编代码：

```asm
// 申请 16 字节的栈空间，使用 48 字节的参数和返回值空间
0x0000 00000 (main.go:9)	TEXT  "".User.addAgeVal(SB), NOSPLIT|ABIInternal, $16-48
...
// 为返回值这是 0 值
0x000e 00014 (main.go:9)	MOVL  $0, "".~r1+64(SP)
// 加载 u.Age，与参数 a 相加
0x0016 00022 (main.go:10)	MOVL  "".u+48(SP), AX
0x001a 00026 (main.go:10)	ADDL  "".a+56(SP), AX
// 将相加结果分别赋值给内部变量 n 和返回值空间
0x001e 00030 (main.go:10)	MOVL  AX, "".n+4(SP)
0x0022 00034 (main.go:11)	MOVL  AX, "".~r1+64(SP)
...
```

该方法是在`main()`方法的栈帧基础上再申请了 16 字节的栈空间（`8(n) + 8(BP)`），并声明其使用 48 字节的参数和返回值空间（`32(User) + 8(a) + 8(result)`）。

在方法中，使用会直接使用`48(SP)`的栈地址来引用`u.Age`字段的值，将其与`56(SP)`栈空间中的参数`a`的值进行相加，并将结果分别赋值给方法内的变量`n`以及方法的返回地址中。

> 该方法申请了 16 字节的栈空间，但是引用变量`u`、参数`a`以及返回值的时候，地址都是多增加了 8，这是因为在执行`CALL`命令的时候，编译器会在调用方的栈顶后面再申请 8 字节来存储调用后的下一个指令的地址。

综上，`main()`函数调用`User.addAgeVal()`方法时，栈变动如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1636108687676-29a6c8fb0bb8.jpg)

### 2.2 指针接收器方法

再来看调用指针接收器函数`User.addAgePtr()`方法相关的指令：

```asm
// 将变量 u（存储了 User 类型堆实例的地址）设置到栈顶
// 作为 User.addAgePtr() 方法的隐式的第一个参数
0x0080 00128 (main.go:23)	MOVQ    "".u+64(SP), AX
0x0085 00133 (main.go:23)	MOVQ    AX, (SP)
// 为 User.addAgePtr() 方法的参数 a 赋值为 2
0x0089 00137 (main.go:23)	MOVL    $2, 8(SP)
0x0091 00145 (main.go:23)	PCDATA   $1, $0
// 调用 User.addAgePtr() 并将结果赋值给变量 s2，栈地址为 56(SP)
0x0091 00145 (main.go:23)	CALL    "".(*User).addAgePtr(SB)
0x0096 00150 (main.go:23)	MOVL    16(SP), AX
0x009a 00154 (main.go:23)	MOVL    AX, "".s2+56(SP)
// 将 s1 和 s2 的值进行比较
0x009e 00158 (main.go:25)	CMPL    "".s1+60(SP), AX
0x00a2 00162 (main.go:25)	SETEQ    ""..autotmp_4+55(SP)
```

可以看到，对于指针接收器方法，在被调用时不需要将整个结构体实例的数据拷贝到栈上，而是直接使用其起始堆地址。这其实就相当于向`User.addAgePtr()`方法传递了变量`u`的指针。然后再为参数`a`设置值，之后进行方法调用和返回值保存。

而`User.addAgePtr()`和`User.addAgeVal()`方法的指令类似，唯一不同的是需要使用指针来获取接收器`u`的`Age`字段的值：

```asm
// 申请 16 字节的栈空间，使用 24 字节的参数和返回值空间
0x0000 00000 (main.go:14)	TEXT   "".(*User).addAgePtr(SB), NOSPLIT|ABIInternal, $16-24
// 将返回值设置为零值
0x000e 00014 (main.go:14)	MOVL   $0, "".~r1+40(SP)
// 加载 u.Age 字段的值到寄存器 AX
0x0016 00022 (main.go:15)	MOVQ   "".u+24(SP), AX
0x001b 00027 (main.go:15)	TESTB  AL, (AX)
0x001d 00029 (main.go:15)	MOVL   24(AX), AX
// 执行加法，并将结果赋值给内部变量`n`和返回值空间
0x0020 00032 (main.go:15)	ADDL   "".a+32(SP), AX
0x0024 00036 (main.go:15)	MOVL   AX, "".n+4(SP)
0x0028 00040 (main.go:16)	MOVL   AX, "".~r1+40(SP)
```

由于指针接收器方法只需要结构体指针作为其隐式的第一个参数，所以这个方法声明使用的参数和返回值空间只有 24 字节（`8(*User) + 8(a) + 8(result)`）。

另外，由于接收器是一个指针，所以获取其字段的时候，就不能从栈上直接取值了，而是要使用指针地址的偏移量从堆上获取。

整个流程的栈变动如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1636109445526-7e36735d8588.jpg)

从图中可以看出，指针接收器的方法被调用时，只需要将接收器的地址作为默认参数进行传递。所以，在方法内对接收器进行修改的话，都是直接修改在原值上的。



