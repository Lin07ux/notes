> 转摘：
> 
> * [空结构体引发的大型打脸现场](https://mp.weixin.qq.com/s/o9E4Ry1Ui-VPyz41KPJvlw)
> * [用 Go struct 不能犯的一个低级错误！](https://mp.weixin.qq.com/s/QnMOwYUANdydbiM8yGznHA)

### 1. 用处

空结构体是不占用内存空间的，所以在一些对值不关注的场景中使用空结构体填充是最合适的。

* 作为 Map 的 value 来实现 set 功能；
* 与 Channel 搭配使用，进行信号通知或并发同步。

比如：

```go
func study(ch chan struct{}) {
  <-ch
  fmt.Println("study with chaochao")
  close(ch)
}

func main() {
  ch := make(chan struct{})
  go study(ch)
  time.Sleep(2 * time.Second)
  ch <- struct{}{}
  time.Sleep(1 * time.Second)
}
```

### 2. 空结构体地址

空结构体不占用内存，其`size`值为 0。

**在堆内存中分配（内存逃逸）时，`size = 0`的对象统一会返回`zerobase`变量的地址**：

```go
// runtime/malloc.go
func newobject(typ *_type) unsafe.Pointer {
  return mallocgc(typ.size, typ, true)
}

func mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {
  if gcphase == _GCmarktermination {
	 throw("mallocgc called with gcphase == _GCmarktermination")
  }

  if size == 0 {
	 return unsafe.Pointer(&zerobase)
  }

  // ...
}   
```

所以空结构体在进行参数传递时，发生值拷贝前后其地址都是一样的：

```go
type User struct {}

func FPrint(u User) {
  fmt.Printf("FPrint: %p\n", &u)  // FPrint: 0x118eff0
}

func main() {
  u := User{}
  FPrint(u)
  fmt.Printf("main: %p\n", &u)    // main: 0x118eff0
}
```

### 3. 空结构体内嵌时的内存对齐

空结构体作为另一个结构体的嵌入字段时，是否需要进行内存对齐与空结构体在新的结构体中的位置有关：

1. **空结构体嵌入在新结构体的最后面时，会被填充对齐到前一个字段的大小，地址偏移对齐规则不变**；
2. **空结构体嵌入到其他位置（最前面、中间）时，不占用空间**.

之所以会这样，是因为如果空结构体在一个结构体的最后，那么指向这个空结构体字段的指针所表示的地址就不属于这个结构体了，可能会造成安全隐患。

```go
package main

import (
	"fmt"
	"unsafe"
)

func main() {
	fmt.Println("Size:")
	fmt.Println("Test1: ", unsafe.Sizeof(Test1{}))
	fmt.Println("Test2: ", unsafe.Sizeof(Test2{}))
	fmt.Println("Test3: ", unsafe.Sizeof(Test3{}))
	fmt.Println("Test4: ", unsafe.Sizeof(Test4{}))
	fmt.Println("Test5: ", unsafe.Sizeof(Test5{}))
	fmt.Println("Test6: ", unsafe.Sizeof(Test6{}))
}

type es struct {}

type Test1 struct {
	es
	n  byte
}

type Test2 struct {
	es
	n  byte
	m  byte
}

type Test3 struct {
	n  byte
	es
}

type Test4 struct {
	n  byte
	m  byte
	es
}

type Test5 struct {
	n  byte
	es
	m  byte
}

type Test6 struct {
	m  byte
	n  byte
	es
	x  byte
	y  byte
}
```

输出结果如下：

```
Size:
Test1:  1
Test2:  2
Test3:  2
Test4:  3
Test5:  2
Test6:  4
```

> 如果将示例中的类别进行更换，则输出结果也会有所不同。

### 4. 空结构体比较

对于如下的代码：

```go
func main() {
  a := new(struct{})
  b := new(struct{})
  println(a, b, a == b) // 0xc000092f57 0xc000092f57 false
  
  c := new(struct{})
  d := new(struct{})
  fmt.Println(c, d)     // &{} &{}
  println(c, d, c == d) // 0x118c370 0x118c370 true
}
```

上面代码中定义了 4 个空结构体类型的变量，但是打印出来的结果却是：`a != b`、`c == d`。而且，如果把`fmt.Println(c, d)`语句注释掉，那么打印出来的结果就变成了：`a != b`、`c != d`。所以，这种奇怪的结果是由`fmt.Println()`方法引起的，而且`fmt.Printf()`方法也会引起同样的问题。

关键原因其实就是`fmt.Println()`和`fmt.Printf()`方法内部涉及到大量的发射相关方法的调用，造成了变量的逃逸行为，也就是使得这些变量被分配到了堆上：

```shell
$ go build -gcflags="-m" main.go
./main.go:12:13: inlining call to fmt.Println
./main.go:6:10: new(struct {}) does not escape
./main.go:7:10: new(struct {}) does not escape
./main.go:10:10: new(struct {}) escapes to heap
./main.go:11:10: new(struct {}) escapes to heap
./main.go:12:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape
```

可以看到变量`c`和`d`都发生了逃逸到堆的行为。如果将`fmt.Println()`方法注释掉，那么它们就都不会发生逃逸了。

而**空结构体类型的变量逃逸到堆上之后**，Go runtime **会将其优化为指向`runtime.zerobase`的一个地址**。也就是说，发生逃逸之后，`c`和`d`本质上都指向了`runtime.zerobase`。那么两者再相比就**必然是相等**的了，所以会打印出`true`。

**而没有发生逃逸的时候，即便两个空结构体类型变量的地址是一样的（指向相同的内存），依然是不相等的**。这是 Go 团队刻意而为之的设计，就是不希望大家依赖这个来做判断依据：

> This is an intentional language choice to give implementations flexibility in how the handle pointers to zero-sized objects. If every pointer to a zero-sized object were required to be different, then each allocation of a zero-sized object would have to allocate at least one byte. If every pointer to a zero-sized object were required to be the same, it would be different to handle taking the address of a zero-sized field within a larger struct.
> 
> 这是一个刻意的选择，为了能够实现可扩展操作空结构体指针的行为。如果指向空结构体的指针需要互不相同，那么为空结构体对象分配内存的时候就至少需要分配 1 字节；如果指向空结构体的指针需要都一样，那么就需要为从一个大结构体中取出其空结构体字段的地址采用不同的处理方式了。
> 
> Pointers to distinct zero-sized variables may or may not be equal.
> 
> 指向空结构体的指针，可能相等，也可能不相等。

因此，Go 的这个特性与 map 的随机性如出一辙，就是来避免大家对这类逻辑的直接依赖。

而在没有逃逸的场景下，两个空 struct 的比较动作，其实已经在代码优化阶段被直接优化掉了，转为了`false`。因此，虽然代码上看上去是在做`==`比较操作，实际上结果是`a == b`被直接转换为了`false`，直接都不需要比较了。

如果想让没有逃逸也相等，在代码编译的时候禁止优化就可以了。比如，对于前面的代码，执行如下命令就可以得到相等的结果了：

```shell
$ go run -gcflags="-N" main.go 
0xc000092e75 0xc000092e75 true
&{} &{}
0x118d370 0x118d370 true
```

总结下，对于空结构体的比较：

* 若空结构体变量逃逸到堆上，则其默认被分配的就是`runtime.zerobase`变量，是专门用于分配到堆上的 0 字节对象的地址。因此，此时两个空结构体相比较就相当于是`runtime.zerobase == runtime.zerobase`的比较了，结果自然是`true`。
* 若没有发生逃逸，也就是分配到了栈上。此时，因为 Go 在语言设计上的故意意图，空结构体指针相比是可能相等也可能不相等。所以在 Go 编译器的代码优化阶段，就会对其进行优化，直接返回 false。


