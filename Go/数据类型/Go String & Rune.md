## 一、基础

### 1.1 字符

Go 中存在两种字符：

* `byte`：是`uint8`的别称，占用 1 个字节。适合存储 ASCII 字符集或者 ASCII 扩充字符集，空间占用较少；
* `rune`：是`int32`的别称，占用 4 个字节，存储时是基于 Unicode 码点存储，不是 UTF-8 字符集值，占用空间较大。

字符串则是一系列的字符组合在一起构成的。Go 源文件的默认编码方式是 UTF-8，Go 的字符串同样也是用 UTF-8 的编码方式。

### 1.2 字符串

Go 语言支持多种方式定义一个字符串：字面量、八进制、十六进制、Unicode 码点值。

下面的例子都是字符串`"世界"`的表示：

```go
s1 := "世界"                      // 字面量
s2 := "\344\270\226\347\225\214" // 八进制
s3 := "\xe4\xb8\x96\xe7\x95\x8c" // 十六进制，\x 后的字符大小写都可
s4 := "\u4e16\u754c"             // 16bit 的 Unicode 码点值
s5 := "\U00004e16\U0000754c"     // 32bit 的 Unicode 码点值（较少使用）
```

> 注：八进制`\ooo`形式，包含三个八进制的数字（0 到 7），但是总体不能超过`\377`（对应一个字节的范围，十进制的 255）。

字符串可以强制转换为`[]rune`或`[]byte`类型，也可以强制转换`[]rune`或`[]byte`为字符串。

### 1.3 原生字符串

字面量形式的字符串除了使用双引号`""`来包裹之外，还可以使用两个`` ` ``反引号来包裹，此时就定义了一个**原生字符串**字面量。

**原生字符串面值中没有转义操作**，全部的内容都是字面的意思，包括退格和换行，因此一个原生字符串面值可能跨越多行。但是依旧可以使用十六进制和八进制来表示特定符号（在原生字符串面值中无法直接写出`` ` ``，可以使用十六进制或八进制来表示）。

原生字符串面值中唯一特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（Windows 系统会把回车和换行一起放入文本文件中）。

示例如下：

```go
const GoUsage = `Go is a tool for managing Go source code. \r\n

Usage:
    go command [arguments]
`
```

### 1.4 转义字符

一些特殊的转义字符也可以用于字符串中，用于表示特定的 ASCII 控制字符：

 escape sequences | description
----------------- | -------------
 `\a`             | 响铃
 `\b`             | 退格
 `\f`             | 换页
 `\n`             | 换行
 `\r`             | 回车
 `\t`             | 制表符（Tab）
 `\v`             | 垂直制表符
 `\'`             | 单引号（只用在`'\''`形式的 rune 符号字面值中）
 `\"`             | 双引号（只用在`"..."`形式的字符串字面值中）
 `\\`             | 反斜杠

## 二、方法

### 2.1 字符串长度

Go 的内置方法**`len()`**方法可以**获取一个字符串占用的字节数量**，注意这个方法获取的并不一定的是字符串中字符的数量。

由于 ASCII 字符集中的字符都只占用一个字节，所以如果字符串中全都是 ASCII 字符时，`len()`方法获取到的就是该字符串的长度。如果字符串中有其他类型的字符（如中文）时，基于`len()`去遍历每一个字节时就会出现乱码。

对于不确定包含什么字符的字符串，可以使用`for ... range`语法来遍历字符串，并自己实现字符串字符数的累计计算。

另外，Go 提供了一个标准包包[`unicode/utf8`](https://pkg.go.dev/unicode/utf8@go1.17.2)，可以实现 utf-8 编码和 Unicode 字符集码点之间的转换。可以使用`utf8.RuneCountInString()`方法获取字符串的字符数量。

### 2.2 字符串比较

字符比较有两种常用的方式：

```go
// 直接比较（性能更高）
stringA == stringB

// 使用标准包中的 Compare 方法比较
strings.Compare(stringA, stringB) == 0
```

这两种方式都会区分大小写，如果需要忽略大小写进行比较，那么这两种方式都需要使用`string.ToLower()`或`strings.ToUpper()`方法转成统一的大小写来实现。

也可以使用`strings.EqualFold()`方法进行大小写不敏感的字符串比较，而且性能更好：

```go
strings.EqualFold(stringA, stringB) // bool
```

当前，在调用比较方法之前，先判断两个字符串的长度是否相等，能更好的进行提速：

```go
len(stringA) == len(stringB) && strings.EqualFold(stringA, stringB)
```

