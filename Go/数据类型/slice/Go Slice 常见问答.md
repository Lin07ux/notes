### 1. slice 是什么？有什么特点？底层数据结构是什么样？

Go 语言中，slice 是一种可保存一组相同数据类型的数据结构。它和数组的区别是 slice 的长度和容量是可变的，可以随时往 slice 中通过`append`函数增加元素。

slice 的底层结构可以表示为一个 SliceHeader 结构，包含 data 指针、len 长度和 cap 容量。data 指针指向一个底层的数组：

```go
type SliceHeader struct {
  Data uintptr
  Len  int
  Cap  int
}
```

结构如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1678014646)

### 2. slice 中的 len 和 cap 字段的作用和使用场景是什么？

slice 的 len 字段表示该 slice 中元素的数量，即一个 slice 只能看到 len 个元素。

slice 的 cap 字段表示该 slice 底层数组的长度，也就是表示该 slice 当前能容纳的元素数量。

cap 一般是用在使用 append 给 slice 添加元素时用到：当往 slice 中 append 元素时，len 的值就会改变，同时如果容量 cap 足够容纳新的元素，就可以直接添加，否则会重新分配新的空间。

![](https://cnd.qiniu.lin07ux.cn/markdown/1678015993)

### 3. 初始化 slice 的方式有几种？区别是什么？

初始化 slice 的方式有三种：

```go
var s1 []int // 声明式
var s2 = make([]int, 0, 10) // make 方式
var s3 = []int{1, 2, 3} // 组合字面量方式
```

第一种方式初始化了一个 nil 切片，第二种方式得到一个长度为 0、容量为 10、元素为零值的切片，第三种方式是使用特定元素初始化一个切片，且该切片的长度和容量都是 3 的切片。

### 4. 空切片和 nil 切片的区别是什么？

空切片和 nil 切片的长度都是 0，可以认为空切片是 nil 切片的一个特例。

不同点在于：nil 切片的 SliceHeader 中的 Data 指针是 nil，而空切片的 Data 指针指向具体的底层数组。

### 5. make 初始化切片的时候可以传递 2 个或者 3 个参数，有什么区别？

make 初始化 slice 的方式为：`make([]int, length, cap)`。其中：`length`指定切片的长度，也就是指定切片的可见元素数量；`cap`主要是用于预先分配空间，在使用`append`对切片进行操作时，不用再为新元素重新分配空间了。

### 6. 对 slice 切分后需要注意什么？

对一个切片进行切分后，两个切片的底层数据实际上指向的是同一个，如果再使用`append`对子切片进行操作，就有可能对原始的切片数据造成影响。

所以想要安全的得到 slice 的子切片，可以使用`copy`获取子切片，或者在使用满切片的表达式来限制子切片的容量，以便在对子切片进行`append`操作时强制进行时强制进行内存的重分配，这样就不会影响原切片了。

### 7. 使用 copy 拷贝 slice 有什么坑？

使用`copy`对 slice 进行拷贝时，需要注意它只会拷贝源 slice 和目标 slice 两者长度的最小值个元素。

也就是说：`copy(dstslice, srcslice)`只会将`min(len(dstslice), len(srcslice))`个元素拷贝到`dstslice`中。

所以，如果目标 slice 的长度为 0，那么其实并不会进行数据拷贝，无法得到预期的结果。

### 8. 什么场景下 slice 会造成内存泄露？

由于对 slice 进行切分后，子切片和原切片共享同一个底层数组，所以如果子切片和原切片有任何一个没有被释放，那么对应的底层数组也不会被释放。

这就导致，在操作一个大容量的切片时，即便只是切分出一个很小的子切片，它依旧会占用原切片的内存空间。如果有大量的这种使用的话，就会造成内存浪费甚至泄露。

解决方式也很简单，就是遵循一个原则：不让子切片和原切片共享底层数组。

### 9. 对 slice 切分后，子切片之外的元素是否会被 GC 回收？

对一个切片进行切分后，由于新年切分的切片的容量和原有的切片的容量是一样的，所以原有的元素依然存储在内存中。这些元素是否会被 GC 回收，遵循如下的规则：

**若切片的元素类型是指针或带指针字段的结构体，那么元素将不会被 GC 回收。**

例如：

```go
func keepFirstElementOnly(ids []strirg) []string {
  return ids[:1]
}
```

如果向`keepFirstElementOnly`传递一个有 100 个字符串的切片，那么剩下的 99 个字符串就会被 GC 回收。虽然原切片的容量会保留（依旧为 100），但是 GC 会回收剩余的 99 个字符串，减少所消耗的内存。

如果将 slice 的元素改为指针类型(`[]*string`)，那么 GC 将不会对元素进行回收。此时如果想要保持容量，但是也要回收元素，就需要手动将元素填充为 nil：

```go
func keepFirstElementOnly(ids []*string) []*string {
  for i := 1; i < len(ids); i++ {
    ids[i] = nil
  }
  return ids[:1]
}
```

### 10. slice 支持并发吗？

Go slice 是对 array 的抽象，其底层就是数组，在并发下写数据到相同的索引位会发生覆盖。另外，切片也有自动扩容的功能，当切片要进行扩容时，就要替换底层的数组，在多个 goroutine 同时运行的情况下，切换底层数组的操作也会发生覆盖，索引在动态扩容时并发写入数据也是不安全的。

所以，对于 slice 是否支持并发，总结如下：

1. 当通过指定索引方式来使用 slice 的时候，切片是支持并发读写索引区的数据的，但是索引区的数据在并发时会被覆盖；
2. 当不指定索引访问切片并且切片发生动态扩容时，并发场景下扩容会被覆盖，索引切片是不支持并发的。

可以使用多种方法来解决切片并发安全的问题：

1. 加互斥锁
2. 使用 Channel 串行化操作
3. 使用`sync.map`代替切片

> iris 框架也曾遭遇到过切片动态扩容导致 websocket 连接数减少的 bug([issue](https://github.com/kataras/iris/pull/1023#event-1777396646))，最终采用`sync.map`解决了该问题。

