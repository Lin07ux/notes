> 转摘：[硬核，图解bufio包系列之读取原理](https://mp.weixin.qq.com/s/rjQ9_8TxfHXpZF4B1gj32w)

## 一、读取介绍

### 1.1 普通文件读取

在 Go 中对文件进行普通读取时，一般是打开一个文件，然后创建一个 byte 切片，再借助打开文件的`Read()`接口将数据读取到切片中。

示例代码如下：

```go
package main

import (
  "fmt"
  "io/ioutil"
  "os"
)

func main() {
  // 以读写模式打开文件
  filename := "./test.txt"
  fd, _ := os.OpenFile(filename, os.O_RDWR, 0666)
  
  // 每次最多读取 2 字节
  b := make([]byte, 2)
  n, err := fd.Read(b)
  fmt.Printf("n=%d, b=%s, err=%+v\n", n, b, err)
}
```

在 Go 中，将读写文件的操作抽象成了接口`io.Reader`和`io.Writer`，只要实现了对应接口的方法即可进行读写操作。而`os.OpenFile()`方法返回的 File 对象也实现了这两个接口。

`os.File`对象的读写操作实现上，是通过底层系统的文件系统 IO 接口实现的，每次读取都需要调用一次底层的系统接口。若需要连续多次读取，效率就会大大降低。

![](http://cnd.qiniu.lin07ux.cn/markdown/1652959356063-1ca9d0881d39.jpg)

### 1.2 bufio 缓存读取

bufio 进行缓存读取的思路很简单：当需要从文件中读取数据的时候，先从文件中读取一大块内容到内存缓冲区中，后续的读取操作可以直接从内存缓冲区进行读取，以降低从文件中读取时的系统调用次数。

流程如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652959465576-ef29ff00a187.jpg)

可以看到，bufio 的缓存读就是在用户程序读取和系统 IO 读取之间增加了缓冲区而已，理论上由用户一次读取大量的数据然后分批使用也是一样的效果。

但是 bufio 的具体实现中，针对不同的场景使用了不同的策略机制，这使得用户的程序能尽可能的简化读取操作。

## 二、缓冲区的状态

bufio 缓冲区有三种状态，分别是：

* 缓冲区为空（无可读取数据）
* 缓冲区未满（有可读取的数据）
* 缓冲区满（无写入空间）

在 bufio 中，缓冲区本质上是一个字节切片，并通过两个整型变量`r`和`w`分别表示可读取以及可写入的索引位置：

* 从文件中每加载一个字节的内容到缓冲区则`w = w + 1`；
* 从缓冲区每读走一个字节的内容则`r = r + 1`。

### 2.1 缓冲区为空

缓冲区为空的状态本质上就是指没有内容可读，其判断标准就是：

```
r == w
```

因为`r`和`w`相等，意味着已经将写入到缓冲区的内容都读取完了。

最简单的情况就是初始情况，也就是`r = w = 0`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652960991920-28eb01ba24c5.jpg)

其他情况则是读取完全部缓冲的数据了，如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652960974847-01e5ada71bf7.jpg)

在这种情况下，再次读取内容时，会首先将`r`和`w`重置为 0，然后从文件中加载新的数据填充到缓冲区中，以供下次调用方读取。

### 2.2 缓冲区非空

这种状态是指缓冲区中有可读的内容，其判断标准如下：

```
r != w && (w-r) < len(buf)
```

其中，`r != w`说明`buf[r:w]`这段内容还没有被调用方读取；`(w-r) < len(buf)`说明 buf 不是满的，还可以继续填充内容。

![](http://cnd.qiniu.lin07ux.cn/markdown/1652961558770-1c4df48143ca.jpg)

在这种状态下，当程序执行读取操作时，会直接从缓冲区中读取。

### 2.3 缓冲区已满

最后一种状态就是缓冲区已满，判断标准为：

```
(w - r) >= len(buf)
```

要满足上述条件公司，只有一种情况：`r = 0`且`w = len(buf)`。这表示整个缓冲区中都写满了数据，而还没有从缓冲区读走任何数据。

![](http://cnd.qiniu.lin07ux.cn/markdown/1652962226441-d96e2c5e4b5a.jpg)

## 三、bufio 读取逻辑

### 3.1 读取指定长度数据 Read([]byte)

bufio 最简单的读取就是和前面的普通文件读取操作类似，只是将文件使用 bufio 进行了一次包裹：

```go
package main

import (
  "bufio"
  "fmt"
  "os"
)

func main() {
  // 以读写模式打开文件
  filename := "./test.txt"
  fd, _ := os.OpenFile(filename, os.O_RDWR, 0666)
  
  // 将 fd 包装到 bufio Reader 中
  bufioReader := bufio.NewReader(fd)
  
  // 从 bufio 中读取 2 字节数据
  p := make([]byte, 2)
  n, _ := bufioReader.Read(p)
  
  fmt.Printf("n=%d, p=%s", n, p)
}
```

与普通文件直接读取数据的代码对比起来，只多了一步使用 bufio 包装 File 的步骤。

> 为了演示方便，假定缓冲区长度为 5。**在 bufio 中默认的缓冲区大小实际上是 4096 字节，即 4KB。**

#### 3.1.1 缓冲区为空时(`r = w`)

缓冲区为空时，进行读取有两种情况：

* 若调用方要读取的字节数小于缓冲区的长度，则先从文件中读取数据填充缓冲区，再从缓冲区中取出要读取的一定长度的数据；
* 若调用方要读取的字节数大于或等于缓冲区的长度，则直接从文件中读取并返回给调用者，不会填充缓冲区。

**读取字节数大于或等于缓冲区长度**

当读取字节数大于等于缓冲区长度的时候，从文件中读取的数据会被调用方一次性取走，所以就不需要将读取的数据在缓冲区中存一遍，而是直接交给调用方即可。

![](http://cnd.qiniu.lin07ux.cn/markdown/1652965837614-cfd7c998ac2b.jpg)

**读取字节数小于缓冲区长度**

此时会先从文件中读取尽可能多的数据，以将缓冲区填满，然后再从缓冲区中读取需要的长度的数据返回。

比如，上面的代码中，如下的两行代码就是从 bufio 中读取数据：

```go
p := make([]byte, 2)
n, _ := bufioReader.Read(p)
```

这表示要从文件中读取 2 个字节，由于要读取的数据小于缓冲区的长度（假定为 5 字节），所以在 bufio 中会先尝试从文件中读取 5 字节的数据以尽量填满缓冲区。此时：

* 若文件的可读取的内容字节数大于等于缓冲区容量，就能将缓冲区填满；
* 若文件的可读取的内容字节数小于缓冲区容量，则将可读取内容全部读取到缓冲区即可。

读取内容之后，会将`r`设置为 0，并将`w`设置为实际从文件中读取出来的数据。

如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652975657164-69f14c6ba7c2.jpg)

然后，从缓冲区中读取数据，也就是拷贝 2 字节的数据给变量`p`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652976118786-7941f6511983.jpg)

最后，移动`r`到读取后的起始位置，也就是`r = 2`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1652976235502-ec643b69632f.jpg)

这样，下次读取数据的时候，就会从 buf 中的 2 字节处开始读取。

#### 3.1.2 缓冲区非空(`r != w`)

在缓冲区非空状态下进行读取操作时，就是直接从缓冲区中获取指定长度的内容返回，并更新对应的`r`值即可。唯一需要注意的是：**当缓冲区中可读取的内容字节数小于调用者要读取的字节数时，只能读取到缓冲区中的内容，不会再从文件中读取后补足**。

比如，下面是 bufio 中缓冲区的初始状态，目前只有 1 字节的内容可读：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653010345784-7f09112bce3d.jpg)

如果调用者期望读取 2 个字节的内容，这时是不会再从文件中继续读取的，而是只读取缓冲区的内容：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653010400932-b889d3a6b147.jpg)

最后，将实际读取大哦的字节数返回给调用者，并将下次可读取的索引位置`r`进行更新：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653010479518-68b50f610703.jpg)

这时，缓冲区的状态实际上是变成了空的状态。下次再次读取的话，`r`和`w`会被复位成 0 后，转换为缓冲区为空状态的读取处理。

#### 3.1.3 缓冲区满(`w - r = len(buf)`)

缓冲区满的时候和缓冲区非空的时候的读取处理其实是相同的，也就是说只会从 buf 中读取指定长度的数据，不足的话也不会从文件中继续读取后补充。

### 3.2 读取到指定字符

这种读取方式是从缓冲区中读取数据，直到遇到指定的字符为止（实际上是指定字符所在切片的索引位置）。比如最常见的按行读取，就表示每次读取到换行符位置。

这种读取方式实际也分为两种情况：

1. 当缓冲区中包含指定的字符，则从缓冲区中直接返回该字符及其之前的有效内容；
2. 当缓冲区中没有指定的字符，又分为：
    * 若缓冲区是满的状态，则返回整个缓冲区的内容；
    * 若缓冲区处于非满状态，则将缓冲区填满内容，再判断是否存在指定字符：存在就返回该字符及其之前的有效数据，否则返回全部的缓冲区数据。

#### 3.2.1 包含指定字符

缓冲区中包含指定字符时，处理较为简单：此时已经指定了指定字符在缓冲区中的索引位置，直接读取缓冲区切片即可。

比如，读取数据直到遇到字符`E`为止，而缓冲区当前的状态如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011211881-ae99c02d3148.jpg)

可以看到，缓冲区中`buf[1:5]`这段内容中包含字符`E`，而且字符`E`的索引位置为 1，那么直接返回`buf[1:2]`即可。

#### 3.2.2 不包含指定字符

不包含指定字符时，需要分为两种情况：缓冲区满和不满。

**缓冲区满**

在缓冲区满的情况下，找不到指定的字符会将缓冲区中当前有效的数据都返回。

比如，当前缓冲区的状态如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011411960-f3d255e65da5.jpg)

当需读取到字符`B`结束时，由于在缓冲区的数据中不存在字符`B`，而且缓冲区是满的，所以就直接将整个缓冲区的数据返回给调用方了，同时返回的错误为**缓冲区满错误 `errors.New("buffer is full")`**。

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011564676-34eae34e417b.jpg)

**缓冲区非满**

缓冲区非满可能是空，也可能是非空非满。缓冲区空的时候必然找不到指定字符的，和非空非满的处理方式相同了。下面就以非空非满状态来说明。

假设缓冲区中下次可读的位置在第 5 个，如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011749601-52a30e9576a8.jpg)

从缓冲区的索引 5 的位置开始查找字符`B`，发现没有找到，但同时也发现缓冲区处于非满状态（因为`buf[0:5]`的数据已经被读取走了）。此时会先将`buf[5:8]`的数据向前移动到缓冲区起始位置，也就是`buf[0:3]`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011903810-57e5b4afa409.jpg)

然后再从文件中读取一段内容填充缓冲区空闲的部分，也即是`buf[3:8]`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653011941248-d7c1ef0b53d1.jpg)

再在新填充进来的内容中查找指定的字符`B`（因为`buf[0:3]`的数据中已经确定没有指定的字符了，所以不需要重复查找）：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653012259816-6ba6350d1e58.jpg)

如果新填充的数据中也没有找到指定的字符，则将当前缓冲区中的有效数据都返回给调用方，并根据缓冲区是否已满来决定是否返回**缓冲区满错误**。

如果能够找到指定的字符了，那么就返回该字符及其之前的有效数据：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653012379727-a1641a60876b.jpg)

以上在缓冲区中移动内容到开始位置，并重新填充内容到缓冲区的过程实际上就是 bufio 包中的`fill`方法。而整个按指定字符读取的过程是 bufio 包中的`ReadLine`和`ReadSlice`函数的对应实现（`ReadLine`函数调用了`ReadSlice`函数。`ReadLine`函数默认读是读取内容直到遇到第一个换行符`\n`为止。

### 3.3 读取到文件中的指定字符

上面介绍的`ReadLine`和`ReadSlice`函数是从缓冲区中读取到指定字符为止，只要在缓冲区满的状态下，无论能否搜索到对应的字符，都会返回结果。但是一般情况下，文件的数据都会远远大于缓冲区的大小，当在缓冲区满状态但没有找到对应的字符时，文件中剩余数据中可能还会存在该字符。

读取到文件中的指定字符这种读取方式则不限于缓冲区中是否能查找到该字符，而是在全文件数据中进行查找，直到文件末尾。

在这个过程中，会依次将文件的内容读取到缓冲区中，然后判断缓冲区中是否有指定字符：

* 如果在缓冲区中未找到指定字符，则将缓冲区中的数据暂存到一个临时区，然后再次读取数据到缓冲区中进行查找；
* 如果在缓冲区中找到了指定字符，则缓冲区的数据和暂存区的数据合并起来一起返回给调用者。

比如，假设缓冲区处于满状态，要查找的指定字符为`r`。

第一步会先从缓冲区中查找：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653017415148-e3b81fe47e85.jpg)

第二步，由于在缓冲区中未找到指定的字符`r`，所以需要将缓冲区中的内容移动到暂存区存储起来，以备后续返回时使用：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653017458601-25682bb97df1.jpg)

第三步，暂存之后，缓冲区已处于空状态，可以再次填充文件中的数据，然后进行再次在缓冲区中查找字符`r`：

![](http://cnd.qiniu.lin07ux.cn/markdown/1653017519750-e4c362028362.jpg)

如果在第三步中没有找到指定的字符，会重新回到第二步，依次循环，直到找到指定的字符或将文件中所有的内容都扫面完为止，最终将暂存区和缓冲区中的内容都返回。

此过程就是 bufio 中的`ReadString`函数及`collectFragments`函数的实现。

## 四、总结

由以上可知，bufio 是利用局部性原理，通过将文件的内容预先加载到缓冲区中，以减少 ID 的系统调用来提高读取性能的。

也就是说，当读取数据时，只有在缓冲区中能够命中时才能提高读取的性能。

