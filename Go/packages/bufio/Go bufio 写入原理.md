> 转摘：[硬核，图解bufio包系列之写入原理篇](https://mp.weixin.qq.com/s/4FqW6AzEHRQqEZktDK6JGA)

### 1. 一般写入方式

Go 语言中，普通的写入方式是将内容通过`io.Writer`接口直接写入到目标文件中，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/21af38909fbe4940b788c8deb2036e7e.jpg)

代码如下:

```go
package main

import (
  "fmt"
  "os"
)

func main() {
  filename := "./test.txt"
  fd, _ := os.OpenFile(filename, os.O_RDWR, 0666)

  // 向文件中写入内容
  body := "Hello Wolrd"
  n, err := fd.Write([]byte(body))
  fmt.Printf("n=%d, err=%+v\n", n, err)
}
```

这种写入方式是通过文件系统的 IO 进行写入：

* 优点是：每次写入都是直接持久化到文件中，写入后内容不会丢失；
* 缺点是：每次都需要一次底层的系统调用，若需要连续多次写入，效率就会大大降低。

### 2. bufio 写入

提高写入效率的凡是依然是使用缓存，其基本思想是先将多次少量的内容写入到一大块的缓冲区中，然后再一次性的将缓冲区内容写入到文件中，从而减少系统调用的次数，提高写入效率。如下图所示：

https://cnd.qiniu.lin07ux.cn/markdown/70a16a7de7c6d3f5be7806349c26808e.jpg

一般情况下，缓冲区会比较大，默认是 1024KB，而写入的内容一般比较小，并需要多次写入。这样就能将每次少量的写入合并成一个大的写入，才能较少系统调用的次数。

缺点是：有丢失数据的风险，比如缓冲区中的数据在没有持久化到目标中之前突然宕机了，那么这部分内容就没有写入到文件中。

### 3. 缓冲区的组成

在写入操作中，会将缓冲区分为两部分：已缓冲了数据的区域和空闲区域。这两部分使用一个位置标识符 n 进行分隔，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/45687bdfa963bf3b1cdde7499eb23bd2.jpg)

在`bufio.Writer`结构中有两个方法：

* `Writer.Buffered()` 返回已缓冲区数据区域的大小（字节数）；
* `Writer.Available()` 返回空闲区域的大小（字节数）。

在写入时，通过比较要写入的内容的字节数和这两个状态的大小来决定具体的写入机制。

### 4. bufio 的写入机制

下面分几个场景来说明 bufio 的写入机制。

#### 4.1 场景一：要写入内容的数据量小于缓冲区的可用空间

也就是说，缓冲区里有足够的空间可以容纳下本次要写入的内容，这时 bufio 就只是简单的将数据写入到缓冲区中，而非目标文件中。所以需要注意的是：当完成全部的写入之后，一定要主动调用一次`Flush()`方法，以便将缓冲区的内容也写入到目标文件中。

下面以缓冲区长度为 5 字节、要写入 3 字节的数据为例，初始状态如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/3c8798606bef3b35396c9a6043b8b8c3.jpg)

上图中，还有 4 个字节的空闲空间，现在要写入 3 字节的数据，缓冲区的空闲空间可以容纳要写入的全部数据，则直接将数据写入缓冲区中，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/01478bad71659c5cecc058cd36157389.jpg)

这时数据只是写入到缓冲区中暂存，还没有持久化到目标文件中，如果不再继续写入了，一定要调用一次`Flush()`方法将缓冲区中的内容持久化到目标文件中。

#### 4.2 场景二：要写入内容的数据量大于缓冲区的可用空间

继续前面的示例，再次写入 2 字节的数据，此时由于缓冲区的剩余可用空间只有 1 字节了，再写入 2 字节的数据就会超出缓冲区的空闲空间了，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/a9c0dc8192f5b2748d94fbf1341728cc.jpg)

因为缓冲区中还有内容，这是需要先将缓冲区填满，即：将写入内容的第一个 1 字节拷贝到缓冲区，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/730c52159a20a60d8149f51b6f056fa3.jpg)

这时缓冲区就满了，同时判断还有数据未写完，所以就需要将缓冲区中的内容刷入到目标文件中，以腾出缓冲区空间继续接收后续未写入的内容，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/9a21c09f4dfcec611552c179bf5d4f04.jpg)

将缓冲区的内容全部刷入到目标文件中后，现在缓冲区实际上就处于空状态了，可以继续接收剩余要写入的数据了。此时再将剩余的 1 字节内容写入到缓冲区暂存，如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/d765027f1f5e27feb099aeea70987287.jpg)

这里需要注意：虽然本次写入了 2 字节数据，但是有 1 个字节还暂存在缓冲区中，并没有真正的写入到目标文件中。所以如果要保证该字节也写入到文件中，就需要主动调用一次`Flush()`方法。

#### 4.3 场景三：写入时缓冲去为空

前面两个写入的场景都是在缓冲区中已有内容时进行写入，如果写入时缓冲区就是空的，此时分为两种情况进行处理：

* 要写入的数据大小比缓冲区小，此时和前面的写入场景是一样的处理方式，就是将数据放在缓冲区中暂存，而不是直接写入文件中；
* 要写入的数据大小比缓冲区大，此时就会绕过缓冲区，直接将数据写入到目标文件中。如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/ffd5a98f25d434c4306dd6582ab80d04.jpg)

### 5. 总结

通过上面的几个场景，bufio 的写入机制有如下总结：

* 当要写入的数据大小 **小于** 缓冲区的空闲区域大小时
    * 将数据写入缓冲区中暂存；
* 当要写入的数据大小 **大于** 缓冲区的空闲区域大小时
    * 缓冲区为空：不经过缓冲区直接将数据写入到文件中
    * 缓冲区不为空：先填满缓冲区，并将缓冲区的内容写入到文件中，再判断剩余内容的大小和缓冲区可用空间的大小，进行后续的处理。

另外，需要注意的是：在结束写入时，调用者应在调用了`bufio.Writer.Write()`之后，在调用一次`bufio.Writer.Flush()`方法，以确保暂存于 bufio 缓冲区的数据被写入到目标文件中，以免造成缓冲区的数据丢失。