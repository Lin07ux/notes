> 转摘：[Go 切片这道题，吵了一个下午！](https://mp.weixin.qq.com/s/kEQI74ge6VhvNEr1d3JW-Q)

### 1. 问题展示

有如下代码：

```go
import "fmt"

func main() {
    sl := make([]int, 0, 10)
    var appendFunc = func(s []int) {
        s = append(s, 10, 20, 30)
        fmt.Println(s)
    }
    
    fmt.Println(sl)

    appendFunc(sl)
    fmt.Println(sl)
    
    fmt.Println(sl[:])
    fmt.Println(sl[:10])
    
    fmt.Println(len(sl), cap(sl))
}
```

这段代码的输出结果是下面这样吗？

```
[]
[10 20 30]
[]
[]
[]
0 10
```

不是！正确的结果是：

```
[]
[10 20 30]
[]
[]
[10 20 30 0 0 0 0 0 0 0]
0 10
```

### 2. 涉及问题

1. 为什么`sl`中会包含函数闭包中插入的数据？
2. 为什么打印`sl[:10]`时，结果包含了 10 个元素？
3. 为什么打印`sl`和`sl[:]`时为空，但是打印`sl[:10]`就正常？

### 3. 了解底层

要分析上面的三个问题的原因，就必须再提到 slice 切片的底层实现。

slice 在运行时的表现是 SliceHeader 结构体，定义如下：

```go
type SliceHeader struct {
    Data uintptr
    Len int
    Cap int
}
```

各个属性的含义如下：

* `Data`：指向具体的底层数组
* `Len`： 代表切片的长度
* `Cap`： 代表切片的容量

可以看到，slice 底层存储的数据结构指向了一个 array，也就是说，slice 结构中**存储的是指向所引用的数组指针地址**。如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1631243757061-4bae1f0581b3.jpg)

### 4. 分析原因

在了解 slice 的底层实现之后，就好里面上面的三个问题和上面 Go 代码的输出结果了。

*1. 为什么`sl`中会包含函数闭包中插入的数据？*

Go 语言中所有东西都是以值传递的，也就是说，一个函数总是得到一个被传递的东西的副本。所以，在调用`appendFunc`函数时，函数闭包得到的是切片`sl`的一个副本，进行 append 操作的也是这个副本。

但是，虽然在函数闭包中是在操作副本，但是副本的`Data`与`sl.Data`是相同的值，也就是他们指向的是同一个底层数组。那么在对副本进行数据追加时，会对底层数组造成影响。自然，引用同一个底层数组的`sl`的数据也有变化了。

这样就不难理解为什么`sl`中会出现函数闭包中加入的`10, 20, 30`了。

要记住一个关键点：**如果传过去的值是指向内存空间的地址，是可以对这块内存空间做修改的。**反之，也无法修改。

*2. 为什么打印`sl[:10]`时，结果包含了 10 个元素？*
*3. 为什么打印`sl`和`sl[:]`时为空，但是打印`sl[:10]`就正常？*

这两个问题的原因是相同的，所以就放在一起解释。

这两个问题用上面的结论似乎是没法完整解释的。虽说程序是诱因，但这块最直接的影响是和切片访问的小优化有关的。

常见的切片访问会用如下语法：`s[low : high]`。

这里的`low`和`high`是可变的，而且`high`的最大的取值范围对应着切片的容量`cap`，而不是长度`len`。因此是可以使用`sl[:10]`而不出现越界的情况。

另外，`low`和`high`两个值都是可以省略的：

* `low`省略时，相当于`low = 0`；
* `high`省略时，相当于`high = len`。

而且，直接获取`sl`的值，相当于获取`sl[:]`(也就是`sl[0:len]`)的值。

在`appendFunc`函数内部，对`sl`的副本`s`切片进行操作之后，除了写入数据，还会使得`s.Len`从 0 变为 3，所以在`appendFunc`打印副本切片`s`时，相当于打印`s[0:3]`，会正常打印出`10 20 30`。

在`appendFunc`调用之后，因为改变的是`sl`的副本的`Len`，而`sl.Len`是没有发生变化的，也就是还是 0，那么打印`sl`和`sl[:]`时都相当于打印`sl[0:0]`，自然是什么也不会有了。

而在打印`sl[:10]`的时候，因为指定了结束位置，所会将切片指向的数组中的全部数据都给打印出来了。

