### 1. 步骤

希尔排序(Shell's Sort)是插入排序的一种又称“*缩小增量排序*”(Diminishing Increment Sort)，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因 D.L.Shell 于 1959 年提出而得名。

该方法的基本思想是：先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前两种方法有较大提高。

具体步骤如下：

1. 选择一个序列 t1、t2、...、ti、tj、...、tk，其中 ti > tj, tk = 1，作为增量序列；
2. 依次按照增量序列的值 k 对数据进行分组，每组数据间隔为 k，再对每组数据进行组内插入排序；
3. 重复执行第 2 步，直到增量序列的值 k 为 1 时，将整个数据作为一个组进行处理。


### 2. 动态图

动态图如下：

![](http://cnd.qiniu.lin07ux.cn/Yhs12z.gif)

假设原数据为：`[8, 3, 6, 7, 4, 9, 2, 5]`。对其进行希尔排序，分解步骤如下：

1. 设置初始化增量值为`$gap = $length / 2 = 4`，将数组分为四组`[8, 4], [3, 9], [6, 2], [7, 5]`。

    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1556433389080.png "/>

    组内插入排序结果为`[4, 8], [3, 9], [2, 6], [5, 7]`，结果集为`[4, 3, 2, 5, 8, 9, 6, 7]`。
    
2. 缩小增量值`gap = gap / 2 = 2`，将数据分为两组`[4, 2, 8, 6], [3, 5, 9, 7]`。

    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1556433491070.png" />

    组内插入排序结果为`[2, 4, 6, 8], [3, 5, 7, 9]`，结果集为`[2, 3, 4, 5, 6, 7, 8, 9]`。(此时由于是巧合刚好已经是有序的了，但是依旧要继续缩小增量)。
    
3. 缩小增量值`gap = gap / 2 = 1`，将数据分为一组`[2, 3, 4, 5, 6, 7, 8, 9]`。

    <img src="http://cnd.qiniu.lin07ux.cn/markdown/1556433611535.png" />
 
    组内排序结果为`[2, 3, 4, 5, 6, 7, 8, 9]`。

4. 由于增量值已经是 1 了，所以结束排序流程，当前结果已经是有序的了。
 
### 3. 代码实现

```php
function shellSort($arr) {
    $len = count($arr);
    
    // 缩小增量，每次都取原先值的 1/2 的向下取整的值，$gap >> 1 === floor($gap / 2)
    for ($gap = $len >> 1; $gap > 0; $gap = $gap >> 1) {
        // 使用增量进行分组
        for ($i = $gap; $i < $len; $i++) {
            $temp = $arr[$i];
            $j = $i - $gap;
            
            // 对组内数据进行插入排序
            while ($j >= 0 && $arr[$j] > $temp) {
                $arr[$j + $gap] = $arr[$j];
                $j -= $gap;
            }
            
            $arr[$j + $gap] = $temp;
        }
    }
    
    return $arr;
}
```

### 4. 测试示例

```php
$startTime = microtime(1);

$arr = range(1, 10);
shuffle($arr);

echo "before sort: ", implode(', ', $arr), "\n";
$sortArr = shellSort($arr);
echo "after sort: ", implode(', ', $sortArr), "\n";

echo "use time: ", microtime(1) - $startTime, "s\n";
```

### 5. 复杂度

希尔排序的时间复杂度取决于初始增量的选取，对于本文所选去的初始增量方式时间复杂度为`O(nlog2(n))`。

只用到了一个临时变量，所以**空间复杂度为`O(1)`**。

希尔排序的增量序列可以自由指定，目前并没有一个统一的定论说明什么增量序列最合适。

### 6. 希尔排序打破二次时间界的原理

冒泡排序、选择排序、插入排序的时间复杂度都是`O(n^2)`，而作为插入排序改进版的希尔排序，时间复杂度第一次突破了二次时间屏障，这跟希尔排序的特殊交换方式有关。

要明白希尔排序为何能够通过非相邻交换方式突破二次时间屏障，需要先了解排序中的一些概念：

* **逆序**：数据列中，具有性质`i < j`但`a[i] > a[j]`的序偶`(a[i]，a[j])`表示一个逆序。
* **交换两个不按顺序排序的相邻元素恰好消除一个逆序**，而一个排过序的数组没有逆序。
* **交换两个不按顺序排序的不相邻元素可以消除至少一个逆序**。

比如，序列`34, 8, 64, 51, 32, 21`有 9 个逆序，即：`(34, 8)`、`(34, 32)`、`(34, 31)`、`(64, 51)`、`(64, 32)`、`(64, 21)`、`(51, 32)`、`(51, 21)`以及`(32, 21)`。这正好是需要（隐含）执行的交换次数。

* 如果交换元素 34 和 8，则可以消除一个逆序`(34, 8)`；
* 如果交换元素 64 和 32，则可以消除`(64, 51)`、`(64, 32)`两个逆序；
* 如果交换元素 64 和 21，则可以消除`(64, 51)`、`(64, 32)`、`(64， 21)`、`(51, 21)`、`(32, 21)`五个逆序。

所以，选择合适的增量序列会有比较好的效果提升，但是具体选择什么样的增量序列并没有一定，但是有如下的一些特点：

1. 希尔排序的运行时间依赖于增量序列的选择 ，而证明很复杂。
2. 使用希尔增量时希尔排序最坏时间复杂度是`O(n^2)`。
3. 使用 Hibbard 增量的希尔排序最坏时间复杂度是`O(n^3/2)`，最优时间复杂度是`O(n^5/4)`。
4. 使用 Sedgewick 增量序列排序最坏时间复杂度是`O(n^4/3)`；平均时间复杂度是`O(n^7/6)`。最好的序列是`{1,5,19,41,109...}`。该序列中的项或者是`9 * 4^i - 9 * 2^i +1`的形式，或者是`4^i- 3*2^i + 1`的形式。

希尔排序是不稳定的排序。因为每一趟的步长不一样，所以步长长的插入排序可能会把后面的元素插入到前面。

> 转摘：[你知道希尔排序为什么可以打破二次时间界吗？](http://www.cnblogs.com/9dragon/p/10720032.html)

