> 转摘：[一文读懂ECDSA算法如何保护数据](https://zhuanlan.zhihu.com/p/97953640)
> 原文：[Understanding how ECDSA protects your data](https://www.instructables.com/Understanding-how-ECDSA-protects-your-data/)

ECDSA 是一种常见的数字签名算法，在区块链特别是以太坊中使用的较多。下面将使用尽可能比较简单的方式介绍其原理和签名/验签步骤。

### 1. What is ECDSA?

ECDSA 是 Elliptic Curve Digital Signature Algorithm 的简称，主要用于对数据（比如一个文件）创建数字签名，以便于在不破坏它的安全性的前提下对它的真实性进行验证。这类似于现实中对一个文件进行签名，然后其他人员就可以通过签名的笔记来辨别文件的真伪。不过，ECDSA 签名会更加安全。

需要注意的是，ECDSA 是数据签名算法，和对数据进行加密的 AES 算法不是同一类：ECDSA 不会对数据进行加密、或者阻止别人看到或访问到签名的原数据，但是它可以确保数据是没有被篡改的。

ECDSA 中有两个词需要注意：`Curve`（曲线）和`Algorithm`（算法）。这意味着 ECDSA 基本上是基于数学知识的，并且涉及到非常复杂的数学原理。

为了更好的理解 ECDSA 算法的原理，下面会分两部分讲解这部分内容：首先是对它具体的工作原理进行解释，然后深入其内部工作机理。

### 2. Understanding the Basics

原理非常简单：

1. 在 x-y 坐标系上画一条曲线，并在这条曲线上面随机选择了一个点作为`原点(point of origin)`；
2. 生成一个随机数，作为`私钥(private key)`；
3. 使用上面的随机数和原点，通过一些复杂的数学方程得到曲线上的第二个点，即为`公钥(public key)`。

这说明，公钥是由私钥计算得到的，也就是可以从私钥导出其匹配的公钥。但是反过来，在不知道原点的情况下，是无法通过公钥得到私钥的。

当要对数据进行签名的时候，使用这个私钥（随机数）和数据的哈希（一串独一无二的代表该文件的数）输入到一个数学方程，从而得到对应的签名。签名由两部分组成：`R`和`S`。

在验证数据的签名时，只需要公钥（使用私钥在曲线上面产生的点）和签名中的`S`部分一起代入另一个数学方程进行计算。如果这个签名是由私钥正确签名过的数字签名，那么这次计算得到的结果将和签名数据中的`R`部分相同。

简单来说：一个数字签名包含两个数字，`R`和`S`，将私钥和数据哈希代入一个数学方程进行计算即可产生`R`和`S`，如果将公钥和签名的`S`代入另一个数学方程进行计算得到的结果和签名中的`R`相同，那么这个签名就是有效的。

### 3. Why use ECDSA?

在继续深入理解 ECDSA 算法之前，先介绍下为什么使用 ECDSA 以及它的具体使用场景。

除了显而易见的“我需要对一份文件/合同进行签名”，还有一些非常流行的应用场景：应用程序（如游戏）的发行方不希望自己的数据被用户修改或者破坏，只能载入官方数据，或者一部只允许安装官方应用程序的手机或者其他设备。

在这些案例当中，相关文件（应用程序、游戏地图、数据等），可以使用 ECDSA 进行签名，公钥会随程序/游戏/设备一起捆绑发行，并用来进行签名的验证，确保数据没有被修改。而私钥则在本地一个私密的地方进行保存。由于公钥只能对签名进行验证，不能用它创建或者伪造新的签名，所以它可以无所顾忌的进行分发的。

这与 AES 相比，区别是显而易见的：AES 加密系统可以对数据进行加密，但是也需要用密钥来解密。这就需要将密钥与应用程序一起捆绑，破坏了对数据进行保护、防止数据被用户修改的目的。

一个很好的例子就是 PS3 的控制台，它被大量的破解，所有的文件都可以解密，所有的密钥可以从解密的文件当中抽取。但是为了能够在最新的固件上面运行程序，还需要破解一个 ECDSA 的数字签名。

### 4. Basic mathematics and binary

ECDSA 算法本质上是对数进行处理，而且只支持整数，不支持浮点数。并且，整数的范围是由签名当中锁采用的位数决定的，更多的位数意味着更大的数字范围，有更高的安全性，因为这会使得“猜”到所使用数学方程当中采用的具体数字变得更难。

在计算机中，是采用比特来表示数据的，一个比特是二进制当中的一位，八个比特表示一个字节。每增加一个比特，科表示的整数范围就可以翻一倍：使用 4 个比特可以表示 0~15，一共 16 个数字；5 个比特可以表示 32 个数字，6 个比特可以表示 64 个数字。一个字节可以表示 256 个数字，32 比特可以表示 4294967296 个数字。通常 ECDSA 总会使用 160 比特，它可以表示相当大的数，最大的数可以有 49 个数字在里面。

另一个需要知道的数组运算是**[模运算](https://zh.wikipedia.org/wiki/%E6%A8%A1%E7%AE%97%E6%95%B8)**，可以简单地说是整数求除之后的余数。例如，`x mod 10`是指 x 除以 10 以后的余数，这个余数总是在 0 和 10 之间（不包括 10），`142 mod 10`的结果是 2。另一个例子，对于`x mod 2`的结果，如果 x 是偶数则结果为 0，如果 x 是奇数则结果为 1。

### 5. The hash

ECDSA 与数据的 SHA-1 哈希一起使用来完成对数据的签名。一个**[哈希](https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A2%BC%E9%9B%9C%E6%B9%8A%E5%87%BD%E6%95%B8)**是作用与数据的每一字节，然后得到一个代替该数据的整数。比如，所有字节所代表的的数值之和可以被认为是一个非常简单的哈希函数。于是，数据发生了任何修改就会使整个哈希发生变化。在 SHA1 哈希算法中，输出结果总是 20 字节，即 160 比特。

同样数据，经过同样的哈希算法，得到的哈希值是相同的。使用这个特性就能验证数据是否被修改或者破坏了：只需要重新计算一遍数据的哈希，跟原始的哈希比较，相同就说明数据正常，否则说明数据已经被篡改了。因

为了便于理解，可以考虑下面的一个例子，设计一个最简单的哈希函数：将所有的数据求和再对 10 取模运算。

* 所有的数据的二进制层面都被作为整数表示。一个文本文件就是一系列的字节，一个字节表示 8 个比特，可以表示 0~255 之间的一个数。因此，如果用一个整数来表示每一个字节，并且将文件的每一个字节所代表的数相加，然后将求和后的结果对 10 取模，将能够得到一个 0~9 之间的数字作为最终的结果哈希。

* 对于相同的数据将总是得到相同的结果，而修改了文件中的一个字节后，重新计算得到的结果将可能会不同。

* 当然，因为这个哈希函数的输出空间只有 0~9 这 10 中可能，可以非常容易的通过修改文件内容获得相同的输出，因为每次修改文件的内容将有 1/10 的概率得到相同的哈希。

这是 SHA1 出来扮演重要角色的地方：SHA1 算法比这个简单的“对 10 取模”的哈希函数要复杂很多，它将给出一个非常巨大的数（160 比特，用湿巾纸表示的话将有 49 位数字），并且随着文件的任何一点微小的变化，就能产生显著的变化。

这个不可预测特性让 SHA1 算法称为一个非常好的哈希算法，非常安全且产生“碰撞(collision)”（两个不同的文件有相同的哈希）的可能性非常低，使得通过伪造数据获得特定的哈希变的不可能。当然，现在有很多其他的哈希算法也有这种特性，比如 SHA256、SHA512，他们具有更好的不可预测特性和更低的碰撞率。

### 6. The ECDSA Equation

那么，ECDSA 到底是如何工作的呢？**[椭圆曲线密码学](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography)**是基于以下形式的方程工作的：

![](http://cnd.qiniu.lin07ux.cn/markdown/1658299960294-b869d320704d.jpg)

首先，需要注意这里有一个取模运算，然后`y`是进行了平方运算。另外，这是一条曲线的方程，而且曲线关于 X 轴对称。这意味着对于所有的`x`坐标（`x`只能取整数），可以得到两个`y`的值：一个正值、一个负值。

取模运算的底是一个**素数**，且确保所有得到的数值在 160 比特所能够表示的范围之内，允许采用**[模平方根](https://en.wikipedia.org/wiki/Quadratic_residue)**和**[模的乘法逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)**来简化运算。

因为以`p`为模的底，这意味着，`y^2`可能的取值在`0~(p-1)`之间，一共有 p 个可能的值空间。不过，因为只能处理整数，只有一部分取值能够满足**[完美平方数](https://zh.wikipedia.org/wiki/%E5%B9%B3%E6%96%B9%E6%95%B0)**（平方根为整数的数）的要求，所以只能在曲线上面得到 N 个可能的点，使其满足全部要求。

因为每一个`x`对应着曲线上的两个点（`y^2`的两个正负平方根），这意味着一共有 N/2 个`x`坐标是有效的。因为整数运算和模运算的存在，这条椭圆曲线上面只有有限个点是符合需求的。

总结一下：ECDSA 方程给出了一条曲线，这条曲线上面一共有 N 个有效的整数点。因为 Y 轴的取值区间由模底`p`来确定，并且需要满足完美平方数、关于 X 轴对称的要求，所以一共有 N/2 个有效的`x`坐标。

### 7. Point addition

关于椭圆曲线需要了解的另外一个事情是**[椭圆曲线点加法](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication)**的表示方法。它是这样定义的：将一个点 P 和另外一个点 Q 相加，将得到点 S。如果从 P 到 Q 画一条线，并延长与曲线相交于第三个点 R，则 R 为 S 的负值（关于 X 轴对称）。在这种情况下，定义`R = -S`来表示 R 在 X
轴上面的对称点。具体可以看下面这张图：

![](http://cnd.qiniu.lin07ux.cn/markdown/1658300963733-4beb2c8fe305.jpg)

这是令`a = -1`和`b = 0`时对应的椭圆曲线，其关于 X 轴对称，`P + Q`是曲线上的点 R 关于 X 轴对称的点，且 R 是从 P 到 Q 连接线与曲线的第三个交叉点。可以看到，P、Q、R 和 S 都是曲线上的点。

### 8. Point multiplication

同样的机制，如果进行`P + P`运算，其结果为经过 P 的切线与曲线的交点关于 X 轴对称的点。于是，`P + P + P`可以看做是`P + P`点于 P 点相加的结果。这就可以用来对**[椭圆曲线点乘法](https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication)**进行定义：`k × p`就是点 P 自身进行 k 次相加。

示例如下两图：

![](http://cnd.qiniu.lin07ux.cn/markdown/1658303430272-3e0d09031e76.jpg)

![](http://cnd.qiniu.lin07ux.cn/markdown/1658303434445-a394a959cc27.jpg)

这里可以看到，两个椭圆曲线和一个用来作切线的点 P，切线与曲线相交于第三点，然后其对称点就是`2P`。接着，画一条连接 2P 点和 P 点的直线，直线与曲线相交的交点的对称点为 3P。可以一直类推下去来完成椭圆曲线乘法。这也是为什么在做加法时需要取 R 的对称点，因为只有这样，才可以避免在做同一点的多次加法的时候得到的是同一条直线和相同的三个点。

### 9. The trap door function

一个椭圆曲线乘法的特性是：知道点`R = k × P`和点 P，但是无法据此求出`k`。因为这里并没有椭圆曲线减法和除法可用，并不能通过`k = R/P`来得到`k`。并且，因为可以做成千上万次加法，最终只是知道在曲线上面结束的点，但是具体是如何到达这个点的并不能知道。

也就是说，椭圆曲线乘法无法进行反向操作，来得到与点 P 相乘后得到点 R 的 k。

这种即便知道原点和终点，但是无法知道被乘数的特性，是 ECDSA 算法背后安全性的所有基础。这一特性也被称为**[单向陷门函数](https://en.wikipedia.org/wiki/Trapdoor_function)**。

### 10. The ECDSA algorithm

现在已经掌握了基础，可以来谈谈实际的 ECDSA 签名算法了。

对于 ECDSA 算法，首先需要选定曲线参数，一共有`a`、`b`、`p`、`N`、`G`五个参数。其中，`a`和`b`是曲线方程的参数（`y^2 = x^3 + a × x + b`），`p`是模运算的底，`N`是曲线上面点的个数，`G`表示在曲线上面所选中的任意一个参考的起始点。

这些曲线参数非常重要，如果不能实现获得它们，先入无法签署和验证一个签名。是的，验证一个签名并不是只需要知道公钥，还需要知道这个公钥是从什么曲线参数推算出来的。

总结一下：首先，生成一对密钥：公钥和私钥。私钥是一个随机数，为 160 比特大小，公钥是将曲线上的点 G 与私钥相乘（椭圆曲线点乘法）以后得到的曲线上的另一个点。令`dA`表示私钥（一个随机数），`Qa`表示公钥，曲线上的一个点，即有`Qa = dA × G`，其中 G 为曲线上的任意一个点。

### 11. Creating a signature

有了私钥和公钥，如何对一个文件或者信息进行签名呢？

首先需要明确，签名本身是 40 字节，由两个 20 字节的值组成，第一个值叫做 R，第二个叫做 S。值对`(R, S)`放到一起就组成了 ECDSA 签名。

然后看看签名时是如何创建这一对值的：

* 产生一个随机数 k，占 20 字节；
* 利用椭圆曲线点乘法计算`P = k × G`；
* 点 P 的 x 坐标即为 R；
* 利用 SHA1 计算数据的哈希，得到一个 20 字节的巨大整数 z；
* 利用方程`S = (k^-1)(z + dA × R) mod p`得到 S。

其中`k`是用来生成 R 的随机数，`k^-1`是 k 的**[模的乘法逆元](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)**。

可以看到，计算签名的时候，主要用到的是私钥和一个随机的数。每次取不同的随机数，得到的签名计算不同的。

### 12. Verifying the signature

计算得到签名之后，可以使用公钥来进行验证，验证的所需的数据就是公钥和导出这个公钥的曲线参数。

验证时，使用如下的方程计算点 P：

```
P = (S^-1) × z × G + (S^-1) × R × Qa
```

如果点 P 的 x 坐标和 R 相等，则意味着这个签名是有效的，否则是无效的。

计算过程很简单，下面来看看如何一步步的从数学上进行推导。

1. 首先，由于`Qa = dA × G`，待入上式可得：

    ```
    P = (S^-1) × z × G + (S^-1) × R × dA × G = (S^-1) × (z + R × dA) × G
    ```

2. 再由点 P 的 x 坐标必须与 R 匹配，且 R 是点`k × P`的 x 坐标，即有：

    ```
    P = R = k × G
          = (S^-1) × (z + R × dA) × G
    ```

3. 同时消掉 G，有：

    ```
    k = (S^-1) × (z + R × dA)
    ```

4. 对两边求逆，即可得到：

    ```
    S = (k^-1) × (z + R × dA)
    ```

最后得到的计算 S 的式子和前面签名时计算 S 的式子相匹配，这就是可以采用本节开头给出的方程进行签名验证的原因。

### 13. The security of ECDSA

可以注意到，需要同时知道随机数 k 和私钥 dA 才能计算出 S，但是验证时则是使用 R 和 Qa 进行。并且，由于`R = k × G`以及`Qa = dA × G`，再加上 ECDSA 点乘法当中的单向陷门函数的特性，是无法通过 Qa 和 R 来逆推出来 dA 或 k 的。

这使得 ECDSA 算法非常安全，在不知道私钥的情况下，是无法伪造签名的。

### 14. The importance of random k

现在来讨论一下索尼 PS3 中使用的 ECDSA 签名是如何以及为什么产生问题的，以及它是如何允许黑客访问 PS3 的 ECDSA 私钥的。

产生签名的两个方程`R = k × G`和`S = (k^-1) × (z + dA × R) mod p`，它们的强势在于实际上有一个方程里面有两个未知数（`k`和`dA`），因此是无法确定其中的任何一个的。

不过，算法的安全是基于其实现的：确保随机数`k`确实是随机产生的非常重要，并且没有人能够猜测、计算或者用其他任何类型的攻击来得到这个随机数。

而索尼在实现中犯了一个巨大的错误：它们在任何地方都采用了同一个随机数，这就使得每个签名都有一个相同的 R。这意味着，可以使用两个分别具有散列值`z`和`z′`的数据，和它们的签名`S`和`S′`来计算随机数 k：

```
S - S′ = (k^-1) × (z + dA × R) - (k^-1) × (z′ + dA × R)
       = (k^-1) × (z + dA × R - z′ - dA × R)
       = (k^-1) × (z - z′)
```

于是就有：

```
k = (z - z′)/(S - S′)
```

一旦知道了随机数 k，求解 S 的方程就变成了只含有一个未知数的方程了，然后利用这个方程就能很容易的解出`dA`了：

```
dA = (S × k - z) / R
```

而一旦知道了私钥 dA，那么就能够签名自己的文件，并使得 PS3 认为它是一个由索尼签署的官方文件。这就是为什么 ECDSA 重要的是要确保用于生成签名的随机数实际上是“加密随机的”。

从 3.56 版本以来，索尼已经修复了他们的 ECDSA 的实现和使用，并使用了新的密钥对，现在不可能这么容易的找到私钥了。

这个问题的另一个例子是：一些比特币客户使用非加密随机数生成器（在一些浏览器和一些 Android 客户端上），导致他们以相同的随机数 k 来签署交易，恶意用户能够据此找到他们的比特币钱包的私钥，并窃取他们的资金。

这表明了每次签名时使用真正随机数的重要性，因为如果`(R, S)`签名对的 R 值在两个不同签名上相同，则会暴露私钥。当然，只要实现是正确合理的，ECDSA 算法非常安全，就不轻易的被找到私钥。

### 15. Conclusion

经过这番讲解，这个算法仍然很复杂、很难理解，无法用任何简单的术语进行解释。

但是，对于一个开发人员或者数学家，或者有兴趣学习这方面的知识，那么这些信息能够提供足够的帮助，让人能够得到一些简单的概念和原理知识，或者至少能够理解这个名为 ECDSA 的未知野兽背后的概念。

本文中的一些图片来自于 Avi Kak 解释 ECDSA 背后的[数学的论文](https://engineering.purdue.edu/kak/compsec/NewLectures/Lecture14.pdf)。


