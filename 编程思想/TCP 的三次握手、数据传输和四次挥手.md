> 转摘：[【图文讲解】TCP为啥要3次握手和4次挥手？握两次手不行吗？](https://mp.weixin.qq.com/s/tP5yOBwtc3cN9sJOYqw_Dw)

TCP 连接在建立和断开的过程中，会涉及到 SYN(建立连接)、ACK(确认)、PSH(传送)、FIN(结束)、RST(重置)、URG(紧急)。下面对 TCP 的三次握手和四次挥手的流程进行剖析说明。

## 一、三次握手

TCP 在建立连接的时候，会在客户端和服务器端进行的三次交互，握手流程如下图所示：

![TCP 三次握手流程](http://cnd.qiniu.lin07ux.cn/markdown/1572320005637.png)

其中，客户端是指发起建立 TCP 请求的主机，而服务器端则指要建立连接的目标主机。

### 1.1 第一次握手

客户端向服务器发出连接请求报文，报文首部中的同步位`SYN = 1`，同时随机生成初始序列号`seq = x`。这是三次握手的开始，表示客户端想要和服务器端建立连接。

在发出这个报文后，TCP 客户端进程进入了 SYN-SENT(同步已发送)状态。

TCP 规定，SYN 报文段(`SYN = 1`的报文段)不能懈怠数据，但需要消耗掉一个序号。

### 1.2 第二次握手

服务器端收到客户端发来的 SYN 请求报文后，如果同意连接，则发出确认报文。

确认报文中标志设置为：`ACK = 1`、`SYN = 1`、`ack = x + 1`、`seq = y`。其中`ack`为确认号，`seq`为随机初始化的一个服务器端的序列号。

这个报文不能携带数据，但是同样要消耗一个序号。而且这个报文带有 SYN(建立连接)和 ACK(确认)标志，询问客户端是否准备好。

> 序列号的作用是为了让对方确认已收到己方发送的报文的序列，确保报文按顺序到达。

发送完确认报文后，服务器进程就进入了 SYN-RCVD(同步收到)状态。

### 1.3 第三次握手

客户端进程收到确认报文后，还要向服务器端也发送一个确认报文，用来确认已收到服务器端的确认报文。

确认报文的标志设置为：`ACK = 1`、`ack = y + 1`。表示客户端已经准备好了。

TCP 规定，客户端发出的这个 ACK 报文可以携带数据，但是如果不携带数据则不消耗序号。

发送完这个确认报文后，客户端进入 ESTABLISHED(已建立连接)状态。

### 1.4 TCP 为什么需要三次握手？两次不行吗

**三次握手是为了避免客户端的请求已失效而造成服务器端资源浪费。**

假如客户端发送了第一个请求建立连接的报文，但是由于网络延迟，这个请求在网络节点中滞留了一段时间之后才打到服务器端。由于请求时间过程，客户端以认为这个请求是失效的了，但是服务器端接收到这个报文之后，还是会向客户端发出确认请求的报文，表示同意链接。

此时，如果不采用三次握手，那么只要服务器端发出确认请求报文，新的 TCP 连接就建立了，但其实由于客户端的请求报文失效，所以客户端是不会理睬这个确认报文的，也不会向服务器发送确认建立请求的报文了。另一方面，服务器端则认为连接已建立，就会一直等待客户端发来数据。这样服务器端的很多资源就被浪费掉了。

采用三次握手就是为了防止这种情况的发生：服务器端会因为收不到客户端的确认报文而认为连接没有建立，就不会长时间等待数据而浪费资源了。

## 二、数据传输

### 2.1 正常传输

建立了 TCP 连接之后，两台主机之间就可以相互传输数据了。传输流程如下图所示：

![TCP 数据传输流程](http://cnd.qiniu.lin07ux.cn/markdown/1572334339724.png)

具体步骤如下：

1. 主机 A 初始 seq 为 1200，滑动窗口大小为 100，然后向主机 B 发送数据。
2. 主机 B 成功接收数据后，向主机 A 发送 ACK 包来确认已收到数据，并将 ack 号设置为 1301，表示 A 主机下次发送的数据序号。
3. 主机 A 获得 B 传来的确认报文后，读取 ack 号(1301)，然后开始继续发送 seq 为 1301 的 100 字节的数据。

> 数据完全接受成功时，ACK 确认报文中 ACK 号的计算规则为：`ack = seq + 传输的字节数 + 1`。与三次握手协议相同，最后加 1 是为了告诉对方要传递的 seq 号。

### 2.2 丢包处理

当传输过程中出现丢包时，处理过程如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1572334736827.png)

上图表示通过`seq = 1301`数据包向主机 B 传递 100 字节的数据，但中间发生了错误，主机 B 未收到。

经过一段时间后，主机 A 仍未收到对于`seq = 1301`的 ACK 确认报文，就会尝试重传这段数据。

> 为了完成数据包的重传，TCP 套接字每次发送数据包时都会重启定时器，如果在一定时间内没有收到目标机器传回的 ACK 包，那么定时器就会超时，数据包将被重传。

## 三、四次挥手

TCP 连接可以由任意一方决定断开。断开 TCP 连接时，需要经过如下图所示四个步骤，被称为四次挥手：

![](http://cnd.qiniu.lin07ux.cn/markdown/1572335025918.png)

其中，发起断开连接的一方被称为客户端，而 TCP 连接的另外一方被称为服务器端。

### 3.1 第一次挥手

客户端发送一个 FIN(结束)报文，用来关闭与服务器端的 TCP 连接。

释放连接报文中标识设置为：`FIN = 1`、`seq = u`。其中 seq 序号的值等于前面已经传送过的数据的最后一个字节的序号加 1。

TCP 规定，FIN 报文段即使不携带数据，也需要消耗一个序号。

发送完释放报文后，客户端就进入了 FIN-WAIT-1(终止等待 1)状态。此后，客户端除了 ACK 应答报文外，不能发送其他报文，也不能再传递其他数据。

### 3.2 第二次挥手

服务器端收到 FIN 报文后，就立即返回一个 ACK 确认报文，确认收到该终止报文。

确认报文的标识设置为：`ACK = 1`、`ack = u + 1`、`seq = v`。其中 seq 序号的值 v 为服务器端发送数据的序号。也可以理解为，这次的确认报文和之前的数据传输确认报文一样。

发送这个确认报文后，服务器端就进入了 CLOSE-WAIT(关闭等待)状态，TCP 服务器通知高层应用进程，客户端向服务器的方向已释放了，整个 TCP 连接处于半关闭状态，即：客户端已经没有数据要发送了，但是服务器端如果要继续发送数据，客户端依然要接受。

客户端接收到这个确认报文之后，客户端就进入了 FIN-WAIT-2(终止等待 2)状态，等待服务器端发送链接释放报文(在这段时间内，还要继续接受服务器端发送过来的数据)。

### 3.3 第三次挥手

服务器端在将数据都发送完成之后，就可以发送一个 FIN(结束)报文给客户端，来关闭服务器端到客户端的连接。

FIN 报文的标识设置为：`FIN = 1`、`ack = u + 1`、`seq = w`。由于服务器端在接受到客户端发来的 FIN 报文后，还有可能需要继续向客户端发送数据，所以这里的 seq 序号的值可能会有所变化。

服务器发送完 FIN 报文后，就进入了 LAST-ACK(最后确认)状态，等待客户端的确认。

### 3.4 第四次挥手

客户端接收到服务器端的 FIN 报文后，需要发送回一个 ACK 确认报文，确认关闭整个 TCP 连接。

ACK 报文的标识设置为：`ACK = 1`、`ack = w + 1`、`seq = u + 1`。

发送完这个报文后，客户端就进入了 TIME-WAIT(时间等待)状态。此时 TCP 连接还没有被释放，必须要经过 2 * MSL(最长报文段寿命)的时间后，客户端撤销相应的 TCB 才进入 CLOSED 状态。

而服务器端只要收到了客户端发出的确认，就立即进入 CLOSED 状态，不需要发送其他报文了。同样，服务器端撤销 TCB 后，就结束了这个 TCP 连接。所以服务器端结束 TCP 连接的时间比客户端要早一些。

### 3.5 为什么需要完整的 4 次挥手才能释放连接？

**四次挥手是为了确保数据能够完成传输。**

由于 TCP 连接的任意一方都能发起关闭 TCP 的请求，所以当收到对方发送的 FIN 报文时，仅仅表示对方没数据发送给己方了，但未必己方所有的数据也都发送给对方了。所以整个关闭过程需要双方都给对方发送 FIN 报文，并接收到对方相应的 ACK 确认报文才能关闭。

同样，关闭连接时，由于服务器端可能还有数据需要发送，所以在接收到客户端的 FIN 报文时，只会先回复一个 ACK 报文，表示已经接收到对方的 FIN 报文了。当服务器端将全部的数据都发送完成之后，才能再发送 FIN 报文给客户端。而不能像建立 TCP 链接时一样，将 ACK(确认) 和 SYN(建立连接)一起发送。

### 3.6 未正常关闭连接时客户端突然挂掉怎么办？

正常连接时，由于一些问题，客户端可能会突然挂掉，而没能正常的关闭 TCP 连接。如果没有合适的措施，那么客户端和服务器端就会出现长时期的空闲，浪费资源。

为了解决这种情况，服务器端设置了保活计时器和超时时间(通常为 2 小时)。每当服务器收到客户端的消息时，就将计时器复位。而如果超过超时时间依旧没有接收到客户端的消息，服务器就会间隔 75 秒发送一次探测报文段。如果发送了 10 个探测报文段还没有响应，就认为客户端除了故障，因而终止该连接。

## 四、其他

### 4.1 SYN 洪水攻击

**背景**

当初始化连接时，服务器端发送的第二次握手报文 SYN-ACK 一直没有接收到客户端的 ACK 确认，这时候这个连接既没有建立起来，也不能算是建立失败。

这个未成功也未失败的连接在被服务器端断开之前，会一直占用服务器端的 SYN 连接队列中的一个位置。如果出现大量的这样的连接就会让服务器端的 SYN 连接队列耗尽，让正常的链接无法得到处理。

为了避免这个问题，需要在服务器端设置一个超时时间来结束这样的连接。

目前 Linux 默认会对这样的连接进行 5 次 SYN-ACK 报文的重发，重试的间隔从 1s 开始，每次翻倍。5 次的重试时间间隔就为 1s、2s、4s、8s、16s，总共 31s。而且第 5 次发出后，还要等待 32s 来确认超时。所以，Linux 会需要 1s + 2s + 4s + 8s + 16s + 32s = 63s 的时间才会将这样的 TCP 连接断开。

**什么是 SYN 攻击**

由于 SYN 超时需要 63s，就让攻击者可以用来攻击服务器，在短时间内伪造大量不存在的 IP 地址向服务器端发送大量的 SYN 包(俗称 SYN Flood 攻击)，用于耗尽服务器端的 SYN 队列。

由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的 SYN 包将长时间占用未连接的 SYN 队列，导致正常的 SYN 请求被丢弃，使得目标服务运行缓慢，严重者会引起网络堵塞直至系统瘫痪。

SYN 攻击是一种典型的 DoS 攻击。

**如何检测 SYN 攻击**

检测 SYN 攻击非常方便，当在服务器上看到大量的处于半连接状态的 TCP 连接，特别是源 IP 地址是随机的，基本上可以断定这是一次 SYN 攻击。

在 Linux/Unix 系统上可以使用系统自带的 netstats 命令来检测 SYN 攻击。

**如何防御 SYN 攻击**

SYN 攻击不能被完全阻止，除非将 TCP 协议重新设计。但是可以尽可能的减轻 SYN 攻击的危害。

常见的防御 SYN 攻击的方法有如下几种：

* 缩短 SYN 超时时间(SYN Timeout)
* 增加最大半连接数
* 过滤网关防护 SYN
* cookies 技术

### 4.2 TCP 和 UDP 的区别

TCP 和 UDP 的区别主要有如下几种：

1. 基于连接和无连接：TCP 的基于连接的，而 UDP 是无连接的，也就是发送数据之前不需要建立连接；

2. 数据正确性：TCP 保证数据的正确、有序性，而 UDP 则不保证数据都能正确达到，也不保证数据到到的顺序。

    也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。TCP 通过校验和、重传控制、序号标识、滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。

3. 时效性：UDP 具有较好的实时性，工作效率比 TCP 高，适用于对告诉传输和实时性有较高要求的通信情景。

4. TCP 连接是点对点的，只能一对一传输数据；UDP 支持一对一、一对多、多对一和多对多的交互通信。

5. TCP 对系统资源的要求较多，UDP 对系统资源要求较少。


