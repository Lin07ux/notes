> 转摘：
> 
> 1. [算法-求二进制数中1的个数](https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html)
> 2. [Population Count算法](https://gaomf.cn/2016/02/24/Population_Count/)

计算数字二进制表示中 1 的数量，在数学上被称为计算汉明重量。

> 下面的算法都假设数据是 32 位无符号数值。

### 0. 直接算法

利用定位累加方式，依次获取数值的每一位值，如果结果大于 0 则加 1，否则不增加累加器。最终遍历完数值的每一位之后，累加器的值就是数值中 1 的数量了。

```JavaScript
function hammingWeight (number) {
    let count = 0;

    for (let i = 0; i < 32; i++) {
        count += number & (1 << i);
    }
    
    return count;
}
```

使用这种方式进行遍历，则每次都需要循环数值的二进制位数，无论数值的大小。

### 1. 改进直接算法

在直接算法中，并不一定都需要遍历每一位是否为 1。因为当一个数为 0 时，它包含的 1 的位数也为 0，不需要继续遍历了。

结合这种情况，可以得到如下改进算法：

```JavavScript
function hammingWeight (number) {
    let count = 0;

    for (; number != 0; number >>= 1) {
        count += number & 1;
    }
    
    return count;
}
```

这个算法的循环次数与首位 1 的位置有关，最优情况下只循环一次，最坏情况下循环 N 次。

### 2. 查表法

查表法的思想就是针对一个 8bit 的数字（表示 0~255 这 256 个数值），列举出每一个数值对应的 1 的位数，然后将要统计的原数据按照每 8bit 划分为一组，依次去查表得到对应的 1 的位数，然后累加这些数量即为要统计的 1 的位数。

查表法有动态建表法和静态查表法，他们的区别在于每个数值对应的 1 的位数的表是初始化的时候就写定的，还是由程序自动生成的。而在得到对应表之后的查表逻辑就相同了。

动态建表的方法就是在运行的时候生成 0~255 数值的二进制表示中 1 的位数表。

```JavaScript
function hammingWeight (number) {
    let count = 0;
    let bitSetTable256 = [0];
    
    for (let i = 0; i < 256; i++) {
        bitSetTable256[i] = (i & 1) + bitSetTable256[i>>1];
    }

    for (; number != 0; number >>= 8) {
        count += bitSetTable256[number & 0xff];
    }
    
    return count;
}
```

这里的核心就是构建表的过程，其原理是数字的奇偶性和其二进制表示中对应的 1 的位数的关系。对于任意一个正整数 n：

1. 如果它是偶数，那么 n 的二进制中的 1 的个数与 n/2 中 1 的个数是相同的。因为偶数的最后一位必然是 0，所以 n 右移一位时会将最后一位 0 给去掉，并不会影响其 1 的个数；
2. 如果它是奇数，那么 n 的二进制中 1 的个数必然会比 n/2 中的 1 的个数大 1。因为奇数的最后一位必然是 1，所以 n 右移一位后会去掉最后一位的 1，使得 1 的位数少 1 了；
3. 综上，每个数的二进制中 1 的位数是右移 1 位之后的 1 的位数，再加上其最末位的值（1 或者 0）。据此进行迭代，即可生成 0~255 个数的二进制中的 1 的位数。
4. 注意：需要将数字 0 的二进制中 1 的个数先初始化为 0。

完成建表之后，就可以对原数据每 8 位进行一次查表计算，并累积每 8 位中的 1 的位数。

静态表则是在直接将 0~255 这些数值对应的 1 的位数初始化到数组中，而后续的查找就和动态建表法一样了。

### 3. 逐位清除法

> 参考：[二进制数中 1 的个数](https://real-neo.me/number-of-1-bits.html)

知识点：**`n & (n - 1)`可以消去二进制数的最右边的 1**。

比如，对于数字`n = 189`，其二进制表示为`1011 1101`，那么`n - 1`的值用二进制表示就是`1011 1100`，所以`n & (n - 1)`的结果就是`(1011 1101) & (1011 1100) = 1011 1100`。这和`n`的二进制表示相比，只有最后的一个非 0 位不相同了。也就是说`n & (n - 1)`消去了数值 n 的最后一个 1 位。

使用上面的知识点，将数值位的 1 一个个的消除掉，那么数值就变成 0 了，统计消除操作的次数即可得到该数值的二进制表示中总共有多少个 1 了。

需要注意的地方在于：计算机中，负数一般使用的是相应正数的补码表示。如果要统计一个正数的实际底层二进制表示中有多少个 1，使用上面的方式即可；否则就需要考虑先将数值转成对应的正数表示再进行统计。

JavaScript 代码实现如下：

```JavaScript
function hammingWeight (number) {
    let count = 0;
    
    // 对于数字 -7，加这一步时结果为 7，不加这一步则为 30
    number = Math.abs(number)
    
    while (number) {
        number &= (number - 1);
        count++;
    }
    
    return count;
}
```

使用这种方式一般情况下可以比循环判断每个二进制位是否为 1 高效，但是如果二进制位全为 1 的时候，这样与循环判断一样，需要循环数值的位数次了。

### 4. 分治

> 转摘：[LeetCode 每日一题 191. 位1的个数](https://zhuanlan.zhihu.com/p/37623166)

利用分治算法，先将数值的二进制分为两两一组，分别计算每一组的和，然后再将计算的结果再次两两分组，继续计算，最终得到的一组结果即是该数值的汉明重量了。

计算代码如下：

```JavaScript
function hammingWeight (n) {
    n = (n & 0x55555555) + (n >> 1 & 0x55555555);
    n = (n & 0x33333333) + (n >> 2 & 0x33333333);
    n = (n & 0x0f0f0f0f) + (n >> 4 & 0x0f0f0f0f);
    n = (n & 0x00ff00ff) + (n >> 8 & 0x00ff00ff);

    return (n & 0x0000ffff) + (n >> 16 & 0x0000ffff);
}
```

比如，计算数值 211 的汉明重量。211 的二进制表示为`1101 0011`，那么使用分治方式时就是如下的计算过程：

![](http://cnd.qiniu.lin07ux.cn/markdown/1575462403825.png)

* 第一次：把每相邻的两位加起来，得到每两位里 1 的个数，比如前两位的计算结果`10`就表示原数的前两位有 2 个 1。
* 第二次：继续两两相加，`10+01=11`，`00+10=10`，得到的结果是`0011 0010`，它表示原数前 4 位有 3 个 1，末 4 位有 2 个 1。
* 最后一次：把`0011`和`0010`加起来，得到的就是整个二进制中 1 的个数。

程序中巧妙地使用取位和右移，比如第二行中`0x33333333`的二进制为`00110011001100110011001100110011`，用它和 n 做逻辑与运算就相当于以 2 为单位间隔取数。

### 5. 完美法

这种算法是实现代码是最简洁的，只是因为有一个取模运算，所以可能会慢一些：

```JavaScript
function hammingWeight (n) {
    let temp = n - ((n>>1) & 033333333333) - ((n>>2) & 011111111111);
    
    return ((temp + (temp>>3)) & 030707070707) % 63;
}
```

这个算法的代码虽然简洁，但是却不太好理解。下面进行解释说明：

> 以`0`开头的是八进制数，以`0x`开头的是十六进制数。这段代码中使用了 3 个八进制的数。

1. 第一行代码主要就是将数值 n 的二进制表示按照每组 3bit 进行分组，求出每一组中的 1 的个数，然后再表示成二进制形式。

    而求出每组的 3bit 中的 1 的个数，需要根据这 3bit 数据的特性进行计算。
    
    因为 3bit 的二进制能表示的十进制数的范围是 0~7 这 8 个数字，对于从高到低每位依次为`a`、`b`、`c`的 3bit 二进制数字来说，其十进制值可以表示为`4a + 2b + c`，而其中 1 的位数则可以表示为`a + b + c`。
    
    通过一些观察和比较可以发现：`a + b + c = (4a + 2b + c) - (2a + b) - a`，而：
    
    * `4a + 2b + c`右移一位即为`2a + b`；
    * `4a + 2b + c`右移两位即为`a`。

    所以，第一行代码就能计算出将 n 按照每 3bit 一组分组后，每组二进制表示中的 1 的位数。
    
    比如，对于`n=50`的情况，其二进制表示为`110010`，分组后就是`110`和`010`。通过第一行代码即可得到：`temp = 50 - 25(011001&011011) - 8(001100&001001) = 17`。
    
2. 第二行代码则对第一行的结果中相邻两组中 1 的个数累计，并去除重复计算的组，对结果进行修正。

    因为每 3bit 中 1 的个数最多只有 3 个，所以经过第一行的处理，`temp`的二进制表示中，从右侧起每相邻的 3bit 只有四种可能，即：`000`、`001`、`010`、`011`。所以将相邻的两组 3bit 相加，最大只有 6，不足 8，依旧能用 3bit 来表示。

    `temp + temp>>3`是为了将相邻的两组 3bit 中的 1 的个数相加，但是这样会造成中间一部分的 3bit 分组会被重复相加。比如，当`temp = 659`时：
    
    * `temp    = 001 010 010 011`
    * `temp>>3 = 000 001 010 010`

    `temp + temp>>3`的结果为`001 011 100 101`，而`001 010 010`这三组是被重复计算到结果中了。
    
    进行`&030707070707`计算的时候，会将中间结果从右侧开始开始，每隔三位删除三位，这样就能消除重复累计进去的结果。
    
    因为上面计算后相当于得到每相连的 6bit 中的中 1 的个数，最多只会为`111 111`，也就是十进制的 63。所以还需要将结果对 63 取模来修正结果。

### 6. 指令法

现代很多 CPU 会提供指令级别的汉明重量计算方式，使用这些指令即可实现 1 的个数的统计。

在 Intel x86 中，如果 CPU 支持 SSE4 指令集，就可以使用`POPCNT`指令来计算二进制数中 1 的个数。这是一个单周期指令，所以效率非常高。

在 MSVC 下，可以通过`_mm_popcnt_u32()`函数来调用`POPCNT`指令，比如：

```c
#include <nmmintrin.h>

Count = _mm_popcnt_u32(num);
```

在 GCC 下，可直接调用`__builtin_popcountll()`函数，编译时加上编译选项`-mpopcnt`即可。


