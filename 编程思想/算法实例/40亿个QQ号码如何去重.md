> [腾讯三面：40亿个QQ号码如何去重？](https://mp.weixin.qq.com/s/6Z9frE6BgT_ztiO1kgTNCw)

需求如下：

> 文件中有 40 亿个 QQ 号码，请设计算法对 QQ 号码去重，相同的 QQ 号码仅保留一个，内存限制 1G。

## 一、解决方法

### 1.1 方法一：排序

最简单的方法，对所有的 QQ 号码进行排序，这样相同的 QQ 号必然是相邻的，保留第一个，去除后续重复的就可以了。

这个方法会因为排序的时间复杂度太大而没有实际意义。

### 1.2 方法二：Hash Map

将 QQ 号 Hash 之后的值作为 Key，QQ 号作为值，记录到 Hash Map 中。利用 Hash Map 天然的去重特性就可以得到去重后的结果了。

这个方法会因为占用内存空间超过 1G 而无法达到要求。

### 1.3 方法三：文件切割

显然，这是海量数据的问题，可以考虑使用文件切割的方式避免内存过大。

文件切割之后，要么使用文件间的归并排序，要么使用过桶排序，反正最终是能够排序的。排序之后就可以进行去重了。

但是由于有较多的文件操作，效率并不高，难以实际使用。

### 1.4 方法四：BitMap

可以将前面的 Hash Map 转换为 BitMap，这样可以同时解决时间问题和空间问题。

对于一个 unsigned char 类型，有 8 位，取值范围是`[0, 255]`。如果这个 unsigned char 的值是 255，它能标记 0~7 这些数字都存在；如果它的值是 254，则表示 1~7 这些数字是存在的，而数字 0 是不存在的。

以此类推：

* 一个 unsigned int 类型数据可以标识 0~31 这 32 个整数的存在与否。
* 两个 unsigned int 类型数据可以标识 0~63 这 64 个整数的存在与否。

QQ 号码的理论最大值为 2^32 - 1，大概是 43 亿左右。显然，可以推导出来，512MB 大小足够标识所有 QQ 号码。

所有，使用 BitMap 来代替 HashMap，即实现了去重，也能占用很少的内存。 
## 二、扩展

### 2.1 扩展练习一

*文件中有 40 亿个互不相同的 QQ 号码，请设计算法对 QQ 号码进行排序，内存限制 1G。*

显然，直接使用 BitMap 来进行存储，然后从小到大遍历正整数即可：当 BitMap 该位的值为 1 时就输出该值，输出后的正整数序列就是排序后的结果。

注意：这里必须限制 40 亿个 QQ 号码互不相同，否则会由于 BitMap 的去重特性造成 QQ 号码的丢失。

### 2.2 扩展二

*文件中有 40 亿个互不相同的 QQ 号码，求这些 QQ 号码的中位数，内存限制 1G。*

依旧使用 BitMap 即可。

### 2.3 扩展三

*文件中有 40 亿个互不相同的 QQ 号码，求这些QQ号码的 top-K，内存限制 1G。*

使用 BitMap。

### 2.4 扩展四

*文件中有 80 亿个 QQ 号码，试判断其中是否存在相同的 QQ 号码，内存限制 1G。*

使用 BitMap 也是能实现的。但是因为 QQ 号码的个数是 43 亿左右（理论值 2^32 - 1），所以 80 亿个 QQ 号码必然存在相同的号码，并不需要其他的判断。


