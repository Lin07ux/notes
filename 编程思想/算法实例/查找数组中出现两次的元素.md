> 转摘：[一道让你拍案叫绝的算法题](http://www.cnblogs.com/fivestudy/p/10275446.html)

### 1. 初级题

**题目**

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

**要求**

算法应该具有线性时间复杂度，并且不使用额外空间来实现。

**示例**

* 输入`[2, 2, 1]`，输出`1`
* 输入`[4, 1, 2, 1, 2]`，输出`4`

**解决**

由于限定具有线性时间，而且不使用额外的空间，那就说明不能对数组进行排序或者循环一类的操作。

解题的关键在于这是一个*非空整数*数组，而且只有一个元素出现一次，其他都是两次。也就是说，数组里面的数字都是整数，而且基本都是成双成对的出现。而对于两个一样的数字，将其按位进行异或运算的结果总是 0。所以，这道题的解决方式是**位异或操作**。

> 异或操作：当两个操作位相同时，得到 0，不同时，得到 1。

将全部元素进行异或操作，即`a[1] ⊕ a[2] ⊕ a[3] ⊕ …⊕ a[n]`，所得的结果就是那个只出现一次的数字，时间复杂度为 O(n)。

<img src="http://cnd.qiniu.lin07ux.cn/markdown/6rAnaqI.gif"/>

### 2. 进阶题

给定一个非空整数数组，除了某两个元素只出现一次以外，其余每个元素均出现两次。找出那两个个只出现了一次的元素。

**要求**

算法应该具有线性时间复杂度，并且不使用额外空间来实现。

**示例**

* 输入`[1, 2, 2, 1, 3, 4]`，输出`[3, 4]`

**解决**

同样，由于限制条件在，依旧是需要考虑使用异或操作。但是这次是有两个只出现了一次的元素。解题的关键则在于这两个只出现一次的元素是互不相同的这个隐藏条件(如果这两个元素也相同，那么就没有只出现一次的元素了)。

因为这两个只出现一次的元素一定是不相同的，所以这两个元素的二进制形式肯定至少有某一位是不同的，即一个为 0，另一个为 1。也就是说，全部元素都进行异或计算之后，最终的结果必然不为 0。按照如下的步骤进行操作：

* 在全部数组元素的最终的异或结果中，找到不为 0 的那个位的位置
* 将那个位置不为 0 的数组元素分为一组，为 0 的分为另一组
* 将这一位为 0 的所有元素做异或，得出的数就是只出现一次的数中的一个
* 将这一位为 1 的所有元素做异或，得出的数就是只出现一次的数中的另一个

<img src="http://cnd.qiniu.lin07ux.cn/markdown/7ZzUZz7.gif"/>


