对于一个整数，要找到二进制表示中的最低 1 的位置，可以使用按位遍历的方式，但是这样的话时间复杂度是`O(n)`，性能上有提升的空间。

利用`x & ~(x - 1)`可以将时间复杂度为减小到`O(1)`。

对于一个二进制数字 x，将其值减 1 会影响 x 中最后一个 1 位及其之后的位。再对`x - 1`的值取反之后，其结果就会与`x`的值仅有最低 1 的位相同，而其他位都相反。

比如，`x = 56`：

* `x`其二进制为`00111000`，`x - 1`的二进制表示就是`00110111`。可以看出`x - 1`的值和`x`的值的二进制表示中，高位的 0 和 1 位相同，仅`x`的最后一个 1 及其之后的位发生了变化。
* 此时再对`x - 1`取反，得到`11001000`，这个结果与`x`的二进制表示中，仅有第五位相同，其他的位都相反。
* 将`x`与`~(x - 1)`做位与操作，就可以得到`x`的最后一位了。

JavaScript 的实现代码如下：

```JavaScript
function lowBit (x) {
    return (x & ~(x - 1)) >> 1;
}
```

