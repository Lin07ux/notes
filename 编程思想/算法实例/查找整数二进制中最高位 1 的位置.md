> 转摘：[我眼中的 Nginx（一）：Nginx 和位运算](http://www.cnblogs.com/upyun/p/10455087.html)

寻找一个整数的二进制表示中的 1 的最高位的位置，有实际的使用意义，比如在设计一个 best-fit 的内存池的时候，需要找到一个比用户期望的 size 大的第一个 2 的幂次。

虽然用循环遍历的方式也可以得到结果，不过这个效果并不好，可以使用更好的位运算来实现。

> Intel CPU 指令集有一条指令可以直接计算一个数二进制里最高位为 1 的位置。

可以利用位运算将整数中的每一位都与其前面的所有位进行或运算，从而使得整数中从第一位为 1 开始所有的位都全部设置为 1。然后将这个结果除第一个 1 位之外的位全都设置为 0，即可得到最高值为 1 的位对应的值了。

JavaScript 实现的代码如下：

```JavaScript
// x 假设为 64 位无符号整数
function bsf (x) {
    x |= x >> 1;
    x |= x >> 2;
    x |= x >> 4;
    x |= x >> 8;
    x |= x >> 16;
    x |= x >> 32;
    
    return (x - (x >> 1)) >> 1;
}
```

这里`x |= x >> n`步骤执行的次数与 x 的位数相关，假设 x 的位数为 m，则执行次数应该为`log2(m)`。比如，8 位数值需要执行 3 次，16 位数值需要执行 4 次，32 位数值需要执行 5 次。而且每次执行的移位的位数为`2 ^ (n - 1)`，其中 n 为当前执行的第几次。

下面用 8 位数值来说明。设一个数 A，它的二进制如下所示：

```
A[7] A[6] A[5] A[4] A[3] A[2] A[1] A[0]
```

8 位数值需要执行三次`x |= x >> m`。

第一次执行`x |= x >> 1`，结果为：

```
A[7] A[6] A[5] A[4] A[3] A[2] A[1] A[0]
0    A[7] A[6] A[5] A[4] A[3] A[2] A[1]
---------------------------------------
A[7] A[7]|A[6] A[6]|A[5] A[5]|A[4] A[4]|A[3] A[3]|A[2] A[2]|A[1] A[1]|A[0]
```

第二次执行`x |= x >> 2`，结果为：

```
A[7] A[7]|A[6] A[6]|A[5] A[5]|A[4] A[4]|A[3] A[3]|A[2] A[2]|A[1] A[1]|A[0]
0    0         A[7]      A[7]|A[6] A[6]|A[5] A[5]|A[4] A[4]|A[3] A[3]|A[2]
--------------------------------------------------------------------------
A[7] A[7]|A[6] A[7]|A[6]|A[5] A[7]|A[6]|A[5]|A[4] A[6]|A[5]|A[4]|A[3] A[5]|A[4]|A[3]|A[2] A[4]|A[3]|A[2]|A[1] A[3]|A[2]|A[1]|A[0]
```

第三次执行`x |= x >> 4`，结果为：

```
A[7] A[7]|A[6] A[7]|A[6]|A[5] A[7]|A[6]|A[5]|A[4] A[6]|A[5]|A[4]|A[3] A[5]|A[4]|A[3]|A[2] A[4]|A[3]|A[2]|A[1] A[3]|A[2]|A[1]|A[0]
0    0         0              0                   A[7]                A[7]|A[6]           A[7]|A[6]|A[5]      A[7]|A[6]|A[5]|A[4]
--------------------------------------------------------------------------------------------------------
A[7] A[7]|A[6] A[7]|A[6]|A[5]  A[7]|A[6]|A[5]|A[4] A[7]|A[6]|A[5]|A[4]|A[3] A[7]|A[6]|A[5]|A[4]|A[3]|A[2] A[7]|A[6]|A[5]|A[4]|A[3]|A[2]|A[1] A[7]|A[6]|A[5]|A[4]|A[3]|A[2]|A[1]|A[0]
```

最终得到的结果中，最高位为`A[7]`，次高位为`A[7]|A[6]`，第三位是`A[7]|A[6]|A[5]`，最低位`A[7]|A[6]|A[5]|A[4]|A[3]|A[2]|A[1]|A[0]`。

假设最高位的 1 是在第 m 位（从右向左算，最低位称为第 0 位），那么此时的低 m 位都是 1，其他的高位都是 0。也就是说，最终得到的结果将会是 2 的某幂再减一，于是最后一步`input - (input >> 1)`的用意也就非常明显了，即将除最高位以外的 1 全部置为 0，得到的就是原来的 x 里最高位 1 的对应幂了。

