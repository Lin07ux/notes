> 转摘：[面试如果你这样回答“什么是线程安全”，面试官都会对你刮目相看](http://netsecurity.51cto.com/art/201905/596333.htm)

线程安全不是指线程的安全，而是指内存的安全，更准确的说法应该是数据的安全。

在每个进程的内存空间中都会有一块特殊的公共区域，通常称为堆(内存)。由于线程是从属于进程的，所以进程内的所有线程都可以访问到该区域，这就是造成问题的潜在原因。

假设某个线程把数据处理到一半，需要等待别的资源，然后接着处理，却发现数据已经被修改了，不是之前的结果了，可能被其它线程修改了。

这就是公共数据容易出现的线程安全。所以线程安全指的是，在堆内存中的数据由于可以被任何线程访问到，在没有限制的情况下存在被意外修改的风险。即堆内存空间在没有保护机制的情况下，对多线程来说是不安全的地方，因为放进去的数据，可能被别的线程“破坏”。

为了实现线程安全，可以有如下一些方式。

### 私有数据

既然公共内存数据容易被别的线程查看和修改，那么自然就会考虑把数据放在线程自身的空间中。操作系统会为每个线程分配属于它自己的内存空间，通常称为栈内存，其它线程无权访问，这也是由操作系统保障的。

如果一些数据只有某个线程会使用，其它线程不能操作也不需要操作，这些数据就可以放入线程的栈内存中，较为常见的就是局部变量：

```java
double avgScore(double[] scores) {
    double sum = 0;
    
    for (double score : scores) {
        sum += score;
    }

    int count = scores.length;
    double avg = sum / count;

    return avg;
} 
```

这里的变量`sum`、`count`、`avg`都是局部变量，它们都会被分配在线程栈内存中。

假如 A 线程来执行这个方法，这些变量会在 A 的栈内存分配。与此同时，B 线程也来执行这个方法，这些变量也会在 B 的栈内存中分配。这样就可以保证 B 线程不会“破坏” A 线程的数据。

### 用时拷贝

虽然使用局部变量可以保证线程安全，但是相应的使用范围也就被限制在局部了。

现实中往往会有一个变量需要多个方法都能够使用的情况，此时定义这个变量的“位置”就不能在方法里面了，而应该在方法外面。即从(方法的)局部变量变为(类的)成员变量，其实就是“位置”发生了变化。按照主流编程语言的规定，类的成员变量不能分配在线程的栈内存中，而应该分配在公共的堆内存中。

此时，要让公共区域堆内存中的数据对于每个线程都是安全的，那就每个线程都拷贝它一份，每个线程只处理自己的这一份拷贝而不去影响别的线程的，这就保证数据安全了。在 Java 中就是 ThreadLocal 类的作用。

```Java
class StudentAssistant {
    ThreadLocal<String> realName = new ThreadLocal<>();
    ThreadLocal<Double> totalScore = new ThreadLocal<>();
 
    String determineDegree() {
        double score = totalScore.get();
        
        if (score >= 90) return "A";
        if (score >= 80) return "B";
        if (score >= 70) return "C";
        if (score >= 60) return "D";
        return "E";
    }
 
    double determineOptionalcourseScore() { 
        double score = totalScore.get(); 
 
        if (score >= 90) return 10;
        if (score >= 80) return 20;
        if (score >= 70) return 30;
        if (score >= 60) return 40; 
        return 60;
    }
}
```

这个学生助手类有两个成员变量`realName`和`totalScore`，都是 ThreadLocal 类型的，每个线程在运行时都会拷贝一份存储到自己的本地。

A 线程运行的是“张三”和“90”，那么这两个数据“张三”和“90”是存储到 A 线程对象(Thread 类的实例对象)的成员变量里去了。假设此时 B 线程也在运行，是“李四”和“85”，那么“李四”和“85”这两个数据是存储到了 B 线程对象(Thread 类的实例对象)的成员变量里去了。

线程类(Thread)有一个成员变量，类似于 Map 类型的，专门用于存储 ThreadLocal 类型的数据。从逻辑从属关系来讲，这些ThreadLocal 数据是属于 Thread 类的成员变量级别的。从所在“位置”的角度来讲，这些 ThreadLocal 数据是分配在公共区域的堆内存中的。

说的直白一些，就是把堆内存中的一个数据复制 N 份，每个线程认领 1 份，同时规定好，每个线程只能使用自己的那份，不准影响别人的。

### 只读数据

如果一份数据只允许读取，不允许修改，那么不论放在哪里，不论有多少个线程使用，都不会改变其内容，自然就是线程安全了。

比如，程序中的常量或只读变量，它们对于多线程是安全的，想改也改不了。

```Java
class StudentAssistant {
    final double passScore = 60;
}
```

### 互斥锁(悲观锁)

如果要使用的数据无法通过以上三种方式实现线程安全，那么还可以使用数据互斥锁的方式来保证线程安全。

也就是在访问数据前，需要先获得数据的访问锁，并将数据锁上。这样，当别的线程要访问这个数据时，由于数据已经被锁了，就无法访问了。

比如，公共区域(堆内存)的数据要被多个线程操作时，为了确保数据的安全(或一致)性，在数据旁边放一把锁。要想操作数据，就要先获取锁。

假设一个线程来要使用该数据，发现锁是空闲的，没有人持有，于是它就拿到了这把锁，对这个数据上锁，然后开始操作数据，干了一会活，累了，就去休息了。

这时，又来了一个线程，发现锁被别人持有着，按照规定它不能操作数据，因为它无法得到这把锁。当然，它可以选择等待或放弃，转而去干别的。

第一个线程因为它手里拿着锁，其它线程是不可能操作数据的，所以当它回来后继续把数据操作完，就可以把锁给释放了。锁再次回到空闲状态，其它线程就可以来抢这把锁了。还是谁先抢到锁谁操作数据。

```Java
class ClassAssistant {
    double totalScore = 60;
    final Lock lock = new Lock();
    
    void addScore(double score) {
        lock.obtain();
        totalScore += score;
        lock.release();
    }
    
    void subScore(double score) {
        lock.obtain();
        totalScore -= score;
        lock.release();
    }
}
```

假定一个班级的初始分数是 60 分，这个班级抽出 10 名学生来同时参加 10 个不同的答题节目，每个学生答对一次为班级加上 5 分，答错一次减去 5 分。因为 10 个学生一起进行，所以这一定是一个并发情形。因此加分和减分这两个方法被并发的调用，它们共同操作总分数。为了保证数据的一致性，需要在每次操作前先获取锁，操作完成后再释放锁。

### CAS(乐观锁)

互斥锁是每次在访问数据前都要先获得数据锁，并上锁。但是很多时候并不是一定存在并发操作数据的情况，此时使用数据锁就会造成一些不必要的开销。

比如，2 个线程操作同一个数据和 200 个线程操作同一个数据，这个数据的安全概率是完全不一样的。肯定线程越多数据不安全的概率越大，线程越少数据不安全的概率越小。取个极限情况，那就是只有 1 个线程，那不安全概率就是 0，也就是安全的。

在并发很小、数据被意外修改的概率很低，但是又存在这种可能性的情况下，可以使用 CAS(Compare and Swap)方式保证线程安全。

CAS 的工作方式是，在进行数据更改时，先比较数据是否发生过变化，如果没有，那么就可以进行修改。如果发生了变化，则说明被其他线程操作过了，此时当前线程就应该放弃本次修改。

比如，一个线程操作数据，中途需要暂停处理，于是它记录下当前数据的状态(就是数据的值)。暂停结束后打算继续接着干活，但是又担心数据可能被修改了，于是就把暂停前保存的数据状态拿出来和现在的数据状态比较一下，如果一样，说明在暂停期间，数据没有被动过(当然也有可能是先被改成了其它，然后又改回来了，这就是 ABA 问题了)，那就接着继续干。如果不一样，说明数据已经被修改了，那之前做的那些操作其实都白瞎了，就干脆放弃，从头再重新开始处理一遍。

所以** CAS 这种方式适用于并发量不高的情况**，也就是数据被意外修改的可能性较小的情况。如果并发量很高的话，数据很大概率会被修改，每次都要放弃，然后从头再来，这样反而花费的代价更大了，还不如直接加锁呢。

而对于 ABA 问题，则可以使用添加数据版本的方式进行避免，规定：只要修改数据，必须使版本号加 1。这样数据在暂停前后如果数据版本一样，那么就说明没有被更改过。

