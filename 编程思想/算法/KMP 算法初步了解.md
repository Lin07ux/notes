## 一、暴力匹配

字符串匹配是在编程中常见的问题，其中从一个字符串（主串）中检测出另一个字符串（模式串）是一个非常经典的问题。当提及
到这个问题时首先想到的算法可能就是暴力匹配，下面的动图就展示了暴力匹配的流程。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596035882701.gif)

上图中箭头指向的字符都为蓝色时代表二者匹配，都为黑色时表示二者不匹配，红色则代表在主串中找到模式串。

这种算法大致思路就是每当模式串和主串中有字符不匹配的时候，模式串与主串对应的位置整体向后移动一位，再次从模式串第一位开始比较，重复上述做法直至在主串中匹配到模式串或者匹配到主串的最后一位结束。

如果主串与模式串都比较短时，用暴力匹配还是不错的，编码也相对容易；但是如果主串与模式串过长时，就会非常耗时。而使用 KMP 算法可以优化匹配，实现快速查找。

## 二、KMP 算法

### 2.1 构建前缀表

首先要确定一下引例的主串和模式串：

* 主串 S="abacaababc"
* 模式串 P="ababc"

在模式串和主串匹配时，暂时只看第 4 步，明显主串 S 中的 c 和模式串 P 中 b 是不匹配的：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596950592157.png")

如果用暴力匹配算法，那么就是*后移*模式串 P，然后从 P 的第一个字符开始比较。但是现在通过匹配我们可以知道的是第 4 位不匹配时，亲三个字符为 aba 是确定的，这个已知信息是十分有用的。

KMP 算法的核心就是利用匹配失败后获取的信息，**尽量减少模式串与主串的匹配次数已达到快速匹配的目的**。比如对于这个不匹配的现象，是不是可以像下图这样直接移动模式串呢？

![](http://cnd.qiniu.lin07ux.cn/markdown/1596950986545.png)

那么信息从何而来呢？在 KMP 算法中，对于一个模式串都可以先计算出其内部的匹配信息，这样在匹配失败时可以最有效的移动模式串，从而减少匹配次数。

在此之前，需要先理解一下前缀和后缀：

* 前缀：abcde 的前缀可以是 a、ab、abc、abcd
* 后缀：abcde 的后缀可以是 e、de、cde、bcde

这里需要引出一个新的概念——前缀表：可以用 profix 表示、且下标从 0 开，profix[i] 存储的信息就是前 i+1 个字符的最长公共前后缀，并且这个最长公共前后缀长度一定是小于字符串长度的。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596951560889.png)

> 可以看到 ababc 不是前后缀，但也被列到了表中。如果了解过 KMP 算法，那就可能听过 next 数组。当前缀表转化为 next 数组时，最后一位的值会被覆盖掉，对过程是没有什么影响的。由于本文仅是靠着前缀表 profix 完成 KMP 算法，所以不再过多讲述 next 数组，不同的方法只是表示形式不一样，但归根结底原理还是相同的。

上面的前缀表是通过肉眼比对的出的，程序毕竟不是人，所以需要通过一种程序能够识别的方法构建前缀表。流程如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596951852077.png)

从这个动图中可以将构建前缀表规划成下面五步：

1. 首先创建两个指针，指针 j 指向模式串第一位（下标为 0）、指针 i 指向模式串第二位（下标为 1）。
2. 由于模式串最开始是单一字符，没有前缀和后缀，所以对应前缀表第一位总为 0。
3. 当 j=0 时，比较 j 和 i 指向的字符，如果字符不匹配，i 对应的前缀表位置填入 0，且将 i 向后移动一位，j 原地不动。
4. 当 j 和 i 指向的字符匹配时，i 对应的前缀表位置处填入（j+1），且将 j 和 i 都向后移动一位。
5. 如果 j 和 指向的字符不匹配，并且此时 j 不等于 0，j 需要回溯到 profix[j-1]的位置，再次与 i 指向的字符进行比较。重复此步骤直至 j 和 i 指向的字符匹配或者 j=0。

这里的关键和难点在于第 5 步。利用下面的例子能够更好的凸显步骤 5 的回溯机制：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596952236035.png)

依据上面的步骤，写出了前缀表的前五位，而此时 j 和 i 指向的字符不匹配，且 j 不等于 0，这里 j 的下标是 3，所以需要在前缀表中找到下标为 j-1 的值，即 prefix[2]，然后将 j 回溯到对应的位置。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596952349995.png)

这样回溯是因为可以在模式串头部找到和 j、i 之间的字符串相匹配的前缀，也就是这个例子中的 a。如果此时 j 和 i 指向的字符相匹配，那么最长公共前后缀长度就是一片片的前缀的长度再加 1。由此可见，如果 j 和 i 之间的字符串很长时，这个操作可以节省很多时间。

而此时 j 和 i 指向的字符仍然不匹配，那么需要继续回溯 j，方法和上述一致，回溯的位置就是 profix[0]。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596952721334.png)

此时 j 和 i 指向字符还是不匹配，但这里需要做的就不是回溯了，因为 j=0 已经满足回溯结束条件了，只需要将 i 对应的前缀表的位置处(profix[5])填入 0 即可。用肉眼匹配也会发现此时的确没有公共前后缀。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596952874756.png)

在理解上述步骤之后，可以将其当做伪代码，依据伪代码很容易编写出构建前缀表函数：

```python
def PrefixTable(Pattern):
  i = 1
  j = 0
  prefix = [0]*len(Pattern)
  
  while(i < len(Pattern)):
    if Pattern[j] == Pattern[i]:
      prefix[i] = j+1
      j += 1
      i += 1
    else:
      if j == 0:
        prefix[i] = 0
        i +=1
      else:
        j = prefix[j-1]
        
  return prefix
```

可以输入一个模式串，测试一下改代码是否能够的出对饮的前缀表：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596953371772.png)

### 2.2 优化前缀表

经过上文解释，可以发现一个基本事实，即前缀表的最后一位没有任何作用。这么说的理由是什么呢？因为当 j 和 i 指向的字符不匹配的时候，这里的解决办法是回溯 j，而回溯依据一直都是 prefix[j-1]，j 是永远不可能超越 i 的，所以前缀表的最后一位永远也不会用到。

所以最后一位就可以去掉，将所有元素整体后移一位，并将前缀表第一位填入 -1，如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596960518276.png)

填入 -1 这个操作的原理稍后介绍，目前只需要知道这个操作并且了解其对应的代码即可：

```Python
def MoveTable(prefix):
  for i in range(len(prefix) - 1, 0, -1):
    prefix[i] = prefix[0-1]

  prefix[0] = -1
  return prefix
```

### 2.3 KMP 匹配机制

主串和模式串还是利用上文所举例子，省略简单的匹配过程，直接看关键点：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596960745857.png)

可以看到主串和模式串的第 4 位是不匹配的，现在需要做的就是将 Pattern[prefix[3]] 对应主串中需要匹配的元素也就是模式串下标为 1 的元素后移至与主串第 4 位对应的位置。如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596960899877.png)

对应位置仍然不匹配，需要继续后移模式串，该位置对应前缀表的值为 0，所以将 Pattern[prefix[0]] 对应的主串中需要匹配的元素，即模式串下标为 0 的元素与主串该位置对应。

![](http://cnd.qiniu.lin07ux.cn/markdown/1596961029883.png)

此时两串对应位置还是不匹配，但是 a 已经是模式串的第一位元素了，如果按照上面方法需要继续后移模式串，让主串那个位置与模式串下标为 -1 的元素匹配，可是前缀表中并不存在下标为 -1 的元素。

所以比较时如果模式串和主串对应位置不匹配，且模式串的元素对应前缀表的值为 -1，那么直接将模式串整体后移一位，并且将指向主串的指针后移一位即可。这也是为什么在前缀表的第一位插入 -1 的原因。

下面动图是利用 KMP 算法在主串中查找模式串的全过程：

![](http://cnd.qiniu.lin07ux.cn/1596961399.gif)

KMP 算法的代码如下：

```Python
def KMP(TheString,Pattern):
    m = len(TheString);n = len(Pattern)
    prefix = PrefixTable(Pattern)
    prefix = MoveTable(prefix)
    i = 0;j = 0#i为主串指针，j为模式串指针
    while(i<m):
        if j==n-1 and TheString[i]==Pattern[j]:
            print("已在主串下标%d处找到模式串" % (i-j))
            j = prefix[j]
        if TheString[i]==Pattern[j]:
            i+=1;j+=1
        else:
            j = prefix[j]
            if j==-1:
                i+=1;j+=1
```

这里只讲第一个 if 语句，当 j 指向了模式串的最后一位，并且此时如果主串和模式串对应位置品匹配，则代表在主串中找到了模式串，并打印出第一个字符出现的位置。而 j = prefix[j] 这个语句的作用就是在找到模式串后继续匹配剩余的主串，因为可能会有主串中含有若干个模式串的现象出现。

最后整个程序运行截图如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1596961697959.png)

### 2.4 BF 与 KMP 的比较

为什么 KMP 会由于 BF，这里通过对比二者的时间复杂度给出原因。

假设有这么两个比较极端的主串和模式串：

* 主串 S = "aaaaaaab"
* 模式串 P = "aaab"

首先看下 BF 算法解决该匹配问题的流程：

![](http://cnd.qiniu.lin07ux.cn/1596961830.gif)

再看一下 KMP 算法解决该匹配问题的流程：

![](http://cnd.qiniu.lin07ux.cn/1596961846.gif)

假设主串长度为 m，模式串长度为 n，对于 BF 算法，每当遇到不匹配的字符时，都要从模式穿开头再次匹配，所以对应时间复杂度为 O(m*n)；对于 KMP 算法，每当遇到不匹配的字符时，根据获得的信息它不会重复匹配已知的前缀，所以对应时间复杂度为 O(m+n)。当字符串较长时，就时间复杂度而言，KMP 算法是完全优于 BF 算法的。



