> 转摘：[Go学设计模式-程序流程要动态切换？用这个模式写更丝滑](https://mp.weixin.qq.com/s/G7r6abAzKXuite8-E8I12Q)

### 1. 介绍

模板、策略和职责链三个设计模式是解决业务系统流程复杂多变痛点的利器。

策略模式可以在运行时根据需要修改一个对象的行为，常见的定义如下：

> 定义一类算法蔟，将每个算法分别封装起来，让它们可以互相替换，此模式让算法的变化独立于使用算法的客户端。

这里所说的算法并不是狭义的那种解决问题的算法，而是指要完成的某项任务的归类。比如说，订单支付的处理就可以作为一种任务类。

算法蔟中的每个算法（即策略）则说的是完成这项任务的具体方法，对于支付场景来说，就是指可以使用微信支付，也可以使用支付宝支付，还可以使用其他的三方支付。每种支付方式就相当于一种算法，他们共同组成了算法蔟。

策略模式主要用于允许程序在运行时能根据条件动态的更改一个任务的处理逻辑。场景的应用场景有针对软件用户群体的不同进行策略切换（也就是千人千面）和业务流程兜底切换。

策略模式要解决的问题是：让使用客户端跟具体执行任务的策略解耦，不管使用哪种策略完成任务，都不需要更改客户端的调用方式。也就是说，客户端在进行任务执行调用的时候，只需要通过固定的方式进行调用并传入参数，就可以自动的使用相应的策略来完成任务。

### 2. 组成

策略模式的组成相对较为简单：定义策略调用方式的接口，并实现具体的策略实现类型，然后客户端通过统一的调用接口进行调用来完成相关的任务。

策略模式的 UML 图如下所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1673005712)

图中主要有四类角色：

* 客户端：可以简单理解成发起任务调用的代码；
* 抽象策略：是所有具体策略的通用接口，声明了用于执行完成任务的方法；
* 具体策略：实现了抽象策略，定义了具体应该如何完成任务；
* 上下文：作为客户端和具体策略的中间层，达到客户端和具体策略解耦的效果。

上图中的上下文对象维护了指向具体策略的引用，且仅通过抽象策略中定义的接口与具体策略进行交流。上下文对象引用具体策略类的时候，一般是通过组合的方式来实现：上下文对象通过私有属性指向策略接口的具体实现，这样就能够在运行时根据需要修改执行任务的具体策略的效果。

### 3. 示例

下面使用用户支付场景为例来实现策略模式：线上购物时要进行线上支付，可以选择微信支付、支付宝支付、其他三方在线支付等方式。使用策略模式进行接口时，客户端可以使用同样的调用方式完成支付，甚至可以在微信支付不能使用时，让应用吴桐的切换到其他支付方式，来完成支付。

> 这里的客户端是上面说的调用上下文，并非是不是手机 APP。

在实现代码前，先用 UML 类图梳理一下整个实现的主体结构：

![](https://cnd.qiniu.lin07ux.cn/markdown/1673006539)

其中：

* PayBehavior 抽象策略接口，对支付任务进行接口抽象；
* WxPay 和 ThirdPay 是具体的策略实现；
* PayCtx 支付的上下文对象，用于协调自己持有的 PayBehavior 具体实习，完成支付任务，同时维护发起支付所需要的支付参数（即图中的私有属性`payParams`）。

先实现支付接口和两个具体的策略实现：

```go
type PayBehavior interface {
  OrderPay(px *PayCtx)
}

type WxPay struct{}

func(*WxPay) OrderPay(px *PayCtx) {
  fmt.Printf("微信支付加工支付请求 %v\n", px.payParams)
  fmt.Println("正在使用微信支付进行支付")
}

type ThirdPay struct{}

func (*ThirdPay) OrderPay(px *PayCtx) {
  fmt.Printf("三方支付加工支付请求 %v\n", px.payParams)
  fmt.Println("正在使用三方支付进行支付")
}
```

有了策略的实现后，就需要支付上下文来进行协调以及提供必须的入参：

```go
type PayCtx struct {
  payBehavior PayBehavior // 提供支付能力的接口实现
  payParams map[string]interface{} // 支付参数
}

func (px *PayCtx) setPayBehavior(p PayBehavior) {
  px.payBehavior = p
}

func (px *PayCtx) Pay() {
  px.payBehavior.OrderPay(px)
}

func NewPayCtx(p PayBehavior) *PayCtx {
  params := map[string]interface{} {
    "appId": "ddddd",
    "mchId": 12112,
  }
  
  return &PayCtx{
    payBehavior: p,
    payParams: params,
  }
}
```

然后就可以通过支付上下文来调用具体的支付策略来完成支付任务：

```go
func main() {
  wxPay := &WxPay{}
  px := NewPayCtx(wxPay)
  px.Pay()
  
  // 支付失败的话，可以再改为三方支付
  thPay := &ThirdPay{}
  px.setPayBehavior(thPay)
  px.Pay()
}
```

### 4. 总结

策略模式和模板模式有点类似，但是两者解耦的维度并不一样：策略模式是让完成某个人物的具体方式可以相互切换，而模板模式则是针对一个流程的共性梳理出固定的执行步骤，具体步骤的执行方式下放给子类来实现。可以说，模板模式定义了完成任务的统一步骤和流程，而策略模式则提供了完成特定步骤时的不同实现方式。

策略模式在抽象方法的实现中，常会用到模板模式。比如，对于上面的支付行为，策略模式定义了一个算法蔟（支付方式），以及多个具体算法实现（微信、三方支付），让支付策略对客户端调用接口。不过，为了完成支付通常还需要用参数生成签名、验证客户端签名、调用支付基础服务进行预下单、确认下单等操作。这些支付前的操作大同小异，可以使用模板模式来进行流程统一。

策略模式和模板模式相结合使用，能够使得程序更清晰统一、更健壮、更容易维护。


