> 转摘：[Go设计模式--享元模式，节省内存的好帮手](https://mp.weixin.qq.com/s/AZHO7R6IXFG8MguDpUNdbw)

### 1. 介绍

享元模式(Flyweight Pattern)是一种结构型设计模式，**核心思想是通过共享多个对象所共有的状态**，从而有效的支持在有限的内存中载入大量细粒度的对象。

**享元**可以理解为可复用的对象，即可以是对象级别的复用，也可以是对象的字段复用（把可复用的字段单独提炼成一个更精细的对象）。

享元模式的意图是**复用对象，节省内存**，前提是**享元对象是不可变的**，也就是的享元对象初始化之后，对象的状态就不会改变了，也就是不会存在被修改的情况。

### 2. 组成

享元模式的 UML 图如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1679059636)

享元模式的结构中有以下几个角色：

* `Context` 上下文或者叫做情景类，包含原始对象中各不相同的外在状态。情景与享元对象组合在一起就表示原始对象的全部状态。调用享元方法的参数由情景类提供，也可将行为移动到情景类中，然后将连入的享元作为单纯的数据对象。
* `Flyweight` 享元类，包含原始对象中部分能在多个对象中共享的状态。同一享元对象可在许多不同场景中使用。享元中存储的状态被称为“内在状态”，传递给享元方法的状态被称为“外在状态”。
* `FlyweightFactory` 享元工厂，会对已有享元的缓存池进行管理。有了工厂之后，客户端就无需直接创建享元，而是直接调用工厂并向其传递目标享元的一些内在状态即可。工厂会根据参数在之前已创建的享元中进行查找，如果找到满足条件的享元就将其返回，没有找到就根据参数创建享元。

### 3. 实例

享元模式的实现思路是：在享元对象的工厂类中，通过一个 Map 来缓存已经创建的享元对象，达到复用的目的。下面使用一个多人在线棋牌游戏平台的例子来说明享元模式的使用。

对于一种棋牌游戏，每局中使用的棋牌都是相同的，只是会有不同的分配方式和使用组合。而且游戏过程中，每张棋牌的基本数据并不会发生变化，变化的只是当局游戏的一些状态。所以可以将棋牌做成享元，在每局游戏中进行复用，避免重复创建造成的内存和性能损失。

首先可以设计卡牌类型和存储多个享元卡牌对象：

```go
type Card struct {
  Name  string
  Color string
}

var pokerCards = map[int]*Card{
  1: {
    Name:  "A",
    Color: "红",
  },
  2: {
    Name:  "A",
    Color: "黑",
  },
  // ... 其他卡牌
}
```

每个牌局创建的时候，程序会设定牌局里的卡牌都引用自`pokerCards`中的享元：

```go
type PokerGame struct {
  Cards map[int]*Card
}

func NewPokerGame() *PokerGame {
  board := &PokerGame{Cards: map[int]*Card{}}
  for id := range pokerCards {
    board.Cards[id] = pokerCards[id]
  }
  return board
}
```

而牌局的规则是确定这些牌如何组合如何使用，这些业务逻辑以及牌局的进行状态等都由`PokerGame`类型来实现。示例代码这里不再多说明。这里的重点就是享元始终是不可改变的，这样才能保证享元在系统中只有一份，起到节省内存的作用。

可以使用下面的方式来验证，两个牌局都引用了相同的享元：

```go
func main() {
  game1 := NewPokerGame()
  game2 := NewPokerGame()
  fmt.Println(game1.Cards[1] == game2.Cards[1])
}
```

这里享元模式的代码实现比较简单，主要是为了突出享元的不可变性，而代表业务当前状态的外部状态都是存储在引用了享元的容器对象中。

### 4. 总结

享元模式其实是对象池的一种应用，通过共享大量拥有相同状态（字段）的相似对象的方式来减少内存占用，而且使用的关键在于对象应是不可变的。在享元模式中加上元数据生命周期管理就是池化技术了，而享元就可以简单理解为对象引用。

享元模式的优点是能减少对象的创建，降低内存中对象的数量，降低系统的内存占用，提高效率。

享元模式的缺点是：在写程序时需要关注内、外部状态，关注线程安全问题，使系统、程序的逻辑复杂化。

在使用享元模式前需要综合考虑，确定系统是否存在大量相似对象占用内存过多的问你题。这些对象的一些特征字段也确实能提炼成不可变对象作为享元，让外部对象引用。