> 转摘：[支撑百万并发的 “零拷贝” 技术，你了解吗？](https://mp.weixin.qq.com/s/xej6klx2q0G1fp82_vKCOg)

## 一、物理内存和虚拟内存

由于操作系统的进程与进程之间是共享 CPU 和内存资源的，因此需要一套完善的内存管理机制，防止进程之间的内存泄露问题。

为了更加有效的管理内存并减少出错，现代操作系统提供了一种对驻村的抽象概念，即虚拟内存(Virtual Memory)。

虚拟你村为每个进程体用了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉(每个进程有一片连续的、完整的内存空间)。

### 1.1 物理内存

物理内存(Physical Memory)是相对于虚拟内存(Virtual Memory)而言的，指通过物理内存条而获得的的内存空间。

物理内存是系统运行过程中数据的实际存储位置。

### 1.2 虚拟内存

虚拟内存是计算机系统内存管理的一种技术，它使得应用程序认为它拥有连续的可用的内存。而实际上，虚拟内存通常是被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换，加载到物理内存中来。

目前，大多数操作系统都使用了虚拟内存。

虚拟内存地址和是和用户进程紧密相关的。一般来说，同一个虚拟地址在不同进程里指向的物理地址是不一样的，所以离开进程谈虚拟内存没有任何意义。每个进程所能使用的虚拟地址大小和 CPU 位数相关：

* 在 32 位系统上，虚拟地址空间大小是 2^32=4G
* 在 64 位系统上，虚拟地址空间大小是 2^64=16G

实际的物理内存可能远远小于虚拟内存的大小。

每个用户进程维护了一个单独的页表(Page Table)，虚拟内存和物理内存就是通过这个页表实现地址空间的映射的。页表可以简单的理解为单个内存映射(Memory Mapping)的链表(当然实际结构很复杂)，里面的每个内存映射都将一块虚拟地址映射到一个特定的地址空间(物理内存或者磁盘存储空间)。用户进程的页表之间是没有关系的。

下面给出两个进程 A、B 各自的虚拟内存空间以及对应的物理内存之间的地址映射示意图：

![](http://cnd.qiniu.lin07ux.cn/markdown/1571024174485.png)

### 1.3 用户进程访问内存的过程

当进程执行一个程序时，需要先从内存中读取该进程的指令，然后执行，获取指令时用到的就是虚拟地址。这个虚拟地址是程序链接时确定的（内核加载并初始化进程时会调整动态库的地址范围）。

为了获取到实际的数据，CPU 需要将虚拟地址转换成物理地址，CPU 转换地址时需要用到进程的页表，而页表里面的数据由操作系统维护。
 可以简单的将用户进程申请病房为物理内存(或磁盘存储空间)的过程总结如下：

1. 用户进程向操作系统发出内存申请请求；
2. 操作系统检查进程的虚拟地址空间是否被用完，如果有剩余，给进程分配虚拟地址；
3. 操作系统为这块虚拟地址创建内存映射(Memory Mapping)，并将它放进该进程的页表(Page Table)；
4. 操作系统返回虚拟地址给用户进程，用户进程开始访问该虚拟地址；
5. CPU 根据虚拟地址在此进程的页表(Page Table)中找到相应的内存映射(Memory Mapping)记录，但是这个内存映射(Memory Mapping)没有和物理内存关联，于是产生缺页中断；
6. 操作系统收到缺页中断后，分配真正的物理内存并将它关联到页表相应的内存映射(Memory Mapping)。中断处理完成后，CPU 就可以访问内存了。

> 当然，缺页中断不是每次都会发生，只有系统觉得有必要延迟分配内存的时候才用的着，也即很多时候在上面的第 3 步系统会分配真正的物理内存并和内存映射（Memory Mapping）进行关联。

### 1.4 虚拟内存的优点

在用户进程和物理内存（磁盘存储器）之间引入虚拟内存主要有以下的优点：

* **更大的地址空间**：提供更大的地址空间，并且地址空间是连续的，使得程序编写、链接更加简单。
* **进程隔离**：不同进程的虚拟地址之间没有关系，所以一个进程的操作不会对其他进程造成影响。
* **数据保护**：每块虚拟内存都有相应的读写属性，这样就能保护程序的代码段不被修改，数据块不能被执行等，增加了系统的安全性。
* **内存映射**：有了虚拟内存之后，可以直接映射磁盘上的文件（可执行文件或动态库）到虚拟地址空间。这样可以做到物理内存延时分配，只有在需要读相应的文件的时候，才将它真正的从磁盘上加载到内存中来，而在内存吃紧的时候又可以将这部分内存清空掉，提高物理内存利用效率，并且所有这些对应用程序都是透明的。
* **共享内存**：比如动态库只需要在内存中存储一份，然后将它映射到不同进程的虚拟地址空间中，让进程觉得自己独占了这个文件。进程间的内存共享也可以通过映射同一块物理内存到进程的不同虚拟地址空间来实现共享。
* **物理内存管理**：物理地址空间全部由操作系统管理，进程无法直接分配和回收，从而系统可以更好的利用内存，平衡进程间对内存的需求。

### 1.5 RSS vs VSZ vs PSS

> 转摘：[What is RSS and VSZ in Linux memory management](https://stackoverflow.com/questions/7880784/what-is-rss-and-vsz-in-linux-memory-management)

RSS（Resident Set Size），常驻内存大小，用来表示程序使用了多少 RAM 内存。这个大小不包含被 swap 换出的内存，也不包括完整共享库需要占用的内存，但是包括进程的栈和堆的内存。

VSZ（Virtual Memory Size），虚拟内存大小，表示程序能够访问的全部内存，包括已经被 swap 换出的内存、已经被申请的内存（即便没有被使用）、共享库所需要的全部内存。

PSZ（Proportional Set Size），按比例的常驻内存大小，它表示的范围与 RSS 一直，但是计算数值的时候需要将共享库占用的内存分摊到每一个进程中。

比如，如果一个进程 A 有 500K 的二进制文件，并且链接了一个 2500K 大小的共享库，并且申请了 200K 的栈和堆大小。它申请的栈和堆的内存中只有 100K 是实际使用的，剩下的空间要么是 swap 换出了要么是还未使用。而且，共享库只载入了 1000K，且有另一个进程 B 也使用了这个共享库。另外，进程 A 自身的二进制文件也只加载了 400K。

那么这个时候就有：

```
RSS: 400K + 1000K + 100K = 1500K
VSZ: 500K + 2500K + 200K = 3200K
PSS: 400K + (1000K/2) + 100K = 400K + 500K + 100K = 1000K
```

由于一个进程中的所有线程都共享进程的资源，所以每个将线程的 RSS、VSZ、PSS 分别相加，得到的结果肯定不会小于进程、乃至整个系统的内存大小。

## 二、内核空间和用户空间

操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的权限。

为了避免用户进程之间操作内核，保证内核安全，操作系统将虚拟内存划分为两部分：一部分是内核空间(Kernel Space)，一部分是用户空间(User Space)。

在 Linux 操作系统中，内核模块运行在内核空间，对应的进程处于内核态；而用户进程运行在用户空间，对应的进程处于用户态。

内核进程和用户进程所占的虚拟内存比例是 1:3。对于 Linux x86_32 系统来说，由于系统的寻址空间(虚拟存储空间)为 4G，会将最高的 1G 的字节(从虚拟地址`0xC0000000`到`0xFFFFFFFF`)供内核进程使用，称为内核空间。而较低的 3G 字节的空间(从虚拟地址`0x0000000`到`0xBFFFFFFF`)，供各个用户进程使用，称为用户空间。

下图是一个进程的用户空间和内核空间的内存布局：

![](http://cnd.qiniu.lin07ux.cn/markdown/1571028444305.png)

### 2.1 内核空间

内核空间总是驻留在内存中，它是为操作系统的内核保留的，应用程序是不允许直接在该区域进行读写或直接调用内核代码定义的函数的。

上图左侧区域为内核进程对应的虚拟内存，按访问权限可以分为进程私有和进程共享两块区域：

* 进程私有的虚拟内存：每个进程都有单独的内核栈、页表、Task 结构以及 mem_map 结构等。
* 进程共享的虚拟内存：属于所以进程共享的内存区域，包括物理存储器、内核数据和内核代码区域。

### 2.2 用户空间

每个普通的用户进程都有一个单独的用户空间，处于用户态的进程不能访问内核空间中的数据，也不能直接调用内核函数的，因此要进行系统调用的时候，就要将进程切换到内核态才行。

用户空间包括以下几个内存区域：

1. **运行时栈**：由编译器自动释放，存放函数的参数值、局部变量和方法返回值等。、每当一个函数被调用时，该函数的返回类型和一些调用的信息被存储到栈顶，调用结束后调用新鲜会被弹出并释放掉。

    栈区是从高地址位向低地址位增长的，是一块连续的内存区域，最大容量是由系统预先定义好的，申请的栈空间超过这个界限时会提示溢出，用户能存栈中获取的空间较小。

2. **运行时堆**：用户存放进程运行中被动态分配的内存段，位于 BSS 和栈中间的地址位。由开发人员申请(malloc)和释放(free)。堆是从低地址位向高地址位增长，采用链式存储结构。

    频繁的 malloc/free 会造成内存空间的不连续，产生大量的碎片。当申请堆空间时，库函数按照一定的算法搜索可用的足够大的空间。因此队的效率要比栈低很多。
    
3. **代码段**：存放 CPU 可以执行的机器指令，该部分内存只能读不能写。通常代码区是共享的，即其他执行程序可以调用它。加入机器中有数个进程运行相同的一个程序，那么它们就可以使用同一个代码段。

4. **未初始化的数据段**：存放未初始化的全局变量，BSS 的数据在程序开始执行之前被初始化为 0 或 NULL。

5. **已初始化的数据段**：存放已初始化的全局变量，包括静态全局变量、静态局部变量以及常量。

6. **内存映射区域**：例如将动态库、共享内存等虚拟地址空间的内存映射到物理空间的内存，一般是 mmap 函数所分配的虚拟内存空间。

### 2.3 两者区别

有了用户空间和内核空间的划分后，Linux 内部层级结构可以分为三部分，从最底层到最上层依次是硬件、内核空间和用户空间，如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1571029601386.png)

内核空间和用户空间的区别如下：

* 内核空间可以访问所有的 CPU 指令和所有的内存空间、I/O 空间和硬件设备。
* 用户空间只能访问受限的资源，如果需要特殊权限，可以通过系统调用获取相应的资源。
* 用户空间允许页面中断，而内核空间则不允许。
* 内核空间和用户空间是针对线性地址空间的。
* x86 CPU 中用户空间是 0-3G 的地址范围，内核空间是 3G-4G 的地址范围。x86_64 CPU 用户空间地址范围为0x0000000000000000–0x00007fffffffffff，内核地址空间为 0xffff880000000000-最大地址。
* 所有内核进程（线程）共用一个地址空间，而用户进程都有各自的地址空间。 
由于内核态可以执行任意命令，调用系统的一切资源，而用户态只能执行简单的运算，不能直接调用系统资源，所以用户态必须通过系统接口(System Call)才能向内核发出指令。

比如，当用户进程启动一个 bash 时，它会通过`getpid()`对内核的 pid 服务发起系统调用，获取当前用户进程的 ID。如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1571029373280.png)

 


 


