> 转摘：[0.2 秒居然复制了 100G 文件？](https://mp.weixin.qq.com/s/9W7YtP2XjDZmqvTkBWgTdQ)

文件系统听起来很高大上，其实用通俗话来说，就是用于存储数据的一个容器而已，本质上和行李箱、仓库没有什么区别，只不过文件系统存储的是数字产品而已。文件系统对外提供的就是存取服务。

### 1. 现实的存取场景

例如，到火车站使用寄存服务：

**存行李的时候**，先登记一下个人信息，然后可能会发一个牌子挂在手上，作为后面取特定行李的唯一标识：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635500111821-caee81778fcc.gif)

**取行李的时候**，报自己的名字，有牌子的给他牌子，然后工作人员才能去特定的位置找到要取的行李：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635500761864-17eed1771f3c.gif)

重点：**存的时候必须要记录一些关键信息（如 ID、身份牌），取的时候才能用这些关键信息正确的定位到。**

### 2. 文件系统

对比上面的行李存取行为，可以对文件系统做个简单的类比：

1. 登记名字就是在文件系统记录文件名；
2. 生成的牌子就是元数据索引；
3. 行李就是文件；
4. 寄存室就是磁盘（容纳东西的物理空间）；
5. 管理员就是操作系统，管理整套运行机制。

上面的对应并不是非常严谨，仅仅是帮助理解文件系统而已，表名文件系统其实是一个非常朴实的东西，思想都来源于生活。

### 3. 空间管理

那么文件系统是怎么管理空间的呢？

对于一个连续的大磁盘，如何使用这段空间呢？最直观的一个想法，就是把进来的数据直接完整的放进去：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635500736066-84af95fa4476.gif)

这种方式非常容易实现，但是属于眼前最简单，以后最麻烦的方式。因为这种方式会造成很多空洞，而且难以修改文件。往往会导致：明明还有很大的空间，但是由于文件整体太大，哪个空缺位置都无法放下——因为需要将文件一整个的放进去。

既然整体放进去有比较大的问题，那么就**将文件切分，把空间按照一定粒度切分**。每个小粒度的的物理块命名为 Block，每个 Block 一般都是 512Byte 大小。然后用户数据存储到文件系统里来的时候也需要切分，存储到磁盘的各个角落上：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635500762606-ecafc864db24.gif)

图示标号表示这个完整的文件对象存储的 Block 序号，用于后续取文件时复原对象使用的。

随之而来的问题是：取数据时，需要知道文件是存在哪些 Block 中的。这就**需要有一个表来记录文件对应的所有 Block 的位置**，这个表被文件系统称为 **inode**。

这样，写文件的流程就成了这样：

1. 先写数据：数据按照 Block 粒度存储到磁盘的各个位置；
2. 再写元数据：把 Block 所在的各个位置保存起来，即写到 inode 中（用一本书来表示）。

![](http://cnd.qiniu.lin07ux.cn/markdown/1635501389947-d60b50bb7d05.gif)

读文件流程则是：

1. 先读 inode：找到文件存储的各个 Block 的位置；
2. 然后读数据：构造一个完整的文件，给到用户。

![](http://cnd.qiniu.lin07ux.cn/markdown/1635501404427-e3f357325a21.gif)

### 4. inode 和 block

现在来看看 inode：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635501743207-1fe469aa4dec.jpg)

这个 inode 有**文件元数据**和**Block 数组**（长度是 15），数组中前两项指向 Block3 和 Block11，表示数据在这两个块中存着的。

inode 中的这个 Block 数组只有 15 个元素，对应 15 个 Block，而每个 Block 为 4KB，那么难道一个文件最大只能是`15 * 4KB = 60KB`吗？

> 因为计算机系统中，数据一般都相关性，所以磁盘 IO 在取数据的时候并非每次只读取一个扇区的数据，而是一下子读取多个扇区数据。大部分系统中，磁盘 IO 会一次读取 4096Byte 的数据，所以这里一个 Block 也就为 4K 大小。

当然不是！inode 的 Block 数组其实是有分类的：

* 前 12 个槽位为直接索引；
* 第 13 个槽位为一级索引；
* 第 14 个槽位为二级索引；
* 第 15 个槽位为三级索引；

#### 4.1 直接索引

总共有 12 个直接索引，每个索引指向一个 4KB 大小的数据 Block，总共指向 48KB。也就是说，48KB 以内的文件，直接用钱买 12 个编号槽位就能记录好其位置。

直接索引就类似于一个指针，每个指针都指向一块数据。

#### 4.2 一级索引

这个位置存储的编号所指向的 Block 里面存储的也都是 Block 编号，类似于一个指向指针的指针。

一个 Block 为 4KB，每个*指针*为 4 字节，也就是说总共可以存储 1024 个*指针*。每个*指针*指向 4KB 空间。

所以，一级索引能寻址的大小为：`4096 / 4 * 4K = 4M`。

![](http://cnd.qiniu.lin07ux.cn/markdown/1635506312217-86d87c4994a9.jpg)

#### 4.3 二级索引

二级索引在一级索引的基础上又多了一级。也就是说，总共有三级*指针*了。

所以，二级索引的寻址大小为：`4096/4 * 4K/4 * 4K = 4G`。

![](http://cnd.qiniu.lin07ux.cn/markdown/1635506406984-f14485b519d7.jpg)

#### 4.4 三级索引

三级索引在二级索引的基础上再增加一级，总共就有四级*指针*了。

所以，三级索引的寻址大小为：`4096/4 * 4K/4 * 4K/4 = 4T`。

![](http://cnd.qiniu.lin07ux.cn/markdown/1635506502903-39a5f8c20ca0.jpg)

#### 4.5 总结

综上，在这种文件系统（如：ext2）上，通过这种间接块索引的方式，最大能支撑的单文件大小为：`4K + 4M + 4G + 4T ≈ 4T`。

每多一层*指针*，文件寻址就慢一些。

所以，不超过 12 个数据块（4KB）的小文件的寻址是最快的，访问文件的任意数据理论上只需要两次读盘：一次读 inode，一次读数据块。

访问大文件中的数据则需要最多五次读盘操作：inode、一级间接寻址、二级间接寻址、三级间接寻址、数据库。

### 5. 案例

一个 100G 的文件，使用`cp`命令拷贝，竟然 1 秒不到就完成了。但是一个 SATA 机械硬盘的写能力达到 150M/s 就不错了，正常情况下，拷贝 100G 的文件至少也要`100G / 150M/s = 682s`，也就是 11 分钟。

先看下文件信息：

```shell
# 先使用 du 查看
> du -sh test.txt
2.0M test.txt

# 再使用 stat 分析
> stat text.txt
  File: test.txt
  Size: 107374182400 Blocks: 4096       IO Block: 4096   regular file
Device: 78h/120d Inode: 3148347     Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2021-03-13 12:22:00.888871000 +0000
Modify: 2021-03-13 12:22:46.562243000 +0000
Change: 2021-03-13 12:22:46.562243000 +0000
 Birth: -
```

`du`命令可以看出，`test.txt`文件的实际大小只有 2M，但是在`stat`命令的输出中，可以看到它的 Size 是有 107374182400 字节（也就是 100G，这个也是一般人们看到的大小）。

同时也可以看到，这个文件总共占用了 4096 个 Blocks，每个 Block 默认大小为 512 字节（也就是一个扇区的大小），所以其实际占用的空间就是`4096 * 512byte / 1024 / 1024 = 2M`，这个就跟`du`命令的输出相符了。

> `Blocks`表示的占用（申请）了多少个磁盘扇区，每个扇区是 512Byte，这个和 inode 中的 Block 意义和大小是不同的。
> 
> `IO Block: 4096`表示的是文件系统每次存取数据时一次操作的大小为 4096 字节（也就是 8 个扇区），而不是表示每个 Block 的大小。

也就是说，虽然这个文件展示的大小是 100G，但是它其实只占用了 2M 的磁盘空间，所以拷贝速度能如此之快。而之所以文件大小和占用磁盘空间有如此大的差异，就是因为有些数据写入到了三级索引中，而中间部分没有数据。

那么，这种数据是如何写入磁盘的呢？

1. 创建一个文件，这时候会分配一个 inode；
2. 在`[0, 4K]`位置写入 4K 数据，这时候只需要一个 Block，把这个 Block 的编号写到 inode 的 Block 数组的第 0 个。
3. 在`[1T, 1T+4K]`位置写入 4K 数据，这时候只需要一个 Block，但是这个 Block 的编号就需要记录到三级索引中了，所以还需要分配出 3 个索引块。
4. 写入完成，关闭文件。

示意图如下图所示：

![](http://cnd.qiniu.lin07ux.cn/markdown/1635507226444-45ec4aaaafd1.jpg)

这个时候，这个文件看起来是一个超大文件，size 等于`1T+4K`，但是实际数据占用的磁盘只有 8K，位置分别是`[0, 4K]`、`[1T, 1T+4K]`。

由于没写数据的地方不用分配物理空间，索引实际占用的物理空间就只有 8K。

重点：**文件的 Size 只是 inode 里面的一个属性，实际占用的物理空间则是要看用户数据放了多少个 Block，没写数据的地方是不需要分配物理 Block 的。**

这样的文件其实就是稀疏文件，它的逻辑大小和实际物理空间是不相等的。所以当使用`cp`命令去复制一个这样的文件的时候，肯定就能迅速的完成了。


