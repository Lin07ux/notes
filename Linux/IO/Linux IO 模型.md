> 转摘：[送分来了，华为一面，介绍下五种 IO 模型](https://mp.weixin.qq.com/s/IAWrXznU4DlJFa8tTcthPw)

### 0. IO 简介

用户态的应用程序要进行 IO 操作，就需要经过 System Call 陷入内核，而操作系统进行输入输出操作时通常都会包括以下两个阶段：

1. **准备数据**：内核缓冲区准备数据，等待其准备好；
2. **数据拷贝**：从内核缓冲区向用户缓冲区复制数据。

比如，对于网络通信（即 Socket）上的读取操作为例：

* 第一阶段就是等待数据从网络中到达网卡。对于网络 IO 来说，很多时候数据在一开始还没有到达，比如对于 TCP 连接，数据都是分包送到的。这时候内核就要等待足够的数据到来，并将其拷贝到内核缓冲区中后，才会进入下一阶段；
* 第二阶段就是把数据从内核缓冲区中拷贝到用户缓冲区中，完成数据的读取。

![](https://cnd.qiniu.lin07ux.cn/markdown/1676800603)

操作系统管理输入和输出的模型就是 IO 模型。Linux 中有一下五种 IO 模型：

* Blocking IO：阻塞 IO
* Non-Blocking IO：非阻塞 IO
* IO Multiplexing IO：多路复用
* Signal Blocking IO：信号驱动 IO
* Asynchronous IO：异步 IO

### 1. Blocking IO

在 Linux 中，默认情况下所有的 Socket 都是 Blocking，它符合人们最常见的思考逻辑。Blocking  IO 对应的就是阻塞的系统调用`recvfrom`。

* 第一阶段，准备数据：用户进程通过系统调用`recvfrom`进行数据读取，操作系统就开始准备数据。数据被拷贝到操作系统内核的缓冲区中是需要一个过程的，在这个过程中，整个进程会被阻塞住。

* 第二阶段，数据拷贝：当内核将数据准备好了，就会将数据从内核空间拷贝到用户空间，然后系统调用`recvfrom`返回结果，用户进程才解除阻塞的状态，重新运行起来。

> **阻塞**的概念源自操作系统对进程/线程状态的描述概念，其定义为：操作系统把进程/线程从运行状态(Running)挂起为阻塞状态(Blocked)（又称为 Waiting 状态）。当进程/线程处于阻塞状态，则意味着其处于暂停运行状态，暂时不会被 CPU 调度执行。

![](https://cnd.qiniu.lin07ux.cn/markdown/1676802105)

在上述步骤中，用户进程调用`recvfrom`掉用那个，直到数据准备好且被复制到用户缓冲区中才返回。**从调用`recvfrom`开始，到返回数据的整段时间，用户进程都是被阻塞住的。**

这就是 Blocking IO 的特点：在数据准备和复制的两个阶段用户进程都被阻塞住了。在`recvfrom`成功返回后，用户进程才开始继续处理。

### 2. Non-Blocking IO

《Unix 网络编程：第一卷》中是这样描述 Non-Blocking 的：

> 进程把一个套接字设置成非阻塞是通知内核，当所请求的 IO 操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。

意思就是：如果某个用户进程进行系统调用`recvfrom`尝试获取数据，但这时候数据还没有准备好：

* 如果操作系统把这个进程挂起，那就是 Blocking IO；
* 如果操作系统选择立即给用户进程返回错误信息，那就是 Non-Blocking IO。

也就是说，Non-Blocking IO 在调用`recvfrom`系统调用之后，如果数据还没有准备好，应用进程不会被阻塞住，而是能立即从`recvfrom`得到一个`EWOULDBLOCK`错误。

用户进程在收到`recvfrom`的返回值之后，可以去做别的事情，过一段时间之后再次使用`recvfrom`系统调用来查询 IO 是否已完成。通过这种不断的轮询(Polling)检查内核数据是否准备好，准备好之后再阻塞式的将数据拷贝到用户空间中。

需要注意的是：在 Non-Blocking IO 中，系统内核准备好数据之后，将其从内核空间拷贝到用户空间的时候，用户进程同样是被阻塞住的。

因此，Non-Blocking IO 的特点就是：**用户进程需要不断的主动轮询内核是否已准备好，准备好之后再阻塞式的拷贝到用户空间**。可以简单理解为，IO 执行的第一阶段用户进程非阻塞，第二阶段用户进程阻塞。

### 3. IO Multiplexing

由于 Non-Blocking IO 需要不断的主动轮询，会消耗大连IG 的 CPU 时间。而且后台可能有多个任务在同时进行，所以可以考虑在一次轮询中，同时查询多个任务的完成状态，只要有任何一个任务完成就可以去处理它。这就是 IO Multiplexing。

IO Multiplexing 引入了新的系统调用`select/poll/epoll`（也称为多路复用器），这几种方式先后被引入 Linux 内核，性能也逐步提升。

具体来说，IO Multiplexing 就是将多个应用进程的 Socket 注册到一个多路复用器上，然后使用一个进程来监听这个多路复用器。多路复用器会不断的是轮询所有注册进来的 Socket，只要有一个 Socket 的数据准备好了，就会返回该 Socket，再由应用进程发起真正的 IO 系统调用（也就是`recvfrom`，和 Blocking IO 一样），来完成数据读取。

简单那来说，IO Multiplexing 就是同时阻塞了多个应用进程，而且可以同时对多个 Socket 进行检测，直到有数据可读或可写，才开始真正开始 IO 操作。

![](https://cnd.qiniu.lin07ux.cn/markdown/1676812746)

IO Multiplexing 的操作和 Blocking IO 类似，但是 IO Multiplexing 其实更差一些，因为需要用两个系统调用`select`和`recvfrom`，而 Blocking IO 只需要一个系统调用`recvfrom`。

但是，**IO Multiplexing 的优势并不是对单个连接能处理得更快，而是只需要一个进程就可以同时处理多个 IO，能同时处理更多的连接。**

### 4. Signal Blocking IO

Signal Blocking IO 就是当用户进程发起 IO 操作的时候，首先通过系统调用`sigaction`向内核注册一个信号处理函数，这个系统调用会立即返回不会阻塞用户进程；**当内核数据准备好后就发送一个`SIGIO`信号给用户进程**，这样用户进程就知道内核数据准备好了，可以开始执行 IO 系统调用了。

![](https://cnd.qiniu.lin07ux.cn/markdown/1676813494)

和 Non-Blocking IO 一样，信号驱动的 IO 的用户进程在 IO 的第一阶段数据准备时是非阻塞的，在第二阶段数据数据拷贝时是阻塞的。

不过信号驱动 IO 基于回调机制，其实现和开发应用难度大，因此在实际中并不常用。

### 5. Asynchronous IO

POSIX 中对同步和异步 IO 的定义如下：

* 同步 IO 操作（Synchronous IO Operation）：导致请求进程阻塞，直到 IO 操作完成；
* 异步 IO 操作（Asynchronous IO Operation）：不导致请求进程阻塞。

根据这个定义，**上述四种 IO 都是同步 IO！因为它们无一例外都会在第二阶段阻塞住用户进程直到 IO 操作完成。**

> 这就是为什么会把“阻塞 IO”称为“同步阻塞 IO”，而把“非阻塞 IO”称之为“同步非阻塞 IO”。

异步 IO 所谓的在整个 IO 操作期间都不会阻塞用户进程，其通常的工作机制是：

用户进程告知内核启动某个 IO 操作，并让内核在整个操作（包括将数据从内核复制到用户缓冲区）完成后通知用户进程。

这与 Signal Blocking IO 的本质区别就是：

* Signal Blocking IO 是在数据准备好了之后进行通知，告知应用进程可以启动 IO 操作进行数据拷贝了；
* Asynchronous IO 是在整个 IO 操作完成了之后进行通知，告知应用进程 IO 已经完成了，可以直接使用了。

下图是一个异步调用的例子：

![](https://cnd.qiniu.lin07ux.cn/markdown/1676814839)

用户进程进行异步系统调用`aio_read`之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户进程可以去做别的事情。等到数据准备好了后，内核直接将其拷贝到用户空间（不需要用户进程再主动发起`recvfrom`系统调用）。拷贝完毕后，内核才会给用户进程发送通知，告诉用户进程 IO 操作已经完成了。

所以，**异步 IO 的两个阶段中，用户进程都是非阻塞的**。用户进程将整个 IO 操作都交由内核完成，内核完成后会发送通知。在此期间，用户进程不需要去检查 IO 操作的状态，也不需要主动的去拷贝数据。

### 6. 相互比较

这五种 IO 模型之间的两阶段对比如下图所示：

![](https://cnd.qiniu.lin07ux.cn/markdown/1676815151)



