> 转摘：[怎么正经的实现shell脚本单例运行？](https://mp.weixin.qq.com/s/BA5MQC-b3yMa1OoRcqouWQ)

脚本单例运行就是在同一时间，机器上只允许运行该脚本一次，不可在该脚本被执行时，再次执行该脚本。

### 1. 简单粗暴的方法

一个非常简单的思路就是：脚本被执行的时候，先检测当前脚本是否有其他实例正在运行，如果有则直接退出。

示例如下：

```shell
#!/usr/bin/env bash
# 获取当前运行的 test.sh 脚本数
runCount=$(ps -ef | grep test.sh | grep -v grep -c)

if [ "${runCount}" -ge 1]
then
    echo -e "test.sh already running, num:${runCount}"
    exit 1;
fi

while true
do
    echo "test.sh run"
    sleep 1
done
```

这里使用`ps`命令获取到当前在运行的`test.sh`脚本数，如果大于 1，说明已经有在运行的了。

但是运行的时候会发现，即便没有运行同时执行`test.sh`脚本，其程序数量依旧不只 1 个，于是就总是不能正常的运行了：

```shell
$ ./test.sh
test.sh already running, num:2
```

之所以会这样，原因在于：shell 脚本中一个命令执行相当于 fork 了一个进程去执行，这里执行的是查找`test.sh`并`grep`的程序，另外还有一个就是当前运行的程序脚本，这样的方式自然就会出现每次都有两个。

当然，这里的判断条件可以换一下，比如当数量大于 2 的时候就说明有另一个`test.sh`在执行了，但是这样终归并不是很友好。

### 2. 文件锁

为了让脚本不能并发执行，那么自然就可以考虑使用锁了：只有获取到锁的才能执行，没有获得锁就不可执行。

在 Shell 脚本中，可以通过文件锁来实现，过程如下：

1. 运行前检查是否有该锁文件，并且文件中的进程正在运行。
2. 如果有并且程序正在运行，则已经有实例在运行，当前程序不可继续执行。
3. 否则，无实例，创建锁文件，写入当前进程 id。
4. 退出时，删除锁文件。

为什么一定要做第一步，也就是检测锁文件中的进程是否正在运行呢？因为有些情况下，脚本运行的时候出现一些问题而退出，导致锁文件没有被正常删除，这样就会造成新的实例永远无法运行了。

示例如下：

```shell
#!/usr/bin/env bash
LOCKFILE=/tmp/test.lock

if [ -e ${LOCKFILE} ] && kill -0 `cat ${LOCKFILE}`;
then
    echo "$0 already running"
    exit
fi

# 确保退出时，锁文件被删除
trap "rm -f ${LOCKFILE}; exit" INIT TERM EXIT
# 将当前程序进程 ID 写入锁文件
echo $$ > ${LOCKFILE}

# 做该脚本的任务
sleep 1000

# 删除锁文件
rm -f ${LOCKFILE}
```

对于上面这个脚本，如果在一个窗口中运行它，然后在另一个窗口中再次尝试运行，就会提示已有实例在运行了：

```shell
$ ./test.sh
./test.sh already running
```

而在第一个实例执行完成之后，再次运行该脚本，就可以正常执行了。

这里涉及到几个点比较巧妙：

* ``kill -0 `cat ${LOCKFILE}` `` 这里用于检测该进程是否存在，避免了进程没有运行了，但是锁文件还在而导致脚本不可运行。
* `trap "rm -f \${LOCKFILE}; exit" INT TERM EXIT` 用于确保脚本退出时，锁文件会被删除。
* `rm -f {LOCKFILE}` 脚本最后会正常的将锁文件删除掉。

### 3. flock

说到锁文件，就需要提到`flock`命令了。

前面利用锁文件的时候，需要进行一些巧妙的处理，否则会难以避免锁文件未正常删除而导致的问题。比如：

* 脚本被意外中断，没来得及执行删除。
* 多个脚本产生竞争，导致判断异常，比如前面有一个脚本运行，判断没有锁文件，下一步准备创建，但是另外一个脚本又先创建了，就会导致异常了。

而使用`flock`命令就简单多了：

```shell
#!/usr/bin/env bash

LOCK_FILE=/tmp/test.lock
exec 99 > "$LOCK_FILE"
flock -n 99

if [ "$?" != 0 ]
then
    echo "$0 already running"
    exit 1
fi

# 执行脚本任务
sleep 1000
```

这里：

* `exec 99 > "$LOCK_FILE"` 表示创建文件描述符 99，指向锁文件。为何是 99？只是为了和当前脚本可能打开的文件描述符冲突(例如可能和 0、1、2 冲突)，使用 110 也是没问题的。
* `flock -n 99` 尝试对该文件描述符加锁，由操作系统保证原子性。
* 一旦`flock`失败了，就可以退出执行了。
* 如果加锁成功了，当脚本退出后，该锁也会被自动释放。

因此，使用`flock`命令可以避免加锁的原子性和未正常释放的问题。

### 4. flock 改进

查看`flock`的 man 手册，发现它还有一个例子是这么做的：

```shell
[ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -en  "$0"  "$0"  "$@" || :
```

直接将这一行加在脚本开头就可以确保正常获取和释放锁了：

```shell
#!/usr/bin/env bash

[ "${FLOCKER}" != "$0" ] && exec env FLOCKER="$0" flock -en  "$0"  "$0"  "$@" || :

# 脚本要做的其他事情
sleep 1024
```

这里是先判断`${FLOCKER}`环境变量的值，如果不是当前脚本名称，则设置该环境变量，并尝试将脚本本身加锁。如果加锁成功，则运行当前脚本(并带上原有的参数)，否则就静默退出。

### 5. 总结

单例运行本身思路是很简单的，就是探测当前是否有实例在运行，如果有，则退出，但是这里如何判断，却并不是那么容易。


