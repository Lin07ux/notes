> 转摘：[为什么 0.._ 等于 undefined](http://www.hongweipeng.com/index.php/archives/1873/)

JavaScript 中，`0.._`的结果是`undefined`，这是 JavaScript 中对数字的解析特性造成的。

### 1. `0.._`的隐式转换

在 JavaScript 的词法分析中，对于 10 进制数字来说，后面接`.`操作符时，JavaScript 引擎并不知道该`.`是小数点还是属性访问符，因此有如下规定：

**`.`前面的数字为十进制数字时，如果这个数字已带小数点，则该`.`符号是访问数组的属性，否则即表示该数字的小数点；如果`.`前面不是十进制数字，则它表示属性访问符。**

比如：

```JavaScript
00._   // . 前面是八进制数字，所以其表示属性访问符
true._ // . 前面不是十进制数字，所以其表示属性访问符
0._    // 语法错误，此时 . 表示小数点，其后不可以是 . 和非数字字符
0.0._  // 输出 undefined，相当于 (0.0)._
0.._   // 相当于(0.)._
```

所以，对于`0.._`来说，相当于先定义了一个值为 0 的数字，然后访问这个数字的`_`属性(访问会将数字转换成 Number 对象)，所以也就等同于`0['_']`了。由于 Number 对象中并没有`_`属性，所以自然其值就是 undefined 了。

### 2. 为何不用`0.._`代替`void 0`

由于 JavaScript 中，`undefined`并非关键字，所以它是可以被重定义为其他值的，所以一般情况下会会用`void 0`来代替`undefined`，而且这种写法也会更短。

而`0.._`更短，为什么不用这个来代替`void 0`呢？原因主要有如下两个：

* 首先是因为可读性：`0.._`的可读性远不如`void 0`。
* 其次是正确性问题：`void`是 JavaScript 中的关键字，不会被外部改变，因此`void 0`的值永远是`undefined`；但对于`0.._`来说，由于会被转成 Number 对象后再访问`_`属性值，那么就可以在 Number 或 Object 的原型链中定义`_`属性，从而改变其值。

综上可以看到，`0.._`结果不是固定的，因此不能用于替换`void 0`。


