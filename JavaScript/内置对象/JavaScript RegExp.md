> [JS正则表达式一条龙讲解，从原理和语法到JS正则、ES6正则扩展，最后再到正则实践思路](https://segmentfault.com/a/1190000008088937)

## 一、原理概论

在一开始用正则的时候，就觉得神奇，计算机究竟是怎么根据一个正则表达式来匹配字符串的？直到后来我遇到了一本书叫《计算理论》，看到了正则、DFA、NFA 的概念和相互间的联系，才有一些恍然小悟的意思。

但如果真的要从原理上吃透正则表达式，那么恐怕最好的方式是：

1.	首先去找一本专门讲正则的书去看看，O’REILLY 的“动物总动员”系列里就有；
2.	再自己实现一个正则引擎。 
而本文的重点在于 JS 中正则的应用，故原理仅作简单介绍（因为我也没写过正则引擎，也不深入），一来大致“糊弄下”像我一样的好奇宝宝们对正则原理的疑惑，二来知道一些原理方面基本的知识，对于理解语法和写正则是大有裨益的。

### 1.1 正则引擎

为什么正则能有效，因为有引擎，这和为什么 JS 能执行是因为有 JS 引擎一样。

所谓正则引擎，可以理解为**根据你的正则表达式用算法去模拟一台机器，这台机器有很多状态，通过读取待测的字符串，在这些状态间跳来跳去，如果最后停在了“终结状态”(Happy Ending)，那么就 Say I Do，否则 Say You Are a Good Man**。如此将一个正则表达式转换为一个可在有限的步数中计算出结果的机器，那么就实现了引擎。

正则的引擎大致可分为两类：DFA 和 NFA：

1.	DFA (Deterministic finite automaton) 确定型有穷自动机
2.	NFA (Non-deterministic finite automaton) 非确定型有穷自动机，大部分都是 NFA 
这里的“确定型”指，对于某个确定字符的输入，这台机器的状态会确定地从 a 跳到 b，“非确定型”指，对于某个确定字符的输入，这台机器可能有好几种状态的跳法；这里的“有穷”指，状态是有限的，可以在有限的步数内确定某个字符串是被接受还是发好人卡的；这里的“自动机”，可以理解为，一旦这台机器的规则设定完成，就可以自行判断了，不要人看。

DFA 引擎不需要进行回溯，所以匹配效率一般情况下要高，但是它并不支持捕获组，于是也就不支持反向引用和$这种形式的引用，也不支持环视(Lookaround)、非贪婪模式等一些NFA引擎特有的特性。

> 如果想更详细地了解正则、DFA、NFA，那么可以去看一下《计算理论》，然后你可以根据某个正则表达式自己画出一台自动机。

### 1.2 知识储备

这一小节对于你理解正则表达式很有用，尤其是明白什么是字符，什么是位置。

#### 1.2.1 正则眼中的字符串 —— n 个字符，n+1 个位置

![](http://cnd.qiniu.lin07ux.cn/markdown/1489238983087.png)

在上面的“笑声”字符串中，一共有 8 个字符，这是你能看到的，还有 9 个位置，这是聪明的人才能看到的。为什么要有字符还要有位置呢？因为位置是可以被匹配的。

那么进一步我们再来理解“占有字符”和“零宽度”:

* 如果一个子正则表达式匹配到的是字符，而不是位置，而且会被保存到最终的结果中，那个这个子表达式就是占有字符的，比如`/ha/`（匹配 ha）就是占有字符的；

* 如果一个子正则匹配的是位置，而不是字符，或者匹配到的内容不保存在结果中（其实也可以看做一个位置），那么这个子表达式是零宽度的，比如`/read(?=ing)/`（匹配`reading`，但是只将`read`放入结果中，下文会详述语法，此处仅仅举例用），其中的`(?=ing)`就是零宽度的，它本质代表一个位置。 
占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。

举个栗子，比如`/aa/`是匹配不了 a 的，这个字符串中的 a 只能由正则的第一个 a 字符匹配，而不能同时由第二个 a 匹配（废话）；但是位置是可以多个匹配的，比如`/\b\ba/`是可以匹配`a`的，虽然正则表达式里有 2 个表示单词开头位置的`\b`元字符，这两个`\b`是可以同时匹配位置 0（在这个例子中）的。

*注意：我们说字符和位置是面向字符串说的，而说占有字符和零宽度是面向正则说的。*

#### 1.2.2 控制权和传动

这两个词可能在搜一些博文或者资料的时候会遇到，这里做一个解释先：

**控制权** 是指哪一个正则子表达式（可能为一个普通字符、元字符或元字符序列组成）在匹配字符串，那么控制权就在哪。

**传动** 是指正则引擎的一种机制，传动装置将定位正则从字符串的哪里开始匹配。

正则表达式当开始匹配的时候，一般是由一个子表达式获取控制权，从字符串中的某一个位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。

举一个栗子，`read(?=ing)ing\sbook`匹配`reading book`，我们把这个正则看成 5 个子表达式`read`、`(?=ing)`、`ing`、`\s`、`book`，当然你也可以把`read`看做 4 个单独字符的子表达式，只是我们这里为了方便这么看待。`read`从位置 0 开始匹配到位置 4，后面的`(?=ing)`继续从位置 4 开始匹配，发现位置 4 后面确实是`ing`，于是断言匹配成功，也就是整一个`(?=ing)`就是匹配了位置 4 这一个位置而已（这里更能理解什么是零宽了吧），然后后面的`ing`再从位置 4 开始匹配到位置 7，然后`\s`再从位置 7 匹配到位置 8，最后的`book`从位置 8 匹配到位置 12，整一个匹配完成。

### 1.3 匹配之旅“浅”度游（可跳过）

说了那么多，我们把自己当做一个正则引擎，一步一步以最小的单位——“字符”和“位置”——去看一下正则匹配的过程，举几个栗子。

#### 1.13.1 基本匹配

```
正则表达式：easy
源字符串：So easy
```

匹配过程：首先由正则表达式字符`e`取得控制权，从字符串的位置 0 开始匹配，遇到字符串字符‘S’，匹配失败，然后正则引擎向前传动，从位置 1 开始尝试，遇到字符串字符‘o’，匹配失败，继续传动，后面的空格自然也失败，于是从位置 3 开始尝试匹配，成功匹配字符串字符‘e’，控制权交给正则表达式子表达式（这里也是一个字符）a，尝试从上次匹配成功的结束位置 4 开始匹配，成功匹配字符串字符‘a’，后面一直如此匹配到‘y’，然后匹配完成，匹配结果为`easy`。

#### 1.3.2 零宽匹配

```
正则：^(?=[aeiou])[a-z]+$
源字符串：apple
```

首先这个正则表示：匹配这样一个从头到尾完整的字符串，这整一个字符串仅由小写字母组成，并且以 a、e、i、o、u 这 5 个字母任一字母开头。

匹配过程：首先正则的`^`（表示字符串开始的位置）获取控制权，从位置 0 开始匹配，匹配成功，控制权交给`(?=[aeiou])`，这个子表达式要求该位置右边必须是元音小写字母中的一个，零宽子表达式相互间不互斥，所以从位置 0 开始尝试匹配，右侧是字符串的‘a’，符合因此匹配成功，所以`(?=[aeiou])`匹配此处的位置 0 匹配成功，控制权交给`[a-z]+`，从位置 0 开始匹配，字符串‘apple’中的每个字符都匹配成功，匹配到字符串末尾，控制权交回正则的 $，尝试匹配字符串结束位置，成功，至此，整个匹配完成。

#### 1.3.3 贪婪匹配和非贪婪匹配

```
正则1：{.*}
正则2：{.*?}
源字符串：{233}
```

这里有两个正则，在限定符（语法会讲什么是限定符）后面加`?`符号表示忽略优先量词，也就是非贪婪匹配，这个栗子我剥得快一点。

首先开头的`{`匹配，两个正则都是一样的表现。

正则 1 的`.*`为贪婪匹配，所以一直匹配余下字符串'233}'，匹配到字符串结束位置，只是每次匹配，都记录一个备选状态，为了以后回溯，每次匹配有两条路，选择了匹配这条路，但记一下这里还可以有不匹配这条路，如果前面死胡同了，可以退回来，此时控制权交还给正则的}，去匹配字符串结束位置，失败，于是回溯，意思就是说前面的`.*`你吃的太多了，吐一个出来，于是控制权回给`.*`，吐出一个`}`（其实是用了前面记录的备选状态，尝试不用`.*`去匹配'}'），控制权再给正则的`}`，这次匹配就成功了。

正则 2 的`.*?`为非贪婪匹配，尽可能少地匹配，所以匹配'233}'的每一个字符的时候，都是尝试不匹配，但是一但控制权交还给最后的`}`就发现出问题了，赶紧回溯乖乖匹配，于是每一个字符都如此，最终匹配成功。

*想详细了解贪婪和非贪婪匹配原理以及获取更多正则相关原理，除了看书之外，推荐去一个 CSDN 的博客 [雁过无痕-博客频道 - CSDN.NET](http://blog.csdn.net/lxcnn)，讲解得很详细和透彻*

## 二、语法一览

正则的语法相信许多人已经看过 [deerchao 写的 30 分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)，我也是从那篇文字中入门的，deerchao 从语法逻辑的角度以 .NET 正则的标准来讲述了正则语法，而我想重新组织一遍，以便于应用的角度、以JS为宿主语言来重新梳理一遍语法，这将便于我们把语言描述翻译成正则表达式。

下面这张一览图（可能需要放大），整理了常用的正则语法，并且将 JS 不支持的语法特性以红色标注出来了（正文将不会描述这些不支持的特性），语法部分的详细描述也将根据下面的图，从上到下，从左到右的顺序来梳理，尽量不啰嗦。

![](http://cnd.qiniu.lin07ux.cn/markdown/1489239801120.png)

### 2.1 要用某类常见字符——简单元字符

为什么这里要加简单 2 个字，因为在正则中，`\d`、`\w`这样的叫元字符，而`{n,m}`、`(?!exp)`这样的也叫元字符，所以元字符是在正则中有特定意义的标识，而这一小节讲的是简单的一些元字符。

* `.`匹配除了换行符以外的任意字符，也即是`[^\n]`，如果要包含任意字符，可使用`(.|\n)`
* `\w`匹配任意字母、数字或者下划线，等价于`[a-zA-Z0-9_]`，在 deerchao 的文中还指出可匹配汉字，但是在 JS 中是不能匹配汉字的
* `\s`匹配任意空白符，包含换页符`\f`、换行符`\n`、回车符`\r`、水平制表符`\t`、垂直制表符`\v`
* `\d`匹配数字
* `\un`匹配 n，这里的 n 是一个有 4 个十六进制数字表示的 Unicode 字符，比如`\u597d`表示中文字符“好”，那么超过`\uffff`编号的字符怎么表示呢？ES6 的 u 修饰符会帮你。 
### 2.2 要表示出现次数（重复）——限定符

* `a*`表示字符 a 连续出现次数 >= 0 次
* `a+`表示字符 a 连续出现次数 >= 1 次
* `a?`表示字符 a 出现次数 0 或 1 次
* `a{5}`表示字符 a 连续出现次数 5 次
* `a{5,}`表示字符 a 连续出现次数 >= 5次
* `a{5,10}`表示字符 a 连续出现次数为 5 到 10 次，包括 5 和 10 
### 2.3 匹配位置——定位符和零宽断言

匹配某个位置的表达式都是零宽的，这是主要包含两部分，一是定位符，匹配一个特定位置，二是零宽断言，匹配一个要满足某要求的位置。

定位符有以下几个常用的：

* `\b`匹配单词边界位置，准确的描述是它匹配一个位置，这个位置前后不全是`\w`能描述的字符，所以像`\u597d\babc`是可以匹配“好abc”的。
* `^`匹配字符串开始位置，也就是位置 0，如果设置了 RegExp 对象的 Multiline 属性，`^`也匹配 'n' 或 'r' 之后的位置
* `$`匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性，`$`也匹配 'n' 或 'r' 之前的位置 
零宽断言（JS 支持的）有以下两个：

* `(?=exp)`匹配一个位置，这个位置的右边能匹配表达式 exp，注意这个表达式仅仅匹配一个位置，只是它对于这个位置的右边有要求，而右边的东西是不会被放进结果的，比如用`read(?=ing)`去匹配“reading”，结果是“read”，而“ing”是不会放进结果的
* `(?!exp)`匹配一个位置，这个位置的右边不能匹配表达式 exp 
### 2.4 想表达“或”的意思——字符簇和分歧

我们经常会表达“或”的含义，比如这几个字符中的任意一个都行，再比如匹配 5 个数字或者 5 个字母都行等等需求。

字符簇可用来表达字符级别的“或”语义，表示的是方括号中的字符任选一：

* `[abc]`表示 a、b、c 这 3 个字符中的任意一个，如果字母或者数字是连续的，那么可以用`-`连起来表示，`[b-f]`代表从 b 到 f 这么多字符中任选一个。
* `[(ab)(cd)]`并不会用来匹配字符串“ab”或“cd”，而是匹配 a、b、c、d、(、) 这 6 个字符中的任一个，也就是想表达“匹配字符串 ab 或者 cd”这样的需求不能这么做，要这么写`ab|cd`。但这里要匹配圆括号本身，讲道理是要反斜杠转义的，但是在方括号中，圆括号被当成普通字符看待，即便如此，仍然建议显式地转义。 
分歧用来表达表达式级别的“或”语义，表示的是匹配`|`左右任一表达就可：

* `ab|cd`会匹配字符串“ab”或者“cd”
* 会短路，回想下编程语言中逻辑或的短路，所以用`(ab|abc)`去匹配字符串“abc”，结果会是“ab”，因为竖线左边的已经满足了，就用左边的匹配结果代表整个正则的结果 
### 2.5 想表达“非”的意思——反义

有时候我们想表达“除了某些字符之外”这样的需求，这个时候就要用到反义

* `\W`、`\D`、`\S`、`\B` 用大写字母的这几个元字符表示就是对应小写字母匹配内容的反义，这几个依次匹配“除了字母、数字、下划线外的字符”、“非数字字符”、“非空白符”、“非单词边界位置”。
* `[^aeiou]`表示除了 a、e、i、o、u 外的任一字符，在方括号中且出现在开头位置的`^`表示排除，如果`^`在方括号中不出现在开头位置，那么它仅仅代表`^`字符本身。 
### 2.6 整体看待和捕获——分组和后向引用

其实你在上面的一些地方已经看到了圆括号，是的，圆括号就是用来分组的，括在一对括号里的就是一个分组。

上面讲的大部分是针对字符级别的，比如重复字母 “A” 5次，可以用`A{5}`来表示，但是如果想要字符串“ABC”重复 5 次呢？这个时候就需要用到括号。

括号的第一个作用，将括起来的分组当做一个整体看待，所以你可以像对待字符重复一样在一个分组后面加限定符，比如`(ABC){5}`。

分组匹配到的内容也就是这个分组捕获到的内容，从左往右，以左括号为标志，每个分组会自动拥有一个从 1 开始的编号，编号 0 的分组对应整个正则表达式，JS 不支持捕获组显示命名。

括号的第二个作用，分组捕获到的内容，可以在之后通过`\`分组编号的形式进行后向引用。比如`(ab|cd)123\1`可以匹配“ab123ab”或者“cd123cd”，但是不能匹配“ab123cd”或“cd123ab”，这里有一对括号，也是第一对括号，所以编号为捕获组 1，然后在正则中通过`\1`去引用了捕获组 1 的捕获的内容，这叫后向引用。

括号的第三个作用，改变优先级，比如`abc|de`和`(abc|d)e`表达的完全不是一个意思。

### 2.7 转义

任何在正则表达式中有作用的字符都建议转义，哪怕有些情况下不转义也能正确，比如`[]`中的圆括号、`^`符号等。

转义需要使用`\`符号来进行。

### 2.8 优先级问题

优先级从高到低是：

* 转义`\`
* 括号（圆括号和方括号）`()`、`(?:)`、`(?=)`、`[]`
* 字符和位置
* 竖线`|`

### 2.9 贪婪和非贪婪

在限定符中，除了`{n}`确切表示重复几次，其余的都是一个有下限的范围。

在默认的模式（贪婪）下，会尽可能多的匹配内容。比如用`ab*`去匹配字符串“abbb”，结果是“abbb”。

而通过在限定符后面加问号?可以进行非贪婪匹配，会尽可能少地匹配。用`ab*?`去匹配“abbb”，结果会是“a”。

不带问号的限定符也称匹配优先量词，带问号的限定符也称忽略匹配优先量词。

### 2.10 修饰符（匹配选项）

其实正则的匹配选项有很多可选，不同的宿主语言环境下可能各有不同，此处就JS的修饰符作一个说明：

* 加`g`修饰符：表示全局匹配，模式将被应用到所有字符串，而不是在发现第一个匹配项时停止
* 加`i`修饰符：表示不区分大小写
* 加`m`修饰符：表示多行模式，会改变`^`和`$`的行为，上文已述 

## 三、JS(ES5)中的正则

JS 中的正则由引用类型 RegExp 表示，下面主要就 RegExp 类型的创建、两个主要方法和构造函数属性来展开，然后会提及 String 类型上的模式匹配，最后会简单罗列 JS 中正则的一些局限。

### 3.1 创建正则表达式

一种是用字面量的方式创建，一种是用构造函数创建，我们始终建议用前者。

```JavaScript
// 创建一个正则表达式
var exp = /pattern/flags;
// 比如
var pattern=/\b[aeiou][a-z]+\b/gi;
// 等价下面的构造函数创建
var pattern=new RegExp("\\b[aeiou][a-z]+\\b","gi");
```

其中 pattern 可以是任意的正则表达式，flags 部分是修饰符，在上文中已经阐述过了，有`g`、`i`、`m` 这 3 个（ES5中）。

现在说一下为什么不要用构造函数，因为用构造函数创建正则，可能会导致对一些字符的双重转义，在上面的例子中，构造函数中第一个参数必须传入字符串（ES6可以传字面量），所以字符`\\`会被转义成`\`，因此字面量的`\b`会变成字符串中的`\\b`，这样很容易出错，贼多的反斜杠。

### 3.2 RegExp 上用来匹配提取的方法——exec()

```JavaScript
var matches=pattern.exec(str);
```

接受一个参数：源字符串。

返回：结果数组，在没有匹配项的情况下返回 null。

结果数组包含两个额外属性，`index`表示匹配项在字符串中的位置，`input`表示源字符串，结果数组 matches 第一项即 matches[0] 表示匹配整个正则表达式匹配的字符串，matches[n] 表示于模式中第 n 个捕获组匹配的字符串。

要注意的是：

* 第一，`exec()`永远只返回一个匹配项（指匹配整个正则的）
* 第二，如果设置了`g`修饰符，每次调用`exec()`会在字符串中继续查找新匹配项，不设置`g`修饰符，对一个字符串每次调用`exec()`永远只返回第一个匹配项。

所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置`g`修饰符，然后通过循环不断调用`exec`方法。

```JavaScript
// 匹配所有 ing 结尾的单词
var str="Reading and Writing";
var pattern=/\b([a-zA-Z]+)ing\b/g; 
var matches;
while(matches=pattern.exec(str)){
    console.log(matches.index +' '+ matches[0] + ' ' + matches[1]);
}
// 循环 2 次输出
// 0 Reading Read
// 12 Writing Writ
```

### 3.3 RegExp上 用来测试匹配成功与否的方法——test()

```JavaScript
var result = pattern.test(str);
```

接受一个参数：源字符串。

返回：找到匹配项，返回 true，没找到返回 false

### 3.4 RegExp 构造函数属性

RegExp 构造函数包含一些属性，适用于作用域中的所有正则表达式，并且基于所执行的最近一次正则表达式操作而变化。

* `RegExp.input`或`RegExp["$_"]`：最近一次要匹配的字符串
* `RegExp.lastMatch`或`RegExp["$&"]`：最近一次匹配项
* `RegExp.lastParen`或`RegExp["$+"]`：最近一次匹配的捕获组
* `RegExp.leftContext`或``RegExp["$`"]``：input 字符串中 lastMatch 之前的文本
* `RegExp.rightContext`或`RegExp["$'"]`：input 字符串中 lastMatch 之后的文本
* `RegExp["$n"]`：表示第 n 个捕获组的内容，n 取 1-9 
### 3.5 String 类型上的模式匹配方法

上面提到的`exec`和`test`都是在 RegExp 实例上的方法，调用主体是一个正则表达式，而以字符串为主体调用模式匹配也是最为常用的。

#### 3.5.1 匹配捕获的 match 方法

在字符串上调用`match`方法，本质上和在正则上调用`exec`相同，但是`match`方法返回的结果数组是没有`input`和`index`属性的。

```JavaScript
var str="Reading and Writing";
var pattern=/\b([a-zA-Z]+)ing\b/g; 
// 在 String 上调用 match
var matches=str.match(pattern);
// 等价于在 RegExp 上调用 exec
var matches=pattern.exec(str);
```

#### 3.5.2 返回索引的 search 方法

接受的参数和`match`方法相同，要么是一个正则表达式，要么是一个 RegExp对象。

```JavaScript
//下面两个控制台输出是一样的，都是5
var str="I am reading.";
var pattern=/\b([a-zA-Z]+)ing\b/g; 

var matches=pattern.exec(str);
console.log(matches.index);

var pos=str.search(pattern);
console.log(pos);
```

#### 3.5.3 查找并替换的 replace 方法

```JavaScript
var result = str.replace(RegExp or String, String or Function);
```

**第一个参数（查找）**：RegExp 对象或者是一个字符串（这个字符串就被看做一个平凡的字符串）。为字符串的时候，只会替换第一个子字符串；如果是正则对象，而且指定了`g`修饰符，则会替换全部匹配正则的地方，否则只替换第一处。

**第二个参数（替换内容）**：一个字符串或者是一个函数。为字符串的时候，可以使用一些特殊的字符序列，将正则表达式操作的值插进入，这是很常用的。

    * `$n`：匹配第 n 个捕获组的内容，n 取0-9
    * `$nn`：匹配第 nn 个捕获组内容，nn 取 01-99
    * ``$` ``：匹配子字符串之后的字符串
    * `$'`：匹配子字符串之前的字符串
    * `$&`：匹配整个模式得字符串
    * `$$`：表示`$`符号本身 
第二个参数是一个函数的时候：

* 在只有一个匹配项的情况下，会传递 3 个参数给这个函数：模式的匹配项、匹配项在字符串中的位置、原始字符串

* 在有多个捕获组的情况下，传递的参数是模式匹配项、第一个捕获组、第二个、第三个...最后两个参数是模式的匹配项在字符串位置、原始字符串 
这个函数要返回一个字符串，表示要替换掉的匹配项。

**返回**：替换后的结果字符串，不会改变原来的字符串


#### 3.5.4 分隔字符串的 split

基于指定的分隔符将一个字符串分割成多个子字符串，将结果放入一个数组，接受的第一个参数可以是 RegExp 对象或者是一个字符串（不会被转为正则），第二个参数可选指定数组大小，确保数组不会超过既定大小。

#### 3.6 JS（ES5）中正则的局限

JS（ES5）中不支持以下正则特性（在一览图中也可以看到）：

* 匹配字符串开始和结尾的 A 和 Z 锚
* 向后查找（所以不支持零宽度后发断言）
* 并集和交集类
* 原子组
* Unicode 支持（uFFFF 之后的）
* 命名的捕获组
* 单行和无间隔模式
* 条件匹配
* 注释 

## 四、ES6 对正则的主要加强

ES6 对正则做了一些加强，这边仅仅简单罗列以下主要的3点，具体可以去看 ES6 的知识。

### 4.1 构造函数可以传正则字面量了

ES5 中构造函数是不能接受字面量的正则的，所以会有双重转义，但是 ES6 是支持的，即便如此，还是建议用字面量创建，简洁高效。

### 4.2 u 修饰符

加了`u`修饰符，会正确处理大于`\uFFFF`的 Unicode，意味着 4 个字节的 Unicode 字符也可以被支持了。

```JavaScript
//  \uD83D\uDC2A 是一个 4 字节的 UTF-16 编码，代表一个字符
/^\uD83D/u.test('\uD83D\uDC2A')
//  false，加了u可以正确处理

/^\uD83D/.test('\uD83D\uDC2A')
//  true，不加 u，当做两个 unicode 字符处理
```

加了`u`修饰符，会改变一些正则的行为：

* 原本只能匹配不大于`\uFFFF`的字符，加了`u`修饰符可以匹配任何 Unicode 字符
* Unicode 字符新表示法`\u{码点}`必须在加了`u`修饰符后才是有效的
* 使用`u`修饰符后，所有量词都会正确识别码点大于`0xFFFF`的 Unicode 字符
* 使一些反义元字符对于大于`\uFFFF`的字符也生效 
### 4.3 y 修饰符

`y`修饰符的作用与`g`修饰符类似，也是全局匹配，开始从位置 0 开始，后一次匹配都从上一次匹配成功的下一个位置开始。

不同之处在于，`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保匹配必须从剩余的第一个位置开始。

所以`/a/y`去匹配"ba"会匹配失败，因为`y`修饰符要求，在剩余位置第一个位置（这里是位置 0）开始就要匹配。

ES6 对正则的加强，可以看 [这篇](http://caibaojian.com/es6/regex.html)


