> 转摘：[JS正则表达式一条龙讲解，从原理和语法到JS正则、ES6正则扩展，最后再到正则实践思路](https://segmentfault.com/a/1190000008088937)

## 一、原理概论

在一开始用正则的时候，就觉得神奇，计算机究竟是怎么根据一个正则表达式来匹配字符串的？直到后来我遇到了一本书叫《计算理论》，看到了正则、DFA、NFA 的概念和相互间的联系，才有一些恍然小悟的意思。

但如果真的要从原理上吃透正则表达式，那么恐怕最好的方式是：

1.	首先去找一本专门讲正则的书去看看，O’REILLY 的“动物总动员”系列里就有；
2.	再自己实现一个正则引擎。 
而本文的重点在于 JS 中正则的应用，故原理仅作简单介绍（因为我也没写过正则引擎，也不深入），一来大致“糊弄下”像我一样的好奇宝宝们对正则原理的疑惑，二来知道一些原理方面基本的知识，对于理解语法和写正则是大有裨益的。

### 1.1 正则引擎

为什么正则能有效，因为有引擎，这和为什么 JS 能执行是因为有 JS 引擎一样。

所谓正则引擎，可以理解为**根据你的正则表达式用算法去模拟一台机器，这台机器有很多状态，通过读取待测的字符串，在这些状态间跳来跳去，如果最后停在了“终结状态”(Happy Ending)，那么就 Say I Do，否则 Say You Are a Good Man**。如此将一个正则表达式转换为一个可在有限的步数中计算出结果的机器，那么就实现了引擎。

正则的引擎大致可分为两类：DFA 和 NFA：

1.	DFA (Deterministic finite automaton) 确定型有穷自动机
2.	NFA (Non-deterministic finite automaton) 非确定型有穷自动机，大部分都是 NFA 
这里的“确定型”指，对于某个确定字符的输入，这台机器的状态会确定地从 a 跳到 b，“非确定型”指，对于某个确定字符的输入，这台机器可能有好几种状态的跳法；这里的“有穷”指，状态是有限的，可以在有限的步数内确定某个字符串是被接受还是发好人卡的；这里的“自动机”，可以理解为，一旦这台机器的规则设定完成，就可以自行判断了，不要人看。

DFA 引擎不需要进行回溯，所以匹配效率一般情况下要高，但是它并不支持捕获组，于是也就不支持反向引用和$这种形式的引用，也不支持环视(Lookaround)、非贪婪模式等一些NFA引擎特有的特性。

> 如果想更详细地了解正则、DFA、NFA，那么可以去看一下《计算理论》，然后你可以根据某个正则表达式自己画出一台自动机。

### 1.2 知识储备

这一小节对于你理解正则表达式很有用，尤其是明白什么是字符，什么是位置。

#### 1.2.1 正则眼中的字符串 —— n 个字符，n+1 个位置

![](http://cnd.qiniu.lin07ux.cn/markdown/1489238983087.png)

在上面的“笑声”字符串中，一共有 8 个字符，这是你能看到的，还有 9 个位置，这是聪明的人才能看到的。为什么要有字符还要有位置呢？因为位置是可以被匹配的。

那么进一步我们再来理解“占有字符”和“零宽度”:

* 如果一个子正则表达式匹配到的是字符，而不是位置，而且会被保存到最终的结果中，那个这个子表达式就是占有字符的，比如`/ha/`（匹配 ha）就是占有字符的；

* 如果一个子正则匹配的是位置，而不是字符，或者匹配到的内容不保存在结果中（其实也可以看做一个位置），那么这个子表达式是零宽度的，比如`/read(?=ing)/`（匹配`reading`，但是只将`read`放入结果中，下文会详述语法，此处仅仅举例用），其中的`(?=ing)`就是零宽度的，它本质代表一个位置。 
占有字符是互斥的，零宽度是非互斥的。也就是一个字符，同一时间只能由一个子表达式匹配，而一个位置，却可以同时由多个零宽度的子表达式匹配。

举个栗子，比如`/aa/`是匹配不了 a 的，这个字符串中的 a 只能由正则的第一个 a 字符匹配，而不能同时由第二个 a 匹配（废话）；但是位置是可以多个匹配的，比如`/\b\ba/`是可以匹配`a`的，虽然正则表达式里有 2 个表示单词开头位置的`\b`元字符，这两个`\b`是可以同时匹配位置 0（在这个例子中）的。

*注意：我们说字符和位置是面向字符串说的，而说占有字符和零宽度是面向正则说的。*

#### 1.2.2 控制权和传动

这两个词可能在搜一些博文或者资料的时候会遇到，这里做一个解释先：

**控制权** 是指哪一个正则子表达式（可能为一个普通字符、元字符或元字符序列组成）在匹配字符串，那么控制权就在哪。

**传动** 是指正则引擎的一种机制，传动装置将定位正则从字符串的哪里开始匹配。

正则表达式当开始匹配的时候，一般是由一个子表达式获取控制权，从字符串中的某一个位置开始尝试匹配，一个子表达式开始尝试匹配的位置，是从前一子表达匹配成功的结束位置开始的。

举一个栗子，`read(?=ing)ing\sbook`匹配`reading book`，我们把这个正则看成 5 个子表达式`read`、`(?=ing)`、`ing`、`\s`、`book`，当然你也可以把`read`看做 4 个单独字符的子表达式，只是我们这里为了方便这么看待。`read`从位置 0 开始匹配到位置 4，后面的`(?=ing)`继续从位置 4 开始匹配，发现位置 4 后面确实是`ing`，于是断言匹配成功，也就是整一个`(?=ing)`就是匹配了位置 4 这一个位置而已（这里更能理解什么是零宽了吧），然后后面的`ing`再从位置 4 开始匹配到位置 7，然后`\s`再从位置 7 匹配到位置 8，最后的`book`从位置 8 匹配到位置 12，整一个匹配完成。

### 1.3 匹配之旅“浅”度游（可跳过）

说了那么多，我们把自己当做一个正则引擎，一步一步以最小的单位——“字符”和“位置”——去看一下正则匹配的过程，举几个栗子。

#### 1.13.1 基本匹配

```
正则表达式：easy
源字符串：So easy
```

匹配过程：首先由正则表达式字符`e`取得控制权，从字符串的位置 0 开始匹配，遇到字符串字符‘S’，匹配失败，然后正则引擎向前传动，从位置 1 开始尝试，遇到字符串字符‘o’，匹配失败，继续传动，后面的空格自然也失败，于是从位置 3 开始尝试匹配，成功匹配字符串字符‘e’，控制权交给正则表达式子表达式（这里也是一个字符）a，尝试从上次匹配成功的结束位置 4 开始匹配，成功匹配字符串字符‘a’，后面一直如此匹配到‘y’，然后匹配完成，匹配结果为`easy`。

#### 1.3.2 零宽匹配

```
正则：^(?=[aeiou])[a-z]+$
源字符串：apple
```

首先这个正则表示：匹配这样一个从头到尾完整的字符串，这整一个字符串仅由小写字母组成，并且以 a、e、i、o、u 这 5 个字母任一字母开头。

匹配过程：首先正则的`^`（表示字符串开始的位置）获取控制权，从位置 0 开始匹配，匹配成功，控制权交给`(?=[aeiou])`，这个子表达式要求该位置右边必须是元音小写字母中的一个，零宽子表达式相互间不互斥，所以从位置 0 开始尝试匹配，右侧是字符串的‘a’，符合因此匹配成功，所以`(?=[aeiou])`匹配此处的位置 0 匹配成功，控制权交给`[a-z]+`，从位置 0 开始匹配，字符串‘apple’中的每个字符都匹配成功，匹配到字符串末尾，控制权交回正则的 $，尝试匹配字符串结束位置，成功，至此，整个匹配完成。

#### 1.3.3 贪婪匹配和非贪婪匹配

```
正则1：{.*}
正则2：{.*?}
源字符串：{233}
```

这里有两个正则，在限定符（语法会讲什么是限定符）后面加`?`符号表示忽略优先量词，也就是非贪婪匹配，这个栗子我剥得快一点。

首先开头的`{`匹配，两个正则都是一样的表现。

正则 1 的`.*`为贪婪匹配，所以一直匹配余下字符串'233}'，匹配到字符串结束位置，只是每次匹配，都记录一个备选状态，为了以后回溯，每次匹配有两条路，选择了匹配这条路，但记一下这里还可以有不匹配这条路，如果前面死胡同了，可以退回来，此时控制权交还给正则的}，去匹配字符串结束位置，失败，于是回溯，意思就是说前面的`.*`你吃的太多了，吐一个出来，于是控制权回给`.*`，吐出一个`}`（其实是用了前面记录的备选状态，尝试不用`.*`去匹配'}'），控制权再给正则的`}`，这次匹配就成功了。

正则 2 的`.*?`为非贪婪匹配，尽可能少地匹配，所以匹配'233}'的每一个字符的时候，都是尝试不匹配，但是一但控制权交还给最后的`}`就发现出问题了，赶紧回溯乖乖匹配，于是每一个字符都如此，最终匹配成功。

*想详细了解贪婪和非贪婪匹配原理以及获取更多正则相关原理，除了看书之外，推荐去一个 CSDN 的博客 [雁过无痕-博客频道 - CSDN.NET](http://blog.csdn.net/lxcnn)，讲解得很详细和透彻*

## 二、正则语法

正则的语法相信许多人已经看过 [deerchao 写的 30 分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)，deerchao 从语法逻辑的角度以 .NET 正则的标准来讲述了正则语法，而我想重新组织一遍，以便于应用的角度、以JS为宿主语言来重新梳理一遍语法，这将便于我们把语言描述翻译成正则表达式。

下面这张一览图（可能需要放大），整理了常用的正则语法，并且将 JS 不支持的语法特性以红色标注出来了（正文将不会描述这些不支持的特性），语法部分的详细描述也将根据下面的图，从上到下，从左到右的顺序来梳理，尽量不啰嗦。

![](http://cnd.qiniu.lin07ux.cn/markdown/1489239801120.png)

### 2.1 简单元字符 —— 常见字符

正则表达式中有一些特殊的字符会被用作控制，被称作元字符，主要有如下几个：

* `(`和`)` 分组符
* `[`和`]` 字符簇包裹符
* `{`和`}` 次数限定符
* `\` 转义字符
* `|` 或链接符
* `^` 行首符
* `$` 行尾符
* `?`、`+`和`*` 重复次数限定符
* `.` 任意字符，匹配除了换行符以外的任何字符

如果需要匹配这些元字符，则需要对其进行转义，也就是在要匹配的元字符前面添加`\`。比如要匹配`(`，则需要写成`\(`。

除了这些用于正则控制的字符，还有一些常用的表达式也会被称作元字符，主要有如下几个：

* `\w` 匹配任意字母、数字或者下划线，等价于`[a-zA-Z0-9_]`，在 JS 中是不能匹配汉字的
* `\s` 匹配任意空白符，包含换页符`\f`、换行符`\n`、回车符`\r`、水平制表符`\t`、垂直制表符`\v`
* `\d` 匹配数字
* `\un` 匹配 Unicode 字符。这里的 n 是一个有 4 个十六进制数字表示的 Unicode 字符，比如`\u597d`表示中文字符“好”，超过`\uffff`编号的字符需要用到 ES6 的`u`修饰符。 
### 2.2 限定符 —— 出现次数（重复）

* `a*` 表示字符 a 连续出现次数 >= 0 次
* `a+` 表示字符 a 连续出现次数 >= 1 次
* `a?` 表示字符 a 出现次数 0 或 1 次
* `a{5}` 表示字符 a 连续出现次数 5 次
* `a{5,}` 表示字符 a 连续出现次数 >= 5次
* `a{5,10}` 表示字符 a 连续出现次数为 5 到 10 次，包括 5 和 10 
### 2.3 匹配位置 —— 定位符和零宽断言

匹配某个位置的表达式都是零宽的，这是主要包含两部分，一是定位符，匹配一个特定位置，二是零宽断言，匹配一个要满足某要求的位置。

定位符有以下几个常用的：

* `\b` 匹配单词边界位置，准确的描述是它匹配一个位置，这个位置前后不全是`\w`能描述的字符，所以像`\u597d\babc`是可以匹配`好abc`的。
* `^` 匹配字符串开始位置，也就是位置 0，如果设置了 RegExp 对象的 Multiline 属性，`^`也匹配`\n`或`\r`之后的位置
* `$` 匹配字符串结束位置，如果设置了 RegExp 对象的 Multiline 属性，`$`也匹配`\n`或`\r`之前的位置 
零宽断言（JS 支持的）有以下两个：

* `(?=exp)`匹配一个位置，这个位置的右边能匹配表达式 exp，注意这个表达式仅仅匹配一个位置，只是它对于这个位置的右边有要求，而右边的东西是不会被放进结果的，比如用`read(?=ing)`去匹配“reading”，结果是“read”，而“ing”是不会放进结果的
* `(?!exp)`匹配一个位置，这个位置的右边不能匹配表达式 exp 
### 2.4 或 —— 字符簇和分歧

经常会需要表达“或”的含义，比如这几个字符中的任意一个都行，再比如匹配 5 个数字或者 5 个字母都行等等需求。

字符簇可用来表达字符级别的“或”语义，表示的是方括号中的字符任选一：

* `[abc]` 表示 a、b、c 这 3 个字符中的任意一个，如果字母或者数字是连续的，那么可以用`-`连起来表示，比如`[b-f]`代表从 b 到 f 这么多字符中任选一个。
* `[(ab)(cd)]` 并不会用来匹配字符串“ab”或“cd”，而是匹配 a、b、c、d、(、) 这 6 个字符中的任一个，也就是想表达“匹配字符串 ab 或者 cd”这样的需求不能这么做，要这么写`ab|cd`。

> 这里要匹配圆括号本身，按理是要反斜杠转义的，但是在方括号中，圆括号被当成普通字符看待，可以不需要转义。即便如此，仍然建议显式地转义。 
分歧用来表达表达式级别的“或”语义，表示的是匹配`|`左右任一表达就可。比如`ab|cd`会匹配字符串“ab”或者“cd”。

分歧会短路，类似于编程语言中逻辑或的短路，所以用`(ab|abc)`去匹配字符串“abc”，结果会是“ab”，因为竖线左边的已经满足了，就用左边的匹配结果代表整个正则的结果。 
### 2.5 非 —— 反义

有时候想表达“除了某些字符之外”这样的需求，这个时候就要用到反义

* `\W`、`\D`、`\S`、`\B` 用大写字母的这几个元字符表示就是对应小写字母匹配内容的反义，这几个依次匹配“除了字母、数字、下划线外的字符”、“非数字字符”、“非空白符”、“非单词边界位置”。
* `[^aeiou]`表示除了 a、e、i、o、u 外的任一字符，在方括号中且出现在开头位置的`^`表示排除。

> 如果`^`在方括号中不出现在开头位置，那么它仅仅代表`^`字符本身。但这种情况建议显式的对其转义。 
### 2.6 分组和后向引用 —— 整体看待和捕获

圆括号就是用来分组的，括在一对括号里的就是一个分组。比如，想要字符串“ABC”重复 5 次就需要用到括号将这三个字符包裹起来。

* 括号的第一个作用，将括起来的分组当做一个整体看待，所以可以像对待字符重复一样在一个分组后面加限定符，比如`(ABC){5}`。分组匹配到的内容也就是这个分组捕获到的内容，从左往右，以左括号为标志，每个分组会自动拥有一个从 1 开始的编号。

    > 编号 0 的分组对应整个正则表达式，JS 不支持捕获组显示命名。

* 括号的第二个作用，分组捕获到的内容，可以在之后通过`\`分组编号的形式进行后向引用。比如`(ab|cd)123\1`可以匹配“ab123ab”或者“cd123cd”，但是不能匹配“ab123cd”或“cd123ab”，这里有一对括号，也是第一对括号，所以编号为捕获组 1，然后在正则中通过`\1`去引用了捕获组 1 的捕获的内容，这叫后向引用。

* 括号的第三个作用，改变优先级，比如`abc|de`和`(abc|d)e`表达的完全不是一个意思。

### 2.7 转义

任何在正则表达式中有作用的字符都建议转义，哪怕有些情况下不转义也能正确，比如`[]`中的圆括号、`^`符号等。

转义需要使用`\`符号来进行。

### 2.8 优先级问题

优先级从高到低是：

* 转义`\`
* 括号（圆括号和方括号）`()`、`(?:)`、`(?=)`、`[]`
* 字符和位置
* 竖线`|`

### 2.9 贪婪和非贪婪

在限定符中，除了`{n}`确切表示重复几次，其余的都是一个有下限的范围。

在默认的模式（贪婪）下，会尽可能多的匹配内容。比如用`ab*`去匹配字符串“abbb”，结果是“abbb”。而通过在限定符后面加问号`?`可以进行非贪婪匹配，会尽可能少地匹配。用`ab*?`去匹配“abbb”，结果会是“a”。

不带问号的限定符也称匹配优先量词，带问号的限定符也称忽略匹配优先量词。

### 2.10 修饰符（匹配模式）

修饰符是用来改变正则匹配的行为的。JavaScript 中正则表达式的修饰符有以下几个：

* `g` 表示全局匹配，模式将被应用到所有字符串，而不是在发现第一个匹配项时停止
* `i` 表示不区分大小写
* `m` 表示多行模式，会改变`^`和`$`的行为
* `u` 表示匹配 Unicode 模式，可以处理大于`\uFFFF`的 Unicode，意味着 4 个字节的 Unicode 字符也被支持
* `y` 表示全局匹配，与`g`修饰符类似，开始时从位置 0 开始，后一次匹配都从上一次匹配成功的下一个位置开始。

> `u`和`y`修饰符是 ES6 中新增加的，ES6 对正则的加强，可以看 [ES6 正则的扩展](http://caibaojian.com/es6/regex.html)。

使用`u`修饰符可以使正则表达式正确的识别和匹配大于`\uFFFF`的 Unicode 字符，所有量词都会正确识别这些 Unicode 字符。比如：

```JavaScript
// \uD83D\uDC2A 是一个 4 字节的 UTF-16 编码，代表一个字符而不是两个，所以下面的结果是 false
/^\uD83D/u.test('\uD83D\uDC2A')

// 不加 u 修饰符的时候，会把 \uD83D\uDC2A 当做两个 Unicode 字符处理，此时结果就是 true
/^\uD83D/.test('\uD83D\uDC2A')
```

`y`修饰符和`g`修饰符虽然都是表示全局匹配，但它们也有区别：`g`修饰符只要剩余位置中存在匹配就可，而`y`修饰符确保必须从剩余的第一个位置开始就匹配，否则会返回 null。比如：

```JavaScript
var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
```

可以看到，对于`y`修饰符，由于第二次执行`exec`的时候，起始位置的字符是`_`，与表达式能匹配，所以就返回了 null。

## 三、ECMAScript 正则对象

JavaScript 中的正则由引用类型 RegExp 表示，下面主要就 RegExp 类型的创建、两个主要方法和构造函数属性来展开，然后会提及 String 类型上的模式匹配，最后会简单罗列 JavaScript 中正则的一些局限。

### 3.1 创建实例

一种是用字面量的方式创建，一种是用构造函数创建，建议用前者。

```JavaScript
// 创建一个正则表达式
var exp = /pattern/flags;
// 比如
var pattern=/\b[aeiou][a-z]+\b/gi;

// 等价下面的构造函数创建
var pattern=new RegExp("\\b[aeiou][a-z]+\\b","gi");
```

其中 pattern 可以是任意的正则表达式，flags 部分是修饰符，有`g`、`i`、`m`、`u`、`y`这几个。

用构造函数创建正则，可能会导致对一些字符的双重转义，在上面的例子中，构造函数中第一个参数必须传入字符串（ES6 可以传字面量），所以字符`\\`会被转义成`\`，因此字面量的`\b`会变成字符串中的`\\b`，这样很容易出错，贼多的反斜杠。所以建议使用字面量方式创建正则表达式。

### 3.2 实例属性

RegExp 的每个实例都有如下属性，通过这些属性可以取得有关模式的各种信息：

* `global` Boolean，表示是否设置了`g`修饰符
* `ignoreCase` Boolean，表示是否设置了`i`修饰符
* `lastIndex` Integer，表示开始搜索下一个匹配项的字符位置，从 0 开始算起
* `multiline` Boolean，表示是否设置了`m`修饰符
* `source` String，正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回

比如：

```JavaScript
let pattern = /\[bc\]at/i

pattern.global     // false
pattern.ignoreCase // true
pattern.multiline  // true
pattern.lastIndex  // 0
pattern.source     // "\[bc\]at"
```

### 3.3 实例方法 exec()

RegExp 实例中的`exec()`方法是专门为捕获组而设计的。语法如下：

```JavaScript
var matches = pattern.exec(str);
```

有一个参数：

* `str` String，表示要与正则表达式进行匹配的源字符串。

没有匹配项时会返回 null，有匹配项时返回值是一个特殊的数组，该数据具有如下特性：

* `index` Integer，该属性表示匹配项在源字符串中的位置，从 0 算起。
* `input` String，表示进行正则匹配的源字符串，也即是传入的参数。
* `0` String，表示与整个正则表达式匹配的字符串
* `n` String，这里 n 是一个数值，表示与模式中的捕获组(`()`)匹配的的字符串，按照正则表达式中捕获组的左括号(`(`)的次序排序。比如`matches[n]`表示于模式中第 n 个捕获组匹配的字符串。

需要注意的是：

1. `exec()`永远只返回一个匹配项（指匹配整个正则的）
2. 如果设置了`g`修饰符，每次调用`exec()`会在字符串中继续查找新匹配项，不设置`g`修饰符，对一个字符串每次调用`exec()`永远只返回第一个匹配项。

所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置`g`修饰符，然后通过循环不断调用`exec`方法。

比如：

```JavaScript
// 匹配所有 ing 结尾的单词
let str = "Reading and Writing";
let pattern = /\b([a-zA-Z]+)ing\b/g; 
let matches;

while (matches = pattern.exec(str)) {
    console.log(matches.index + ' ' + matches[0] + ' ' + matches[1]);
}

// 0 Reading Read
// 12 Writing Writ
```

这里正则表示有一个捕获组`([a-zA-Z]+)`，所以在匹配的结果中，`matches[1]`就表示这个捕获组匹配到的内容，依次分别是`Read`和`Writ`。

### 3.4 实例方法 test()

RegExp 实例上的`test()`方法主要是用来测试字符串与正则表示匹配与否的：相匹配的时候返回 true，否则返回 false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其匹配的文本内容的情况下，使用这个方法非常方便。、

语法如下：

```JavaScript
let result = pattern.test(str)
```

接受一个参数：

* `str` String，表示要与正则表达式进行匹配的源字符串。

返回结果就是一个 Boolean 值。

比如：

```JavaScript
let text = '000-00-0000'
let pattern = /\d{3}-\d{2}-\d{4}/

if (pattern.test(text)) {
    console.log('The pattern was matched')
}

// "The pattern was matched"
```

### 3.5 RegExp 构造函数属性

RegExp 构造函数包含一些属性，适用于作用域中的所有正则表达式，属性值会基于所执行的最近一次正则表达式操作而变化：

 属性名          | 简写属性名    |  说明
----------------|-------------|-------------------
 `input`        | `$_`        | 最近一次要匹配的字符串
 `lastMatch`    | `$&`        | 最近一次的匹配项
 `lastParen`    | `$+`        | 最近一次匹配的捕获组
 `leftContext`  | ``$` ``     | input 字符串中 lastMatch 之前的文本
 `rightContext` | `$'`        | input 字符串中 lastMatch 之后的文本
 `multiline`    | `$*`        | Boolean，表示是否所有表达式都使用多行模式
                | `$n`        | 这里 n 取值为 1-9，表示第 n 个捕获组的内容

这些属性并非所有的浏览器都支持，而且对于简写属性，由于其可能不是有效的 ECMAScript 标识符，所以使用简写属性的时候需要使用中括号方式，比如``RegExp['$`']``。

使用这些属性可以从`exec()`和`test()`执行的操作中提取出更具体的信息。比如：

```JavaScript
let text = 'this has been a short summer'
let pattern = /(.)hort/g

if (pattern.test(text)) {
    console.log(RegExp.input)        // this has been a short summer
    console.log(RegExp.$_)           // this has been a short summer
    
    console.log(RegExp.leftContext)  // this has been a 
    console.log(RegExp["$`"])        // this has been a 
    
    console.log(RegExp.rightContext) // summer
    console.log(RegExp["$'"])        // summer
    
    console.log(RegExp.lastMatch)    // short
    console.log(RegExp["$&"])        // short
    
    console.log(RegExp.lastParen)    // s
    console.log(RegExp["$+"])        // s
    console.log(RegExp.$1)           // s
    
    console.log(RegExp.multiline)    // false
    console.log(RegExp["$*"])        // false
}
```

### 3.6 ECMAScript5 中正则的局限

JS（ES5）中不支持以下正则特性（在一览图中也可以看到）：

* 匹配字符串开始和结尾的`\A`和`\Z`锚
* 向后查找（所以不支持零宽度后发断言）
* 并集和交集类
* 原子组
* Unicode 支持（uFFFF 之后的）
* 命名的捕获组
* 单行和无间隔模式
* 条件匹配
* 注释

## 四、ES9 正则表达式新特性

ES9 为正则表达式添加了四个新的特性，进一步提高了 JavaScript 的字符串处理能力。这些特性有：

* `s`修饰符(dotAll)
* 命名捕获组
* Lookbehind 后行断言
* Unicode 属性转义

这些新特性的目前(2019年)的支持程度如下：

![](http://cnd.qiniu.lin07ux.cn/markdown/1576721997316.png)

### 4.1 s 修饰符

正则表达式中，`.`是一个特殊的字符，可以代表任意的单个字符，除了下面两种：

1. 无法表示四个字节的 UTF-16 字符。
2. 也无法代表行终止符，如换行符`\n`和回车符`\r`。

对于四字节的 UTF-16 字符可以通过`u`修饰符来解决，而对换行符则需要使用 ES9 中新增加的`s`修饰符来解决。比如：

```JavaScript
console.log(/foo.bar/.test('foo\nbar'))  // false
console.log(/foo.bar/s.test('foo\nbar')) // true
```

正则中使用了`s`修饰符之后，可以通过如下方式查看到：

```JavaScript
const re = /foo.bar/s  // 或者：const re = new RegExp('foo.bar', 's')

console.log(res.test('foo\nbar'))  // true
console.log(re.dotAll)  // true
console.log(re.flags)   // 's'
```

### 4.2 命名捕获组

正则表达式中，可以使用`$n`这种方式来指代匹配组。但是在一些正则表达式模式中，使用数字进行匹配可能会令人混淆。

例如，使用正则表达式`/(\d{4})-(\d{2})-(\d{2})/`来匹配日期。因为美式英语中的日期表示法和英式英语中的日期表示法不同，所以很难区分哪一组表示日期，哪一组表示月份：

```JavaScript
const re = /(\d{4})-(\d{2})-(\d{2})/
const match = re.exec('2019-01-01')

console.log(match[0])  // 2019-01-01
console.log(match[1])  // 2019
console.log(match[2])  // 01
console.log(match[3])  // 01
```

ES9 引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，也便于引用：

```JavaScript
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
const match = re.exec('2019-01-01')

console.log(match.groups)       // {year: "2019", month: "01", day: "01"}
console.log(match.groups.year)  // 2019
console.log(match.groups.month) // 01
console.log(match.groups.day)   // 01
```

上面的代码中，命名捕获组在圆括号内部、模式的头部，使用`?<>`符号，并将捕获组的名称写在两个尖括号中间，组成了对该捕获组的命名。然后在该正则执行之后，就可以在匹配结果的`groups`属性上使用这些名称了。

命名捕获组也可以使用在`String.replace()`中。例如，将日期转换为美国的 MM-DD-YYYY 格式：

```JavaScript
const re = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/
const usaDate = '2018-04-30'.replace(re, '$<month>-$<day>-$<year>')

console.log(usaDate) // 04-30-2018
```

需要注意的是，在替换结果中使用捕获组的名称的时候，格式和使用数字表示捕获组的方式一样，都以`$`开头，但是命名捕获组的名称依旧要用`<>`包裹住。

### 4.3 Lookbehind 后行断言

JavaScript 中的正则之前只支持先行断言，不支持后行断言。但是 ES9 提供了正则的后行断言支持。

`(?<)`是后行断言的符号，`(?)`是先行断言的符号，然后结合`=`(等于)、`!`(不等)、`\1`(捕获匹配)。

先行断言表示先匹配断言前的正则，然后再判断其后面的断言是否满足。比如：

```JavaScript
const test = 'hello world'

console.log(test.match(/hello(?=\sworld)/))
// ["hello", index: 0, input: "hello world", groups: undefined]
```

后行断言则表示先判断断言是否满足，满足之后才匹配后续的正则。比如：

```JavaScript
const test = 'world hello'

console.log(test.match(/(?<=world\s)hello/))
// ["hello", index: 6, input: "world hello", groups: undefined]
```

### 4.4 Unicode 属性转义

ES2018 引入了一种新的写法`\p{...}`和`\P{...}`，允许正则表达式匹配符合某种 Unicode 属性的所有字符。

预设有如下几种匹配表达式：

* 使用`\p{Number}`来匹配所有的 Unicode 数字，`\P{Number}`匹配所有的非 Unicode 数字字符。
* 使用`\p{Alphabetic}`来匹配所有的 Unicode 单词字符，`\P{Alphabetic}`匹配所有的非 Unicode 单词字符。

比如：

```JavaScript
const str1 = '㉛'

console.log(/\d/u.test(str1))  // false
console.log(/\p{Number}/u.test(str1))  // true
console.log(/\P{Number}/u.test(str1))  // false

const str2 = 'ض'

console.log(/\w/u.test(str))  // false
console.log(/\p{Alphabetic}/u.test(str2))  // true
console.log(/\P{Alphabetic}/u.test(str2))  // false
```

